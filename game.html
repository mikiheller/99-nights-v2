<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>99 Nights Math Forest ‚Äì 3D Voxel Edition</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Kalam:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-deep: #02040a;
      --bg-panel: #0c1420;
      --bg-panel-soft: #151d2b;
      --accent-fire: #ff7b00;
      --accent-fire-soft: #ffb347;
      --accent-ok: #7cd992;
      --accent-bad: #ff5e5e;
      --text-main: #f6f3ea;
      --text-muted: #c4c4c4;
      --border-soft: rgba(255, 255, 255, 0.06);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #101529 0%, #02040a 60%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--text-main);
      overflow: hidden;
      overscroll-behavior: none;
      touch-action: pan-y pinch-zoom;
    }
    
    html {
      overscroll-behavior: none;
      touch-action: pan-y pinch-zoom;
    }

    .app {
      width: 1200px;
      max-width: 100vw;
      height: 100vh;
      border-radius: 0;
      background: radial-gradient(circle at top, #18243b 0%, #050814 50%, #02040a 100%);
      box-shadow:
        0 40px 80px rgba(0, 0, 0, 0.7),
        0 0 0 1px rgba(255, 255, 255, 0.02);
      padding: 20px;
      display: flex;
      gap: 20px;
    }

    /* Left side - Game view (3D Canvas) */
    
    .game-container {
      flex: 0 0 auto;
      width: 700px;
      height: 700px;
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
    }

    #gameCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Right side - Info panel */
    
    .info-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
    }

    .info-section {
      background: linear-gradient(180deg, #0c1420 0%, #060a16 100%);
      border: 1px solid var(--border-soft);
      border-radius: 12px;
      padding: 16px;
    }

    .info-section-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-muted);
      margin-bottom: 10px;
    }

    /* Day and Time combined */
    .day-time-row {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    
    .pause-button {
      flex: 0 0 auto;
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, var(--bg-panel-soft) 0%, var(--bg-panel) 100%);
      border: 1px solid var(--border-soft);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 18px;
    }
    
    .pause-button:hover {
      background: rgba(255, 123, 0, 0.1);
      border-color: var(--accent-fire);
      transform: scale(1.1);
    }

    .camera-toggle {
      flex: 0 0 auto;
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, var(--bg-panel-soft) 0%, var(--bg-panel) 100%);
      border: 1px solid var(--border-soft);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 18px;
    }
    
    .camera-toggle:hover {
      background: rgba(255, 123, 0, 0.1);
      border-color: var(--accent-fire);
      transform: scale(1.1);
    }
    
    .camera-toggle.first-person {
      background: rgba(255, 123, 0, 0.2);
      border-color: var(--accent-fire);
    }

    .lobby-button {
      flex: 0 0 auto;
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, var(--bg-panel-soft) 0%, var(--bg-panel) 100%);
      border: 1px solid var(--border-soft);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 18px;
    }
    
    .lobby-button:hover {
      background: rgba(255, 123, 0, 0.1);
      border-color: var(--accent-fire);
      transform: scale(1.1);
    }

    .game-mode-header {
      background: linear-gradient(135deg, rgba(255, 123, 0, 0.2) 0%, rgba(255, 123, 0, 0.05) 100%);
      border: 1px solid var(--accent-fire);
      border-radius: 12px;
      padding: 12px 16px;
      text-align: center;
      margin-bottom: 0;
    }

    .game-mode-title {
      font-size: 20px;
      font-weight: 700;
      color: var(--accent-fire);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .game-mode-subtitle {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 4px;
    }

    .fp-crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .fp-crosshair.visible {
      opacity: 0.8;
    }
    
    .fp-crosshair::before,
    .fp-crosshair::after {
      content: '';
      position: absolute;
      background: white;
      box-shadow: 0 0 3px rgba(0,0,0,0.5);
    }
    
    .fp-crosshair::before {
      width: 20px;
      height: 2px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    .fp-crosshair::after {
      width: 2px;
      height: 20px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    .fp-hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 12px;
      pointer-events: none;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .fp-hint.visible {
      opacity: 1;
    }

    .day-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-width: 0;
    }
    
    .day-counter {
      font-size: 24px;
      font-weight: 700;
      text-align: center;
      color: var(--text-main);
      white-space: nowrap;
    }
    
    .cycle-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-width: 0;
    }

    .cycle-icon {
      font-size: 32px;
      margin-bottom: 4px;
    }

    .cycle-countdown {
      font-size: 14px;
      color: var(--text-muted);
    }

    /* Inventory Grid - Category System */
    .inventory-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }

    .inv-category {
      background: var(--bg-panel-soft);
      border: 1px solid var(--border-soft);
      border-radius: 8px;
      padding: 12px;
      text-align: center;
      position: relative;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .inv-category:hover {
      background: rgba(255, 123, 0, 0.1);
      border-color: var(--accent-fire);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(255, 123, 0, 0.2);
    }

    .inv-category-icon {
      font-size: 24px;
      margin-bottom: 4px;
    }

    .inv-category-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
    }

    /* Dropdown System */
    .inv-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(180deg, #1a2332 0%, #0f1621 100%);
      border: 2px solid var(--accent-fire);
      border-radius: 12px;
      padding: 10px;
      min-width: 140px;
      z-index: 50;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
      margin-top: 0px;
      padding-top: 18px;
    }

    /* Invisible bridge area to keep dropdown open when moving mouse */
    .inv-dropdown::before {
      content: '';
      position: absolute;
      top: -20px;
      left: 0;
      right: 0;
      height: 25px;
      background: transparent;
    }
    
    /* Arrow pointer */
    .inv-dropdown::after {
      content: '';
      position: absolute;
      top: -8px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 8px solid var(--accent-fire);
    }

    .inv-category:hover .inv-dropdown {
      display: block;
    }

    .inv-dropdown-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s ease;
      margin-bottom: 4px;
    }

    .inv-dropdown-item:last-child {
      margin-bottom: 0;
    }

    .inv-dropdown-item:hover {
      background: rgba(255, 123, 0, 0.2);
    }

    .inv-dropdown-item.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .inv-dropdown-item.disabled:hover {
      background: transparent;
    }

    .inv-dropdown-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .inv-dropdown-icon {
      font-size: 18px;
    }

    .inv-dropdown-name {
      font-size: 12px;
      color: var(--text-main);
      font-weight: 500;
    }

    .inv-dropdown-count {
      font-size: 14px;
      font-weight: 700;
      color: var(--accent-fire-soft);
    }
    
    /* Rewards dropdown specific styles */
    .inv-dropdown-section {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--accent-fire);
      padding: 8px 12px 4px 12px;
      border-bottom: 1px solid var(--border-soft);
      margin-bottom: 4px;
      font-weight: 600;
    }
    
    .inv-dropdown-section:not(:first-child) {
      margin-top: 8px;
    }
    
    .reward-item.unearned {
      opacity: 0.4;
    }
    
    .reward-item.earned {
      background: rgba(124, 217, 146, 0.1);
    }
    
    .reward-item.earned .inv-dropdown-name::after {
      content: ' ‚úì';
      color: var(--accent-ok);
    }
    
    #rewardsDropdown {
      min-width: 200px;
      max-height: 400px;
      overflow-y: auto;
      /* Align to right edge instead of center to prevent cutoff */
      left: auto;
      right: 0;
      transform: none;
    }
    
    #rewardsDropdown::after {
      /* Move arrow to right side */
      left: auto;
      right: 20px;
      transform: none;
    }
    
    .chest-keys {
      font-size: 12px;
      color: var(--text-muted);
    }
    
    /* Diamond flying animation */
    .flying-diamond {
      position: fixed;
      font-size: 48px;
      z-index: 10000;
      pointer-events: none;
      filter: drop-shadow(0 0 10px rgba(100, 200, 255, 0.8));
    }
    
    @keyframes diamondPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }
    
    .diamond-burst {
      position: fixed;
      font-size: 64px;
      z-index: 10000;
      pointer-events: none;
      animation: diamondBurst 0.5s ease-out forwards;
    }
    
    @keyframes diamondBurst {
      0% { transform: scale(0.5); opacity: 0; }
      50% { transform: scale(1.5); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }

    /* Legacy classes for compatibility */
    .inv-item {
      background: var(--bg-panel-soft);
      border: 1px solid var(--border-soft);
      border-radius: 8px;
      padding: 12px;
      text-align: center;
      transition: all 0.2s ease;
    }

    .inv-item[style*="cursor: pointer"]:hover {
      background: rgba(255, 123, 0, 0.1);
      border-color: var(--accent-fire);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(255, 123, 0, 0.2);
    }

    .inv-icon {
      font-size: 24px;
      margin-bottom: 4px;
    }

    .inv-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .inv-count {
      font-size: 18px;
      font-weight: 700;
      color: var(--text-main);
    }

    /* Stats bars */
    .stat-bar-container {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .stat-bar-container:last-child {
      margin-bottom: 0;
    }

    .stat-icon {
      font-size: 24px;
      flex-shrink: 0;
    }

    .stat-bar-wrapper {
      flex: 1;
    }

    .stat-bar-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .stat-bar {
      height: 20px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid var(--border-soft);
    }

    .stat-bar-fill {
      height: 100%;
      transition: width 0.3s ease;
      border-radius: 10px;
    }

    .stat-bar-fill.health {
      background: linear-gradient(90deg, #9b59b6 0%, #bb8fce 100%);
      transition: background 0.3s ease;
    }
    
    .stat-bar-fill.health.medium {
      background: linear-gradient(90deg, #e67e22 0%, #f39c12 100%);
    }
    
    .stat-bar-fill.health.low {
      background: linear-gradient(90deg, #e74c3c 0%, #ec7063 100%);
    }
    
    .stat-bar-fill.health.critical {
      background: linear-gradient(90deg, #c0392b 0%, #e74c3c 100%);
    }
    
    .stat-bar-fill.hunger {
      background: linear-gradient(90deg, #27ae60 0%, #52be80 100%);
    }
    
    .stat-bar-fill.hunger.low {
      background: linear-gradient(90deg, #ff4444 0%, #ff6666 100%);
    }
    
    .stat-bar-fill.hunger.critical {
      background: linear-gradient(90deg, #ff0000 0%, #ff3333 100%);
      animation: hungerFlash 1.5s ease-in-out infinite;
    }
    
    .stat-bar.hunger-starving {
      border: 2px solid #ff0000;
      animation: hungerBarGlow 1s ease-in-out infinite;
    }
    
    @keyframes hungerFlash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.2; }
    }
    
    @keyframes hungerBarGlow {
      0%, 100% { 
        border-color: #ff0000;
        box-shadow: 0 0 10px rgba(255, 0, 0, 0.8), 0 0 20px rgba(255, 0, 0, 0.4);
      }
      50% { 
        border-color: #ff6666;
        box-shadow: 0 0 20px rgba(255, 0, 0, 1), 0 0 30px rgba(255, 0, 0, 0.6);
      }
    }

    .stat-bar-fill.fire {
      background: linear-gradient(90deg, #ff7b00 0%, #ffb347 100%);
    }

    /* Minimap */
    .minimap-container {
      position: relative;
      width: 150px;
      height: 150px;
      margin: 0 auto;
      border: 2px solid var(--border-soft);
      border-radius: 8px;
      overflow: hidden;
      background: #0a0a0a;
    }

    #minimapCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Math Dialog Bubble */
    .math-bubble {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #1a2332 0%, #0f1621 100%);
      border: 3px solid var(--accent-fire);
      border-radius: 20px;
      padding: 30px 40px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
      z-index: 100;
      min-width: 400px;
      text-align: center;
    }

    .math-bubble.active {
      display: block;
    }

    .math-bubble-label {
      font-size: 18px;
      font-weight: 600;
      color: var(--accent-fire-soft);
      margin-bottom: 20px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .math-question-counter {
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 10px;
    }

    .math-timer-bar {
      height: 8px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 20px;
      border: 1px solid var(--border-soft);
    }

    .math-timer-fill {
      height: 100%;
      background: linear-gradient(90deg, #7cd992 0%, #5fb377 100%);
      transition: width 0.1s linear;
      border-radius: 4px;
    }

    .math-timer-fill.danger {
      background: linear-gradient(90deg, #ff5e5e 0%, #ff3030 100%);
    }

    .math-question {
      font-size: 32px;
      font-weight: 700;
      color: var(--text-main);
      margin-bottom: 20px;
    }

    .math-input-row {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }

    .math-input {
      width: 100%;
      max-width: 200px;
    }

    .math-input input {
      width: 100%;
      padding: 12px 20px;
      font-size: 24px;
      text-align: center;
      background: rgba(0, 0, 0, 0.4);
      border: 2px solid var(--border-soft);
      border-radius: 12px;
      color: var(--text-main);
      font-weight: 600;
      transition: all 0.2s ease;
    }

    .math-input input:focus {
      outline: none;
      border-color: var(--accent-fire);
      box-shadow: 0 0 0 3px rgba(255, 123, 0, 0.2);
    }

    .math-submit {
      padding: 12px 40px;
      font-size: 16px;
      font-weight: 600;
      background: linear-gradient(135deg, var(--accent-fire) 0%, #ff5e00 100%);
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .math-submit:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 123, 0, 0.4);
    }

    .math-submit:active {
      transform: translateY(0);
    }

    .math-bubble-feedback {
      font-size: 14px;
      font-weight: 600;
      margin-top: 12px;
      min-height: 20px;
    }

    .math-bubble-feedback.good {
      color: var(--accent-ok);
    }

    .math-bubble-feedback.bad {
      color: var(--accent-bad);
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .pulse {
      animation: pulse 0.3s ease;
    }

    @keyframes fadeOut {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    .hunger-warning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: bold;
      color: #ff0000;
      text-shadow: 
        0 0 10px rgba(255, 0, 0, 0.8),
        0 0 20px rgba(255, 0, 0, 0.6),
        0 0 30px rgba(255, 0, 0, 0.4);
      z-index: 999;
      pointer-events: none;
      animation: fadeOut 1s ease-out;
    }
    
    .fire-warning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: bold;
      color: #ff7b00;
      text-shadow: 
        0 0 10px rgba(255, 123, 0, 0.8),
        0 0 20px rgba(255, 123, 0, 0.6),
        0 0 30px rgba(255, 123, 0, 0.4);
      z-index: 999;
      pointer-events: none;
      animation: fadeOut 1s ease-out;
    }
    
    .game-over-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      z-index: 99999;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 30px;
    }
    
    .game-over-overlay.active {
      display: flex;
    }
    
    .game-over-text {
      font-size: 96px;
      font-weight: bold;
      color: #ff0000;
      text-shadow: 
        0 0 20px rgba(255, 0, 0, 0.8),
        0 0 40px rgba(255, 0, 0, 0.6),
        0 0 60px rgba(255, 0, 0, 0.4),
        0 0 80px rgba(255, 0, 0, 0.2);
      animation: gameOverPulse 2s ease-in-out infinite;
    }
    
    .game-over-diamonds {
      font-size: 32px;
      color: #64d8ff;
      text-shadow: 
        0 0 10px rgba(100, 216, 255, 0.6);
    }
    
    @keyframes gameOverPulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.02); }
    }
    
    .pause-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      z-index: 10000;
      align-items: center;
      justify-content: center;
    }
    
    .pause-overlay.active {
      display: flex;
    }
    
    .play-button {
      width: 120px;
      height: 120px;
      background: linear-gradient(135deg, var(--accent-fire) 0%, #ff5e00 100%);
      border: 4px solid var(--accent-fire-soft);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 60px;
      color: white;
      box-shadow: 0 10px 40px rgba(255, 123, 0, 0.6);
    }
    
    .play-button:hover {
      transform: scale(1.1);
      box-shadow: 0 15px 50px rgba(255, 123, 0, 0.8);
    }
    
    /* Crafting Menu */
    .crafting-menu {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #1a2332 0%, #0f1621 100%);
      border: 3px solid var(--accent-fire);
      border-radius: 20px;
      padding: 25px 30px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
      z-index: 100;
      min-width: 380px;
      max-height: 80vh;
      flex-direction: column;
      display: none;
    }

    .crafting-menu.active {
      display: flex;
    }

    .crafting-menu-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      border-bottom: 2px solid var(--border-soft);
      padding-bottom: 15px;
    }

    .crafting-menu-title {
      font-size: 22px;
      font-weight: 700;
      color: var(--accent-fire-soft);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    
    .crafting-close-btn {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--bg-panel);
      border: 2px solid var(--accent-fire);
      color: var(--accent-fire);
      font-size: 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }
    
    .crafting-close-btn:hover {
      background: var(--accent-fire);
      color: white;
      transform: scale(1.1);
    }
    
    .crafting-inventory-display {
      display: flex;
      justify-content: center;
      gap: 24px;
      margin-bottom: 12px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
    }
    
    .crafting-inv-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 18px;
      font-weight: 600;
      color: var(--text-main);
    }

    .crafting-hint {
      font-size: 11px;
      color: var(--text-muted);
      text-align: center;
      margin-bottom: 15px;
    }

    .crafting-items {
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow-y: auto;
      max-height: 50vh;
      padding-right: 5px;
    }

    .crafting-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 16px;
      background: var(--bg-panel-soft);
      border: 2px solid var(--border-soft);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .crafting-item:hover:not(.disabled) {
      background: rgba(255, 123, 0, 0.15);
      border-color: var(--accent-fire);
      transform: translateX(4px);
    }

    .crafting-item.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .crafting-item.upgrade {
      background: linear-gradient(135deg, rgba(255, 123, 0, 0.2) 0%, rgba(255, 94, 0, 0.1) 100%);
      border-color: var(--accent-fire);
    }

    .crafting-item-left {
      display: flex;
      align-items: center;
      gap: 14px;
    }

    .crafting-item-icon {
      font-size: 28px;
      width: 40px;
      text-align: center;
    }

    .crafting-item-info {
      display: flex;
      flex-direction: column;
    }

    .crafting-item-name {
      font-size: 15px;
      font-weight: 600;
      color: var(--text-main);
      margin-bottom: 2px;
    }

    .crafting-item-desc {
      font-size: 11px;
      color: var(--text-muted);
    }

    .crafting-item-cost {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .crafting-cost-item {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 14px;
      color: var(--text-main);
    }

    .crafting-cost-item.insufficient {
      color: var(--accent-bad);
    }

    .crafting-cost-icon {
      font-size: 16px;
    }
    
    /* Hidden elements by default */
    .hidden-until-crafted {
      display: none !important;
    }

    /* XP & Level Display */
    .xp-section {
      padding: 12px 16px !important;
    }
    
    .xp-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .level-badge {
      background: linear-gradient(135deg, #ffd700 0%, #ff9500 100%);
      color: #1a1a2e;
      font-weight: 700;
      font-size: 14px;
      padding: 6px 12px;
      border-radius: 20px;
      white-space: nowrap;
      box-shadow: 0 2px 8px rgba(255, 215, 0, 0.3);
    }
    
    .xp-bar-wrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .xp-bar {
      height: 12px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid rgba(255, 215, 0, 0.3);
    }
    
    .xp-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #ffd700 0%, #ffaa00 100%);
      border-radius: 6px;
      transition: width 0.5s ease-out;
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }
    
    .xp-text {
      font-size: 11px;
      color: var(--text-muted);
      text-align: center;
    }
    
    .streak-badge {
      background: linear-gradient(135deg, #ff6b35 0%, #ff4500 100%);
      color: white;
      font-weight: 700;
      font-size: 14px;
      padding: 6px 10px;
      border-radius: 20px;
      white-space: nowrap;
      animation: streakPulse 1s ease-in-out infinite;
    }
    
    @keyframes streakPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    /* Crafting Tooltip */
    .crafting-tooltip {
      position: fixed;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      color: var(--accent-fire-soft);
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      border: 2px solid var(--accent-fire);
      z-index: 50;
      pointer-events: none;
      animation: tooltipPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes tooltipPulse {
      0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); }
      50% { opacity: 0.8; transform: translateX(-50%) scale(1.02); }
    }
  </style>
</head>
<body>

  <div class="app">
    <!-- Left: 3D Game View -->
    <div class="game-container">
      <canvas id="gameCanvas"></canvas>
      <div class="fp-crosshair" id="fpCrosshair"></div>
      <div class="fp-hint" id="fpHint">Click to enable mouse look ‚Ä¢ ESC to release ‚Ä¢ Press üëÅÔ∏è button to exit</div>
    </div>

    <!-- Right: Info Panel -->
    <div class="info-panel">
      <!-- Game Mode Header -->
      <div class="game-mode-header">
        <div class="game-mode-title">
          <span id="gameModeIcon">‚ûï</span>
          <span id="gameModeTitle">Addition Mode</span>
        </div>
        <div class="game-mode-subtitle">99 Nights Math Forest</div>
      </div>

      <!-- XP & Level -->
      <div class="info-section xp-section">
        <div class="xp-row">
          <div class="level-badge" id="levelText">Lvl 1</div>
          <div class="xp-bar-wrapper">
            <div class="xp-bar">
              <div class="xp-bar-fill" id="xpBar" style="width: 0%;"></div>
            </div>
            <div class="xp-text" id="xpText">0 / 100 XP</div>
          </div>
          <div class="streak-badge" id="streakBadge" style="display: none;">üî• <span id="streakCount">0</span></div>
        </div>
      </div>

      <!-- Day & Time -->
      <div class="info-section day-time-row">
        <div class="day-section">
          <div class="day-counter">Day <span id="dayCounter">1</span></div>
        </div>
        <div class="cycle-section" id="cycleSection" style="visibility: hidden;">
          <div class="cycle-icon" id="cycleIcon">‚òÄÔ∏è</div>
          <div class="cycle-countdown" id="cycleCountdown">3:00</div>
        </div>
        <div class="lobby-button" id="lobbyButton" title="Return to Portal Lobby">üö™</div>
        <div class="pause-button" id="pauseButton" title="Pause Game">‚è∏Ô∏è</div>
        <div class="camera-toggle" id="cameraToggle" title="Toggle First/Third Person View">üëÅÔ∏è</div>
      </div>

      <!-- Inventory -->
      <div class="info-section">
        <div class="info-section-title">Inventory</div>
        <div class="inventory-grid">
          <!-- FOOD Category -->
          <div class="inv-category" id="foodCategory">
            <div class="inv-category-icon">üçñ</div>
            <div class="inv-category-label">Food</div>
            <div class="inv-dropdown" id="foodDropdown">
              <div class="inv-dropdown-item" id="carrotItem" data-item="carrots">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">ü•ï</span>
                  <span class="inv-dropdown-name">Carrots</span>
                </div>
                <span class="inv-dropdown-count" id="carrotCount">0</span>
              </div>
              <div class="inv-dropdown-item" id="meatItem" data-item="meat">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">ü•©</span>
                  <span class="inv-dropdown-name">Meat</span>
                </div>
                <span class="inv-dropdown-count" id="meatCount">0</span>
              </div>
              <div class="inv-dropdown-item" id="stewItem" data-item="stew">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">üç≤</span>
                  <span class="inv-dropdown-name">Stew</span>
                </div>
                <span class="inv-dropdown-count" id="stewCount">0</span>
              </div>
            </div>
          </div>
          
          <!-- SUPPLIES Category (Wood, Metal, Fuel) -->
          <div class="inv-category" id="suppliesCategory">
            <div class="inv-category-icon">ü™µ</div>
            <div class="inv-category-label">Supplies</div>
            <div class="inv-dropdown" id="suppliesDropdown">
              <div class="inv-dropdown-item" id="woodItem" data-item="wood">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">ü™µ</span>
                  <span class="inv-dropdown-name">Wood</span>
                </div>
                <span class="inv-dropdown-count" id="woodCount">0</span>
              </div>
              <div class="inv-dropdown-item" id="metalItem" data-item="metal">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">üîß</span>
                  <span class="inv-dropdown-name">Metal</span>
                </div>
                <span class="inv-dropdown-count" id="scrapCount">0</span>
              </div>
              <div class="inv-dropdown-item" id="fuelItem" data-item="fuel">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">‚õΩ</span>
                  <span class="inv-dropdown-name">Fuel</span>
                </div>
                <span class="inv-dropdown-count" id="coalCount">0</span>
              </div>
            </div>
          </div>
          
          <!-- WEAPONS Category -->
          <div class="inv-category" id="weaponsCategory">
            <div class="inv-category-icon">‚öîÔ∏è</div>
            <div class="inv-category-label">Weapons</div>
            <div class="inv-dropdown" id="weaponsDropdown">
              <div class="inv-dropdown-item" id="axeItem" data-item="axe">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">ü™ì</span>
                  <span class="inv-dropdown-name" id="axeName">Old Axe</span>
                </div>
              </div>
              <div class="inv-dropdown-item" id="spearItem" data-item="spear" style="display: none;">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">üî±</span>
                  <span class="inv-dropdown-name">Spear</span>
                </div>
                <span class="inv-dropdown-desc" style="font-size: 10px; color: #888;">2-shot wolves</span>
              </div>
            </div>
          </div>
          
          <!-- REWARDS Category -->
          <div class="inv-category" id="rewardsCategory">
            <div class="inv-category-icon">üíé</div>
            <div class="inv-category-label">Rewards <span id="rewardsDiamondCount">0</span></div>
            <div class="inv-dropdown" id="rewardsDropdown">
              <!-- Chests Section -->
              <div class="inv-dropdown-section">Chests</div>
              <div class="inv-dropdown-item reward-item" id="woodenChestReward" data-reward="woodenChest">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">üì¶</span>
                  <span class="inv-dropdown-name">Wooden Chest</span>
                </div>
                <span class="inv-dropdown-count chest-keys" id="woodenChestKeys">üîë√ó0/3</span>
              </div>
              <div class="inv-dropdown-item reward-item" id="goldenChestReward" data-reward="goldenChest">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">üì¶</span>
                  <span class="inv-dropdown-name">Golden Chest</span>
                </div>
                <span class="inv-dropdown-count chest-keys" id="goldenChestKeys">üîë√ó0/4</span>
              </div>
              <div class="inv-dropdown-item reward-item" id="rubyChestReward" data-reward="rubyChest">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">üì¶</span>
                  <span class="inv-dropdown-name">Ruby Chest</span>
                </div>
                <span class="inv-dropdown-count chest-keys" id="rubyChestKeys">üîë√ó0/5</span>
              </div>
              <div class="inv-dropdown-item reward-item" id="diamondChestReward" data-reward="diamondChest">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">üì¶</span>
                  <span class="inv-dropdown-name">Diamond Chest</span>
                </div>
                <span class="inv-dropdown-count chest-keys" id="diamondChestKeys">üîë√ó0/6</span>
              </div>
              <div class="inv-dropdown-item reward-item" id="obsidianChestReward" data-reward="obsidianChest">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">üì¶</span>
                  <span class="inv-dropdown-name">Obsidian Chest</span>
                </div>
                <span class="inv-dropdown-count chest-keys" id="obsidianChestKeys">üîë√ó0/7</span>
              </div>
              
              <!-- Rare Items Section -->
              <div class="inv-dropdown-section">Rare Items</div>
              <div class="inv-dropdown-item reward-item" id="lanternbarkReward" data-reward="lanternbark">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">‚ú®üå≥</span>
                  <span class="inv-dropdown-name">Enchanted Tree</span>
                </div>
                <span class="inv-dropdown-count">+1üíé</span>
              </div>
              <div class="inv-dropdown-item reward-item" id="silverWolfReward" data-reward="silverWolf">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">‚ú®üê∫</span>
                  <span class="inv-dropdown-name">Enchanted Wolf</span>
                </div>
                <span class="inv-dropdown-count">+1üíé</span>
              </div>
              <div class="inv-dropdown-item reward-item" id="whisperingFanReward" data-reward="whisperingFan">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">‚ú®üîß</span>
                  <span class="inv-dropdown-name">Enchanted Scrap</span>
                </div>
                <span class="inv-dropdown-count">+1üíé</span>
              </div>
              <div class="inv-dropdown-item reward-item" id="frostCanisterReward" data-reward="frostCanister">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">‚ú®‚õΩ</span>
                  <span class="inv-dropdown-name">Enchanted Fuel</span>
                </div>
                <span class="inv-dropdown-count">+1üíé</span>
              </div>
              
              <!-- Milestones Section -->
              <div class="inv-dropdown-section">Milestones</div>
              <div class="inv-dropdown-item reward-item" id="day10Reward" data-reward="day10">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">üèÅ</span>
                  <span class="inv-dropdown-name">Reach Day 10</span>
                </div>
                <span class="inv-dropdown-count">+1üíé</span>
              </div>
              <div class="inv-dropdown-item reward-item" id="day20Reward" data-reward="day20">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">üèÅ</span>
                  <span class="inv-dropdown-name">Reach Day 20</span>
                </div>
                <span class="inv-dropdown-count">+2üíé</span>
              </div>
              <div class="inv-dropdown-item reward-item" id="day40Reward" data-reward="day40">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">üèÅ</span>
                  <span class="inv-dropdown-name">Reach Day 40</span>
                </div>
                <span class="inv-dropdown-count">+3üíé</span>
              </div>
              <div class="inv-dropdown-item reward-item" id="day60Reward" data-reward="day60">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">üèÅ</span>
                  <span class="inv-dropdown-name">Reach Day 60</span>
                </div>
                <span class="inv-dropdown-count">+4üíé</span>
              </div>
              <div class="inv-dropdown-item reward-item" id="day99Reward" data-reward="day99">
                <div class="inv-dropdown-left">
                  <span class="inv-dropdown-icon">üèÜ</span>
                  <span class="inv-dropdown-name">Reach Day 99</span>
                </div>
                <span class="inv-dropdown-count">+5üíé</span>
              </div>
            </div>
          </div>
          
        </div>
      </div>

      <!-- Stats -->
      <div class="info-section">
        <div class="info-section-title">Status</div>
        <div class="stat-bar-container">
          <div class="stat-icon">‚ù§Ô∏è</div>
          <div class="stat-bar-wrapper">
            <div class="stat-bar-label">Health</div>
            <div class="stat-bar">
              <div class="stat-bar-fill health" id="healthBar" style="width: 100%;"></div>
            </div>
          </div>
        </div>
        <div class="stat-bar-container">
          <div class="stat-icon">üçñ</div>
          <div class="stat-bar-wrapper">
            <div class="stat-bar-label">Hunger</div>
            <div class="stat-bar">
              <div class="stat-bar-fill hunger" id="hungerBar" style="width: 100%;"></div>
            </div>
          </div>
        </div>
        <div class="stat-bar-container">
          <div class="stat-icon">üî•</div>
          <div class="stat-bar-wrapper">
            <div class="stat-bar-label">Fire (Level <span id="fireLevel">1</span>)</div>
            <div class="stat-bar">
              <div class="stat-bar-fill fire" id="fireBar" style="width: 0%;"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Minimap -->
      <div class="info-section" id="minimapSection" style="display: none;">
        <div class="info-section-title">Map</div>
        <div class="minimap-container">
          <canvas id="minimapCanvas" width="150" height="150"></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- Math Dialog -->
  <div class="math-bubble" id="mathBubble">
    <div class="math-bubble-label" id="mathBubbleLabel">Solve to Continue</div>
    <div class="math-question-counter" id="mathQuestionCounter"></div>
    <div class="math-timer-bar" id="mathTimerBar" style="display: none;">
      <div class="math-timer-fill" id="mathTimerFill"></div>
    </div>
    <div class="math-question" id="mathQuestion">2 + 3 = ?</div>
    <div class="math-input-row">
      <div class="math-input">
        <input type="text" inputmode="numeric" pattern="[0-9]*" id="mathAnswerInput" placeholder="?" autofocus />
      </div>
      <button class="math-submit" id="mathSubmitButton">Submit</button>
    </div>
    <div class="math-bubble-feedback" id="mathBubbleFeedback"></div>
  </div>

  <!-- Pause Overlay -->
  <div class="pause-overlay" id="pauseOverlay">
    <div class="play-button" id="playButton" title="Resume Game">‚ñ∂Ô∏è</div>
  </div>

  <!-- Game Over Overlay -->
  <div class="game-over-overlay" id="gameOverOverlay">
    <div class="game-over-text">YOU DIED</div>
    <div class="game-over-diamonds" id="gameOverDiamonds">You earned 0 diamonds</div>
  </div>

  <!-- Crafting Menu -->
  <div class="crafting-menu" id="craftingMenu">
    <div class="crafting-menu-header">
      <div class="crafting-menu-title">‚öíÔ∏è Crafting</div>
      <button class="crafting-close-btn" id="craftingCloseBtn">‚úï</button>
    </div>
    <div class="crafting-inventory-display">
      <div class="crafting-inv-item"><span>ü™µ</span><span id="craftingWoodCount">0</span></div>
      <div class="crafting-inv-item"><span>üîß</span><span id="craftingMetalCount">0</span></div>
    </div>
    <div class="crafting-hint">Click an item to craft</div>
    <div class="crafting-items" id="craftingItems">
      <!-- Items will be populated by JavaScript -->
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    // ============================================
    // THREE.JS SETUP
    // ============================================
    
    const canvas = document.getElementById('gameCanvas');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // Sky blue
    
    // Camera - top-down isometric view
    const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
    camera.position.set(0, 30, 30);
    camera.lookAt(0, 0, 0);
    
    // Renderer
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(700, 700);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 100, 50);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.left = -100;
    directionalLight.shadow.camera.right = 100;
    directionalLight.shadow.camera.top = 100;
    directionalLight.shadow.camera.bottom = -100;
    scene.add(directionalLight);
    
    // ============================================
    // VOXEL MODEL BUILDERS
    // ============================================
    
    function createTree(x, z, isEnchanted = false) {
      const group = new THREE.Group();
      
      // Trunk (2 cubes) - looks normal even if enchanted (surprise!)
      const trunkGeometry = new THREE.BoxGeometry(1, 1, 1);
      const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      
      const trunk1 = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk1.position.y = 0.5;
      trunk1.castShadow = true;
      trunk1.receiveShadow = true;
      group.add(trunk1);
      
      const trunk2 = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk2.position.y = 1.5;
      trunk2.castShadow = true;
      trunk2.receiveShadow = true;
      group.add(trunk2);
      
      // Leaves (3x3x3 cube cluster) - looks normal even if enchanted
      const leavesGeometry = new THREE.BoxGeometry(1, 1, 1);
      const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = 0; dy <= 2; dy++) {
          for (let dz = -1; dz <= 1; dz++) {
            // Skip some blocks to make it look more tree-like
            if (dy === 0 && Math.abs(dx) + Math.abs(dz) > 1) continue;
            if (dy === 2 && (Math.abs(dx) === 1 || Math.abs(dz) === 1)) continue;
            
            const leaf = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaf.position.set(dx, 2.5 + dy, dz);
            leaf.castShadow = true;
            leaf.receiveShadow = true;
            group.add(leaf);
          }
        }
      }
      
      group.position.set(x, 0, z);
      group.userData = { type: 'tree', action: 'chop', worldX: x, worldZ: z, isEnchanted: isEnchanted };
      return group;
    }
    
    function createWolf(x, z) {
      const group = new THREE.Group();
      const wolfMaterial = new THREE.MeshLambertMaterial({ color: 0x606060 });
      const darkWolfMaterial = new THREE.MeshLambertMaterial({ color: 0x404040 });
      
      // Body (longer and lower)
      const bodyGeometry = new THREE.BoxGeometry(1.5, 1, 1.2);
      const body = new THREE.Mesh(bodyGeometry, wolfMaterial);
      body.position.y = 0.8;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Neck
      const neckGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.8);
      const neck = new THREE.Mesh(neckGeometry, wolfMaterial);
      neck.position.set(1.0, 1.1, 0);
      neck.castShadow = true;
      neck.receiveShadow = true;
      group.add(neck);
      
      // Head (main part)
      const headGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
      const head = new THREE.Mesh(headGeometry, wolfMaterial);
      head.position.set(1.6, 1.4, 0);
      head.castShadow = true;
      head.receiveShadow = true;
      group.add(head);
      
      // Snout (elongated)
      const snoutGeometry = new THREE.BoxGeometry(0.6, 0.5, 0.6);
      const snout = new THREE.Mesh(snoutGeometry, darkWolfMaterial);
      snout.position.set(2.1, 1.3, 0);
      snout.castShadow = true;
      snout.receiveShadow = true;
      group.add(snout);
      
      // Ears (2 triangular-ish)
      const earGeometry = new THREE.BoxGeometry(0.3, 0.5, 0.3);
      const leftEar = new THREE.Mesh(earGeometry, darkWolfMaterial);
      leftEar.position.set(1.6, 1.9, 0.35);
      leftEar.castShadow = true;
      leftEar.receiveShadow = true;
      group.add(leftEar);
      
      const rightEar = new THREE.Mesh(earGeometry, darkWolfMaterial);
      rightEar.position.set(1.6, 1.9, -0.35);
      rightEar.castShadow = true;
      rightEar.receiveShadow = true;
      group.add(rightEar);
      
      // Tail (curved upward)
      const tailBase = new THREE.BoxGeometry(0.4, 0.4, 0.4);
      const tail1 = new THREE.Mesh(tailBase, wolfMaterial);
      tail1.position.set(-0.9, 0.9, 0);
      tail1.castShadow = true;
      tail1.receiveShadow = true;
      group.add(tail1);
      
      const tail2 = new THREE.Mesh(tailBase, wolfMaterial);
      tail2.position.set(-1.2, 1.2, 0);
      tail2.castShadow = true;
      tail2.receiveShadow = true;
      group.add(tail2);
      
      const tail3 = new THREE.Mesh(tailBase, darkWolfMaterial);
      tail3.position.set(-1.4, 1.5, 0);
      tail3.castShadow = true;
      tail3.receiveShadow = true;
      group.add(tail3);
      
      // Legs (4) - thinner and positioned better
      const legGeometry = new THREE.BoxGeometry(0.35, 1, 0.35);
      const legPositions = [
        [1, 0, 0.4],    // Front left
        [1, 0, -0.4],   // Front right
        [-0.8, 0, 0.4], // Back left
        [-0.8, 0, -0.4] // Back right
      ];
      
      legPositions.forEach(pos => {
        const leg = new THREE.Mesh(legGeometry, wolfMaterial);
        leg.position.set(pos[0], 0.5, pos[2]);
        leg.castShadow = true;
        leg.receiveShadow = true;
        group.add(leg);
      });
      
      // Paws (darker)
      const pawGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.4);
      legPositions.forEach(pos => {
        const paw = new THREE.Mesh(pawGeometry, darkWolfMaterial);
        paw.position.set(pos[0], 0.1, pos[2]);
        paw.castShadow = true;
        paw.receiveShadow = true;
        group.add(paw);
      });
      
      group.position.set(x, 0, z);
      group.userData = { type: 'wolf', action: 'fightWolf', worldX: x, worldZ: z };
      return group;
    }
    
    function createFuelCanister(x, z) {
      const group = new THREE.Group();
      
      // Main body - red rectangular canister (wider)
      const bodyGeometry = new THREE.BoxGeometry(1.1, 1.5, 0.6);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xCC0000 }); // Bright red
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.75;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Black screw cap on one side (top-left corner)
      const capGeometry = new THREE.BoxGeometry(0.35, 0.3, 0.35);
      const capMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 }); // Black
      const cap = new THREE.Mesh(capGeometry, capMaterial);
      cap.position.set(-0.3, 1.65, 0); // Positioned on the left side
      cap.castShadow = true;
      cap.receiveShadow = true;
      group.add(cap);
      
      group.position.set(x, 0, z);
      group.userData = { type: 'fuel', action: 'collectFuel', worldX: x, worldZ: z };
      return group;
    }
    
    function createBrokenFan(x, z) {
      const group = new THREE.Group();
      
      // Base/stand - teal like in the image
      const baseGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.6);
      const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x63a66c }); // Exact teal from image
      const base = new THREE.Mesh(baseGeometry, baseMaterial);
      base.position.y = 0.15;
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);
      
      // Pole/stand - teal
      const poleGeometry = new THREE.BoxGeometry(0.2, 1, 0.2);
      const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x63a66c }); // Exact teal from image
      const pole = new THREE.Mesh(poleGeometry, poleMaterial);
      pole.position.y = 0.8;
      pole.castShadow = true;
      pole.receiveShadow = true;
      group.add(pole);
      
      // Fan center/motor - darker gray
      const centerGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.3);
      const centerMaterial = new THREE.MeshLambertMaterial({ color: 0x505050 });
      const center = new THREE.Mesh(centerGeometry, centerMaterial);
      center.position.y = 1.4;
      center.castShadow = true;
      center.receiveShadow = true;
      group.add(center);
      
      // Fan blades (3 blades) - rusty/broken looking
      const bladeGeometry = new THREE.BoxGeometry(0.15, 0.8, 0.05);
      const bladeMaterial = new THREE.MeshLambertMaterial({ color: 0xA0826D }); // Rusty beige
      
      // Blade 1 (top)
      const blade1 = new THREE.Mesh(bladeGeometry, bladeMaterial);
      blade1.position.set(0, 1.8, 0.2);
      blade1.castShadow = true;
      blade1.receiveShadow = true;
      group.add(blade1);
      
      // Blade 2 (bottom left)
      const blade2 = new THREE.Mesh(bladeGeometry, bladeMaterial);
      blade2.position.set(-0.35, 1.1, 0.2);
      blade2.rotation.z = Math.PI * 2 / 3;
      blade2.castShadow = true;
      blade2.receiveShadow = true;
      group.add(blade2);
      
      // Blade 3 (bottom right)
      const blade3 = new THREE.Mesh(bladeGeometry, bladeMaterial);
      blade3.position.set(0.35, 1.1, 0.2);
      blade3.rotation.z = -Math.PI * 2 / 3;
      blade3.castShadow = true;
      blade3.receiveShadow = true;
      group.add(blade3);
      
      group.position.set(x, 0, z);
      group.userData = { type: 'fan', action: 'salvageFan', metalValue: 2, worldX: x, worldZ: z };
      return group;
    }
    
    function createBolt(x, z) {
      const group = new THREE.Group();
      
      // Bolt head (hexagonal approximated with a cylinder-ish box)
      const headGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.25, 6);
      const boltMaterial = new THREE.MeshLambertMaterial({ color: 0x8B8682 }); // Gray metal
      const head = new THREE.Mesh(headGeometry, boltMaterial);
      head.position.y = 0.9;
      head.castShadow = true;
      head.receiveShadow = true;
      group.add(head);
      
      // Bolt shaft
      const shaftGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.8, 8);
      const shaft = new THREE.Mesh(shaftGeometry, boltMaterial);
      shaft.position.y = 0.4;
      shaft.castShadow = true;
      shaft.receiveShadow = true;
      group.add(shaft);
      
      // Thread ridges (simple rings)
      const threadMaterial = new THREE.MeshLambertMaterial({ color: 0x6B6662 });
      for (let i = 0; i < 4; i++) {
        const threadGeometry = new THREE.TorusGeometry(0.18, 0.03, 4, 8);
        const thread = new THREE.Mesh(threadGeometry, threadMaterial);
        thread.position.y = 0.15 + i * 0.15;
        thread.rotation.x = Math.PI / 2;
        thread.castShadow = true;
        group.add(thread);
      }
      
      group.position.set(x, 0, z);
      group.userData = { type: 'bolt', action: 'salvageBolt', metalValue: 1, worldX: x, worldZ: z };
      return group;
    }
    
    function createOldRadio(x, z) {
      const group = new THREE.Group();
      
      // Main body - dark/rusty box
      const bodyGeometry = new THREE.BoxGeometry(1.4, 1.0, 0.8);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a2a }); // Dark gray/black
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.5;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Rusty/worn stripe across front
      const stripeGeometry = new THREE.BoxGeometry(1.35, 0.5, 0.05);
      const rustMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Rust brown
      const stripe = new THREE.Mesh(stripeGeometry, rustMaterial);
      stripe.position.set(0, 0.35, 0.41);
      stripe.castShadow = true;
      group.add(stripe);
      
      // Speaker grille lines
      const grilleMaterial = new THREE.MeshLambertMaterial({ color: 0x5a5a5a });
      for (let i = 0; i < 4; i++) {
        const grilleGeometry = new THREE.BoxGeometry(0.8, 0.06, 0.05);
        const grilleLine = new THREE.Mesh(grilleGeometry, grilleMaterial);
        grilleLine.position.set(-0.2, 0.2 + i * 0.12, 0.42);
        group.add(grilleLine);
      }
      
      // Dial/knob on right side
      const dialGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 12);
      const dialMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
      const dial = new THREE.Mesh(dialGeometry, dialMaterial);
      dial.position.set(0.45, 0.6, 0.45);
      dial.rotation.x = Math.PI / 2;
      dial.castShadow = true;
      group.add(dial);
      
      // Antenna (broken/bent)
      const antennaMaterial = new THREE.MeshLambertMaterial({ color: 0x909090 });
      const antenna1Geometry = new THREE.CylinderGeometry(0.03, 0.03, 0.6, 6);
      const antenna1 = new THREE.Mesh(antenna1Geometry, antennaMaterial);
      antenna1.position.set(0.5, 1.2, 0);
      antenna1.rotation.z = 0.3; // Slightly tilted
      antenna1.castShadow = true;
      group.add(antenna1);
      
      // Broken antenna piece
      const antenna2Geometry = new THREE.CylinderGeometry(0.025, 0.03, 0.3, 6);
      const antenna2 = new THREE.Mesh(antenna2Geometry, antennaMaterial);
      antenna2.position.set(0.6, 1.5, 0);
      antenna2.rotation.z = 0.8; // More bent
      antenna2.castShadow = true;
      group.add(antenna2);
      
      group.position.set(x, 0, z);
      group.userData = { type: 'radio', action: 'salvageRadio', metalValue: 3, worldX: x, worldZ: z };
      return group;
    }
    
    function createKey(x, z, tier) {
      const group = new THREE.Group();
      
      // Key colors by tier
      const keyColors = {
        wooden: { main: 0xDEB887, dark: 0x8B4513, glow: 0xFFD700 },  // Burlywood/brown
        golden: { main: 0xFFD700, dark: 0xDAA520, glow: 0xFFD700 },
        ruby: { main: 0xFF3366, dark: 0xCC0033, glow: 0xFF6699 },
        diamond: { main: 0x66FFFF, dark: 0x00CCCC, glow: 0x00FFFF },
        obsidian: { main: 0x9966FF, dark: 0x6633CC, glow: 0xCC99FF }
      };
      
      const colors = keyColors[tier] || keyColors.wooden;
      const keyMaterial = new THREE.MeshBasicMaterial({ color: colors.main });
      const darkMaterial = new THREE.MeshBasicMaterial({ color: colors.dark });
      
      // Simple key design - circular handle
      const handleGeometry = new THREE.TorusGeometry(0.4, 0.12, 8, 16);
      const handle = new THREE.Mesh(handleGeometry, keyMaterial);
      handle.rotation.x = Math.PI / 2;
      handle.position.set(-0.6, 0.2, 0);
      group.add(handle);
      
      // Key shaft
      const shaftGeometry = new THREE.BoxGeometry(1.2, 0.2, 0.15);
      const shaft = new THREE.Mesh(shaftGeometry, keyMaterial);
      shaft.position.set(0.4, 0.2, 0);
      group.add(shaft);
      
      // Key teeth (3 simple teeth)
      const teethPositions = [0.7, 0.9, 1.0];
      teethPositions.forEach((tx, i) => {
        const toothHeight = 0.2 + (i * 0.1);
        const tooth = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.15, toothHeight),
          darkMaterial
        );
        tooth.position.set(tx, 0.2, toothHeight / 2);
        group.add(tooth);
      });
      
      group.position.set(x, 0, z);
      group.userData = { type: 'key', action: 'collectKey', tier: tier, worldX: x, worldZ: z };
      return group;
    }
    
    function createChest(x, z, tier) {
      const group = new THREE.Group();
      
      // Chest colors by tier
      const chestColors = {
        wooden: { main: 0x8B4513, trim: 0x5D3A1A, lock: 0xB8860B, emissive: 0x000000 },
        golden: { main: 0xFFD700, trim: 0xB8860B, lock: 0xFFFFFF, emissive: 0x332200 },
        ruby: { main: 0xE0115F, trim: 0x8B0A3A, lock: 0xFFD700, emissive: 0x220011 },
        diamond: { main: 0x00BFFF, trim: 0x0080AA, lock: 0xFFFFFF, emissive: 0x112233 },
        obsidian: { main: 0x1a1a2e, trim: 0x4B0082, lock: 0x9400D3, emissive: 0x110022 }
      };
      
      const colors = chestColors[tier] || chestColors.wooden;
      const mainMaterial = new THREE.MeshLambertMaterial({ 
        color: colors.main,
        emissive: colors.emissive
      });
      const trimMaterial = new THREE.MeshLambertMaterial({ color: colors.trim });
      const lockMaterial = new THREE.MeshLambertMaterial({ 
        color: colors.lock,
        emissive: tier !== 'wooden' ? 0x222222 : 0x000000
      });
      
      // Chest base (bottom half)
      const baseGeometry = new THREE.BoxGeometry(2.5, 1.2, 1.8);
      const base = new THREE.Mesh(baseGeometry, mainMaterial);
      base.position.set(0, 0.6, 0);
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);
      
      // Chest lid (top half, slightly arched)
      const lidGeometry = new THREE.BoxGeometry(2.5, 0.8, 1.8);
      const lid = new THREE.Mesh(lidGeometry, mainMaterial);
      lid.position.set(0, 1.6, 0);
      lid.castShadow = true;
      lid.receiveShadow = true;
      group.add(lid);
      
      // Arched top of lid
      const archGeometry = new THREE.BoxGeometry(2.5, 0.3, 1.4);
      const arch = new THREE.Mesh(archGeometry, mainMaterial);
      arch.position.set(0, 2.1, 0);
      arch.castShadow = true;
      group.add(arch);
      
      // Trim bands (horizontal straps)
      const bandPositions = [0.3, 0.9, 1.3, 1.8];
      bandPositions.forEach(y => {
        const band = new THREE.Mesh(
          new THREE.BoxGeometry(2.6, 0.15, 1.9),
          trimMaterial
        );
        band.position.set(0, y, 0);
        band.castShadow = true;
        group.add(band);
      });
      
      // Corner trims (vertical)
      const corners = [
        { x: -1.2, z: -0.85 },
        { x: -1.2, z: 0.85 },
        { x: 1.2, z: -0.85 },
        { x: 1.2, z: 0.85 }
      ];
      corners.forEach(pos => {
        const cornerTrim = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 2.2, 0.2),
          trimMaterial
        );
        cornerTrim.position.set(pos.x, 1.1, pos.z);
        cornerTrim.castShadow = true;
        group.add(cornerTrim);
      });
      
      // Lock plate (front)
      const lockPlate = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.8, 0.1),
        lockMaterial
      );
      lockPlate.position.set(0, 1.2, 0.95);
      lockPlate.castShadow = true;
      group.add(lockPlate);
      
      // Keyhole
      const keyhole = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.3, 0.12),
        new THREE.MeshLambertMaterial({ color: 0x111111 })
      );
      keyhole.position.set(0, 1.15, 0.97);
      group.add(keyhole);
      
      // Glowing base for visibility
      const glowGeometry = new THREE.BoxGeometry(3.5, 0.05, 2.8);
      const glowMaterial = new THREE.MeshBasicMaterial({ 
        color: colors.main, 
        transparent: true, 
        opacity: 0.5 
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glow.position.y = 0.02;
      group.add(glow);
      
      // Beacon light for spotting from afar
      const beaconGeometry = new THREE.BoxGeometry(0.4, 4, 0.4);
      const beaconMaterial = new THREE.MeshBasicMaterial({ 
        color: colors.main, 
        transparent: true, 
        opacity: 0.4 
      });
      const beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
      beacon.position.set(0, 3, 0);
      group.add(beacon);
      
      // Sparkle particles around the chest (for special tiers)
      if (tier !== 'wooden') {
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          const sparkle = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.15, 0.15),
            new THREE.MeshBasicMaterial({ color: colors.lock })
          );
          sparkle.position.set(
            Math.cos(angle) * 1.8,
            1.5 + Math.sin(i) * 0.5,
            Math.sin(angle) * 1.3
          );
          sparkle.userData.sparkleAngle = angle;
          sparkle.userData.sparkleOffset = i;
          group.add(sparkle);
        }
      }
      
      group.position.set(x, 0, z);
      group.userData = { type: 'chest', action: 'openChest', tier: tier, worldX: x, worldZ: z };
      return group;
    }
    
    function createDeerMonster(x, z) {
      const group = new THREE.Group();
      
      // Colors based on the reference image
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3728 }); // Dark brown body
      const skinMaterial = new THREE.MeshLambertMaterial({ color: 0x8b7355 }); // Lighter face
      const antlerMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a }); // Black antlers
      const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 }); // Black
      const eyeWhiteMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff }); // White eye rings
      const earMaterial = new THREE.MeshLambertMaterial({ color: 0xc4a4a4 }); // Pink inner ears
      
      // Body (humanoid torso, leaning forward)
      const bodyGeometry = new THREE.BoxGeometry(1.2, 1.6, 0.8);
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 1.4, 0);
      body.rotation.x = 0.2; // Slight lean forward
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Legs (digitigrade style - bent backwards at knee)
      const upperLegGeometry = new THREE.BoxGeometry(0.35, 0.9, 0.35);
      const lowerLegGeometry = new THREE.BoxGeometry(0.25, 0.8, 0.25);
      const hoofGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.4);
      const hoofMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      
      // Left leg
      const leftUpperLeg = new THREE.Mesh(upperLegGeometry, bodyMaterial);
      leftUpperLeg.position.set(-0.3, 0.6, 0.2);
      leftUpperLeg.rotation.x = -0.3;
      group.add(leftUpperLeg);
      
      const leftLowerLeg = new THREE.Mesh(lowerLegGeometry, bodyMaterial);
      leftLowerLeg.position.set(-0.3, 0.1, -0.1);
      group.add(leftLowerLeg);
      
      const leftHoof = new THREE.Mesh(hoofGeometry, hoofMaterial);
      leftHoof.position.set(-0.3, 0.1, 0.1);
      group.add(leftHoof);
      
      // Right leg
      const rightUpperLeg = new THREE.Mesh(upperLegGeometry, bodyMaterial);
      rightUpperLeg.position.set(0.3, 0.6, 0.2);
      rightUpperLeg.rotation.x = -0.3;
      group.add(rightUpperLeg);
      
      const rightLowerLeg = new THREE.Mesh(lowerLegGeometry, bodyMaterial);
      rightLowerLeg.position.set(0.3, 0.1, -0.1);
      group.add(rightLowerLeg);
      
      const rightHoof = new THREE.Mesh(hoofGeometry, hoofMaterial);
      rightHoof.position.set(0.3, 0.1, 0.1);
      group.add(rightHoof);
      
      // Arms (long, creepy, with claws)
      const upperArmGeometry = new THREE.BoxGeometry(0.25, 1.0, 0.25);
      const lowerArmGeometry = new THREE.BoxGeometry(0.2, 0.9, 0.2);
      const clawGeometry = new THREE.BoxGeometry(0.08, 0.4, 0.08);
      
      // Left arm
      const leftUpperArm = new THREE.Mesh(upperArmGeometry, bodyMaterial);
      leftUpperArm.position.set(-0.8, 1.6, 0);
      leftUpperArm.rotation.z = 0.4;
      group.add(leftUpperArm);
      
      const leftLowerArm = new THREE.Mesh(lowerArmGeometry, bodyMaterial);
      leftLowerArm.position.set(-1.2, 1.0, 0);
      leftLowerArm.rotation.z = 0.2;
      group.add(leftLowerArm);
      
      // Left claws
      for (let i = -1; i <= 1; i++) {
        const claw = new THREE.Mesh(clawGeometry, antlerMaterial);
        claw.position.set(-1.4, 0.4, i * 0.12);
        claw.rotation.z = 0.3;
        group.add(claw);
      }
      
      // Right arm
      const rightUpperArm = new THREE.Mesh(upperArmGeometry, bodyMaterial);
      rightUpperArm.position.set(0.8, 1.6, 0);
      rightUpperArm.rotation.z = -0.4;
      group.add(rightUpperArm);
      
      const rightLowerArm = new THREE.Mesh(lowerArmGeometry, bodyMaterial);
      rightLowerArm.position.set(1.2, 1.0, 0);
      rightLowerArm.rotation.z = -0.2;
      group.add(rightLowerArm);
      
      // Right claws
      for (let i = -1; i <= 1; i++) {
        const claw = new THREE.Mesh(clawGeometry, antlerMaterial);
        claw.position.set(1.4, 0.4, i * 0.12);
        claw.rotation.z = -0.3;
        group.add(claw);
      }
      
      // Neck
      const neckGeometry = new THREE.BoxGeometry(0.5, 0.6, 0.5);
      const neck = new THREE.Mesh(neckGeometry, bodyMaterial);
      neck.position.set(0, 2.4, 0);
      group.add(neck);
      
      // Head (deer skull mask)
      const headGeometry = new THREE.BoxGeometry(0.9, 1.0, 0.8);
      const head = new THREE.Mesh(headGeometry, skinMaterial);
      head.position.set(0, 3.1, 0);
      head.castShadow = true;
      group.add(head);
      
      // Snout
      const snoutGeometry = new THREE.BoxGeometry(0.5, 0.4, 0.6);
      const snout = new THREE.Mesh(snoutGeometry, skinMaterial);
      snout.position.set(0, 2.85, 0.5);
      group.add(snout);
      
      // Nose
      const noseGeometry = new THREE.BoxGeometry(0.25, 0.2, 0.15);
      const nose = new THREE.Mesh(noseGeometry, antlerMaterial);
      nose.position.set(0, 2.75, 0.85);
      group.add(nose);
      
      // Eyes (large, creepy white rings with black centers)
      const eyeRingGeometry = new THREE.BoxGeometry(0.35, 0.35, 0.1);
      const eyeCenterGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.12);
      
      // Left eye
      const leftEyeRing = new THREE.Mesh(eyeRingGeometry, eyeWhiteMaterial);
      leftEyeRing.position.set(-0.25, 3.2, 0.4);
      group.add(leftEyeRing);
      
      const leftEyeCenter = new THREE.Mesh(eyeCenterGeometry, eyeMaterial);
      leftEyeCenter.position.set(-0.25, 3.2, 0.46);
      group.add(leftEyeCenter);
      
      // Right eye
      const rightEyeRing = new THREE.Mesh(eyeRingGeometry, eyeWhiteMaterial);
      rightEyeRing.position.set(0.25, 3.2, 0.4);
      group.add(rightEyeRing);
      
      const rightEyeCenter = new THREE.Mesh(eyeCenterGeometry, eyeMaterial);
      rightEyeCenter.position.set(0.25, 3.2, 0.46);
      group.add(rightEyeCenter);
      
      // Ears (pink inside)
      const earGeometry = new THREE.BoxGeometry(0.15, 0.4, 0.3);
      
      const leftEar = new THREE.Mesh(earGeometry, bodyMaterial);
      leftEar.position.set(-0.5, 3.5, 0);
      leftEar.rotation.z = 0.3;
      group.add(leftEar);
      
      const leftEarInner = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.3, 0.2), earMaterial);
      leftEarInner.position.set(-0.52, 3.5, 0.08);
      leftEarInner.rotation.z = 0.3;
      group.add(leftEarInner);
      
      const rightEar = new THREE.Mesh(earGeometry, bodyMaterial);
      rightEar.position.set(0.5, 3.5, 0);
      rightEar.rotation.z = -0.3;
      group.add(rightEar);
      
      const rightEarInner = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.3, 0.2), earMaterial);
      rightEarInner.position.set(0.52, 3.5, 0.08);
      rightEarInner.rotation.z = -0.3;
      group.add(rightEarInner);
      
      // Antlers (large, branching, black)
      const antlerBaseGeometry = new THREE.BoxGeometry(0.12, 1.2, 0.12);
      const antlerBranchGeometry = new THREE.BoxGeometry(0.1, 0.6, 0.1);
      const antlerTipGeometry = new THREE.BoxGeometry(0.08, 0.4, 0.08);
      
      // Left antler
      const leftAntlerBase = new THREE.Mesh(antlerBaseGeometry, antlerMaterial);
      leftAntlerBase.position.set(-0.35, 4.2, 0);
      leftAntlerBase.rotation.z = 0.2;
      group.add(leftAntlerBase);
      
      const leftBranch1 = new THREE.Mesh(antlerBranchGeometry, antlerMaterial);
      leftBranch1.position.set(-0.55, 4.5, 0.15);
      leftBranch1.rotation.z = 0.5;
      leftBranch1.rotation.x = -0.3;
      group.add(leftBranch1);
      
      const leftBranch2 = new THREE.Mesh(antlerBranchGeometry, antlerMaterial);
      leftBranch2.position.set(-0.45, 4.8, -0.15);
      leftBranch2.rotation.z = 0.3;
      leftBranch2.rotation.x = 0.3;
      group.add(leftBranch2);
      
      const leftTip1 = new THREE.Mesh(antlerTipGeometry, antlerMaterial);
      leftTip1.position.set(-0.7, 4.9, 0.25);
      leftTip1.rotation.z = 0.6;
      group.add(leftTip1);
      
      const leftTip2 = new THREE.Mesh(antlerTipGeometry, antlerMaterial);
      leftTip2.position.set(-0.5, 5.1, -0.2);
      leftTip2.rotation.z = 0.2;
      group.add(leftTip2);
      
      // Right antler (mirrored)
      const rightAntlerBase = new THREE.Mesh(antlerBaseGeometry, antlerMaterial);
      rightAntlerBase.position.set(0.35, 4.2, 0);
      rightAntlerBase.rotation.z = -0.2;
      group.add(rightAntlerBase);
      
      const rightBranch1 = new THREE.Mesh(antlerBranchGeometry, antlerMaterial);
      rightBranch1.position.set(0.55, 4.5, 0.15);
      rightBranch1.rotation.z = -0.5;
      rightBranch1.rotation.x = -0.3;
      group.add(rightBranch1);
      
      const rightBranch2 = new THREE.Mesh(antlerBranchGeometry, antlerMaterial);
      rightBranch2.position.set(0.45, 4.8, -0.15);
      rightBranch2.rotation.z = -0.3;
      rightBranch2.rotation.x = 0.3;
      group.add(rightBranch2);
      
      const rightTip1 = new THREE.Mesh(antlerTipGeometry, antlerMaterial);
      rightTip1.position.set(0.7, 4.9, 0.25);
      rightTip1.rotation.z = -0.6;
      group.add(rightTip1);
      
      const rightTip2 = new THREE.Mesh(antlerTipGeometry, antlerMaterial);
      rightTip2.position.set(0.5, 5.1, -0.2);
      rightTip2.rotation.z = -0.2;
      group.add(rightTip2);
      
      // Open mouth (creepy gaping)
      const mouthGeometry = new THREE.BoxGeometry(0.35, 0.15, 0.3);
      const mouthMaterial = new THREE.MeshLambertMaterial({ color: 0x2a1a1a });
      const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
      mouth.position.set(0, 2.65, 0.55);
      group.add(mouth);
      
      group.position.set(x, 0, z);
      group.userData = { type: 'deerMonster' };
      return group;
    }
    
    function createCultist(x, z) {
      const group = new THREE.Group();
      
      // Body (red/maroon coat)
      const bodyGeometry = new THREE.BoxGeometry(1.2, 1.5, 0.8);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8B2020 }); // Dark red
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 1.0;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Legs (brown pants)
      const legGeometry = new THREE.BoxGeometry(0.4, 0.8, 0.4);
      const legMaterial = new THREE.MeshLambertMaterial({ color: 0x6B5D3F }); // Brown
      
      const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
      leftLeg.position.set(-0.3, 0.4, 0);
      leftLeg.castShadow = true;
      leftLeg.receiveShadow = true;
      group.add(leftLeg);
      
      const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
      rightLeg.position.set(0.3, 0.4, 0);
      rightLeg.castShadow = true;
      rightLeg.receiveShadow = true;
      group.add(rightLeg);
      
      // Head (yellow/green mask)
      const headGeometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
      const headMaterial = new THREE.MeshLambertMaterial({ color: 0xB8B84D }); // Yellow-green
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 2.1;
      head.castShadow = true;
      head.receiveShadow = true;
      group.add(head);
      
      // Eyes (dark)
      const eyeGeometry = new THREE.BoxGeometry(0.12, 0.12, 0.12);
      const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x2C2C1C });
      
      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.15, 2.15, 0.36);
      group.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(0.15, 2.15, 0.36);
      group.add(rightEye);
      
      // Nose/beak (protruding)
      const noseGeometry = new THREE.BoxGeometry(0.2, 0.3, 0.3);
      const nose = new THREE.Mesh(noseGeometry, headMaterial);
      nose.position.set(0, 2.0, 0.5);
      nose.castShadow = true;
      nose.receiveShadow = true;
      group.add(nose);
      
      // Antlers (black, branching)
      const antlerMaterial = new THREE.MeshLambertMaterial({ color: 0x1C1C1C }); // Very dark
      
      // Left antler main branch
      const leftAntlerMain = new THREE.BoxGeometry(0.15, 1.2, 0.15);
      const leftMain = new THREE.Mesh(leftAntlerMain, antlerMaterial);
      leftMain.position.set(-0.3, 2.9, 0);
      leftMain.rotation.z = -0.3;
      leftMain.castShadow = true;
      group.add(leftMain);
      
      // Left antler branches
      const leftBranch1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.6, 0.1), antlerMaterial);
      leftBranch1.position.set(-0.5, 3.2, 0.15);
      leftBranch1.rotation.z = -0.6;
      leftBranch1.rotation.x = 0.4;
      leftBranch1.castShadow = true;
      group.add(leftBranch1);
      
      const leftBranch2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.1), antlerMaterial);
      leftBranch2.position.set(-0.55, 3.0, -0.15);
      leftBranch2.rotation.z = -0.5;
      leftBranch2.rotation.x = -0.4;
      leftBranch2.castShadow = true;
      group.add(leftBranch2);
      
      // Right antler main branch
      const rightAntlerMain = new THREE.BoxGeometry(0.15, 1.2, 0.15);
      const rightMain = new THREE.Mesh(rightAntlerMain, antlerMaterial);
      rightMain.position.set(0.3, 2.9, 0);
      rightMain.rotation.z = 0.3;
      rightMain.castShadow = true;
      group.add(rightMain);
      
      // Right antler branches
      const rightBranch1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.6, 0.1), antlerMaterial);
      rightBranch1.position.set(0.5, 3.2, 0.15);
      rightBranch1.rotation.z = 0.6;
      rightBranch1.rotation.x = 0.4;
      rightBranch1.castShadow = true;
      group.add(rightBranch1);
      
      const rightBranch2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.1), antlerMaterial);
      rightBranch2.position.set(0.55, 3.0, -0.15);
      rightBranch2.rotation.z = 0.5;
      rightBranch2.rotation.x = -0.4;
      rightBranch2.castShadow = true;
      group.add(rightBranch2);
      
      // Weapon (axe-like) held in front
      const handleGeometry = new THREE.BoxGeometry(0.1, 1.2, 0.1);
      const handleMaterial = new THREE.MeshLambertMaterial({ color: 0x4A3C28 }); // Dark brown
      const handle = new THREE.Mesh(handleGeometry, handleMaterial);
      handle.position.set(0.5, 1.0, 0.6);
      handle.rotation.z = 0.3;
      handle.castShadow = true;
      group.add(handle);
      
      const bladeGeometry = new THREE.BoxGeometry(0.5, 0.4, 0.1);
      const bladeMaterial = new THREE.MeshLambertMaterial({ color: 0x505050 }); // Gray metal
      const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
      blade.position.set(0.7, 1.6, 0.6);
      blade.rotation.z = 0.3;
      blade.castShadow = true;
      group.add(blade);
      
      group.position.set(x, 0, z);
      group.userData = { type: 'cultist', action: 'fightCultist', worldX: x, worldZ: z, targetX: x, targetZ: z };
      return group;
    }
    
    function createPlayer(x, z) {
      const group = new THREE.Group();
      
      // Body (simple rectangular body)
      const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.6);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 }); // Royal blue
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.6;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Arms (two small rectangles on sides)
      const armGeometry = new THREE.BoxGeometry(0.3, 0.8, 0.3);
      const armMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 }); // Yellow like face
      
      const leftArm = new THREE.Mesh(armGeometry, armMaterial);
      leftArm.position.set(-0.55, 0.8, 0);
      leftArm.castShadow = true;
      leftArm.receiveShadow = true;
      group.add(leftArm);
      
      const rightArm = new THREE.Mesh(armGeometry, armMaterial);
      rightArm.position.set(0.55, 0.8, 0);
      rightArm.castShadow = true;
      rightArm.receiveShadow = true;
      group.add(rightArm);
      
      // Legs (two small rectangles at bottom)
      const legGeometry = new THREE.BoxGeometry(0.3, 0.6, 0.3);
      const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F4F }); // Dark slate gray
      
      const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
      leftLeg.position.set(-0.2, 0.3, 0);
      leftLeg.castShadow = true;
      leftLeg.receiveShadow = true;
      group.add(leftLeg);
      
      const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
      rightLeg.position.set(0.2, 0.3, 0);
      rightLeg.castShadow = true;
      rightLeg.receiveShadow = true;
      group.add(rightLeg);
      
      // Head/Face (yellow square on top)
      const faceGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
      const faceMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
      const face = new THREE.Mesh(faceGeometry, faceMaterial);
      face.position.y = 1.6;
      face.castShadow = true;
      face.receiveShadow = true;
      group.add(face);
      
      // Eyes (two small black cubes)
      const eyeGeometry = new THREE.BoxGeometry(0.12, 0.12, 0.12);
      const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
      
      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.15, 1.7, 0.41);
      group.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(0.15, 1.7, 0.41);
      group.add(rightEye);
      
      // Mouth (small black cube)
      const mouthGeometry = new THREE.BoxGeometry(0.3, 0.08, 0.08);
      const mouth = new THREE.Mesh(mouthGeometry, eyeMaterial);
      mouth.position.set(0, 1.45, 0.41);
      group.add(mouth);
      
      group.position.set(x, 0, z);
      group.userData = { type: 'player' };
      return group;
    }
    
    function createCampfire(x, z) {
      const group = new THREE.Group();
      
      // Rocks arranged in a circle around the fire
      const rockGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.4);
      const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 }); // Gray rocks
      
      const rockPositions = [
        [1.2, 0, 0],
        [-1.2, 0, 0],
        [0, 0, 1.2],
        [0, 0, -1.2],
        [0.85, 0, 0.85],
        [-0.85, 0, 0.85],
        [0.85, 0, -0.85],
        [-0.85, 0, -0.85]
      ];
      
      rockPositions.forEach(pos => {
        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
        rock.position.set(pos[0], 0.15, pos[2]);
        rock.castShadow = true;
        rock.receiveShadow = true;
        group.add(rock);
      });
      
      // Logs arranged in a cross in the center
      const logGeometry = new THREE.BoxGeometry(1.5, 0.25, 0.25);
      const logMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown logs
      
      const log1 = new THREE.Mesh(logGeometry, logMaterial);
      log1.position.y = 0.125;
      log1.castShadow = true;
      log1.receiveShadow = true;
      group.add(log1);
      
      const log2 = new THREE.Mesh(logGeometry, logMaterial);
      log2.position.y = 0.125;
      log2.rotation.y = Math.PI / 2;
      log2.castShadow = true;
      log2.receiveShadow = true;
      group.add(log2);
      
      // Three logs arranged in a triangle around the campfire (like seating)
      const sittingLogGeometry = new THREE.BoxGeometry(2.5, 0.3, 0.3);
      
      // Log 1 - bottom (horizontal)
      const sittingLog1 = new THREE.Mesh(sittingLogGeometry, logMaterial);
      sittingLog1.position.set(0, 0.15, 4.5);
      sittingLog1.castShadow = true;
      sittingLog1.receiveShadow = true;
      group.add(sittingLog1);
      
      // Log 2 - top left (angled)
      const sittingLog2 = new THREE.Mesh(sittingLogGeometry, logMaterial);
      sittingLog2.position.set(-3.9, 0.15, -2.25);
      sittingLog2.rotation.y = Math.PI / 3; // 60 degrees
      sittingLog2.castShadow = true;
      sittingLog2.receiveShadow = true;
      group.add(sittingLog2);
      
      // Log 3 - top right (angled)
      const sittingLog3 = new THREE.Mesh(sittingLogGeometry, logMaterial);
      sittingLog3.position.set(3.9, 0.15, -2.25);
      sittingLog3.rotation.y = -Math.PI / 3; // -60 degrees
      sittingLog3.castShadow = true;
      sittingLog3.receiveShadow = true;
      group.add(sittingLog3);
      
      // Fire flames group (will be hidden when fire is out)
      const flamesGroup = new THREE.Group();
      flamesGroup.name = 'flames';
      
      // Fire (orange/yellow cubes with emissive glow)
      const fireGeometry = new THREE.BoxGeometry(0.4, 1.2, 0.4);
      const fireMaterial = new THREE.MeshLambertMaterial({ 
        color: 0xFFAA00, 
        emissive: 0xFF6600, 
        emissiveIntensity: 0.8 
      });
      
      const fire1 = new THREE.Mesh(fireGeometry, fireMaterial);
      fire1.position.set(0, 0.8, 0);
      flamesGroup.add(fire1);
      
      const fire2 = new THREE.Mesh(fireGeometry, fireMaterial);
      fire2.position.set(0.25, 1.1, 0.15);
      fire2.scale.set(0.6, 0.8, 0.6);
      flamesGroup.add(fire2);
      
      const fire3 = new THREE.Mesh(fireGeometry, fireMaterial);
      fire3.position.set(-0.25, 1.1, -0.15);
      fire3.scale.set(0.6, 0.8, 0.6);
      flamesGroup.add(fire3);
      
      // Point light for fire glow (inside flames group so it hides with flames)
      const fireLight = new THREE.PointLight(0xFF6600, 1.5, 25);
      fireLight.position.set(0, 1, 0);
      flamesGroup.add(fireLight);
      
      group.add(flamesGroup);
      
      // Create dotted circle around fire using small cubes (will be updated as fire level grows)
      const dotGeometry = new THREE.BoxGeometry(0.15, 0.05, 0.15);
      const dotMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF }); // White dots
      const numDots = 48; // Number of dots in the circle
      
      // Create dots and store references for later resizing
      for (let i = 0; i < numDots; i++) {
        const angle = (i / numDots) * Math.PI * 2;
        const dotX = Math.cos(angle) * safeZoneRadius;
        const dotZ = Math.sin(angle) * safeZoneRadius;
        
        const dot = new THREE.Mesh(dotGeometry, dotMaterial);
        dot.position.set(dotX, 0.025, dotZ);
        dot.userData.dotIndex = i; // Store index for recalculating position
        dot.userData.numDots = numDots;
        group.add(dot);
        safeZoneDots.push(dot);
      }
      
      group.position.set(x, 0, z);
      group.userData = { type: 'campfire', flamesGroup: flamesGroup };
      return group;
    }
    
    function createCraftingBench(x, z) {
      const group = new THREE.Group();
      
      // Wooden table base (purple-ish wood)
      const tableTopGeometry = new THREE.BoxGeometry(2, 0.3, 1.5);
      const tableTopMaterial = new THREE.MeshLambertMaterial({ color: 0x8B7355 }); // Brown wood
      const tableTop = new THREE.Mesh(tableTopGeometry, tableTopMaterial);
      tableTop.position.y = 1.2;
      tableTop.castShadow = true;
      tableTop.receiveShadow = true;
      group.add(tableTop);
      
      // Legs (4)
      const legGeometry = new THREE.BoxGeometry(0.2, 1.2, 0.2);
      const legMaterial = new THREE.MeshLambertMaterial({ color: 0x6B5D3F });
      const legPositions = [
        [0.8, 0.6, 0.6],
        [0.8, 0.6, -0.6],
        [-0.8, 0.6, 0.6],
        [-0.8, 0.6, -0.6]
      ];
      
      legPositions.forEach(pos => {
        const leg = new THREE.Mesh(legGeometry, legMaterial);
        leg.position.set(pos[0], pos[1], pos[2]);
        leg.castShadow = true;
        leg.receiveShadow = true;
        group.add(leg);
      });
      
      // Tools on table - hammer
      const hammerHandleGeometry = new THREE.BoxGeometry(0.1, 0.6, 0.1);
      const hammerHandleMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const hammerHandle = new THREE.Mesh(hammerHandleGeometry, hammerHandleMaterial);
      hammerHandle.position.set(-0.4, 1.5, 0.2);
      hammerHandle.rotation.z = Math.PI / 4;
      hammerHandle.castShadow = true;
      group.add(hammerHandle);
      
      const hammerHeadGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.2);
      const hammerHeadMaterial = new THREE.MeshLambertMaterial({ color: 0x505050 });
      const hammerHead = new THREE.Mesh(hammerHeadGeometry, hammerHeadMaterial);
      hammerHead.position.set(-0.6, 1.7, 0.2);
      hammerHead.rotation.z = Math.PI / 4;
      hammerHead.castShadow = true;
      group.add(hammerHead);
      
      // Saw on table
      const sawHandleGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.3);
      const sawHandle = new THREE.Mesh(sawHandleGeometry, hammerHandleMaterial);
      sawHandle.position.set(0.5, 1.45, -0.3);
      sawHandle.castShadow = true;
      group.add(sawHandle);
      
      const sawBladeGeometry = new THREE.BoxGeometry(0.6, 0.05, 0.3);
      const sawBlade = new THREE.Mesh(sawBladeGeometry, hammerHeadMaterial);
      sawBlade.position.set(0.1, 1.45, -0.3);
      sawBlade.castShadow = true;
      group.add(sawBlade);
      
      // Purple accent panel (to match layout color)
      const accentGeometry = new THREE.BoxGeometry(1.8, 0.1, 0.1);
      const accentMaterial = new THREE.MeshLambertMaterial({ color: 0x9B59B6 }); // Purple
      const accent = new THREE.Mesh(accentGeometry, accentMaterial);
      accent.position.set(0, 1.0, 0.75);
      accent.castShadow = true;
      group.add(accent);
      
      group.position.set(x, 0, z);
      group.userData = { type: 'craftingBench' };
      return group;
    }
    
    function createBed(x, z, colorScheme) {
      const group = new THREE.Group();
      
      // Color schemes: 'cyan', 'brown', 'green'
      let frameColor, mattressColor;
      if (colorScheme === 'cyan') {
        frameColor = 0x5DADE2; // Cyan
        mattressColor = 0x85C1E9; // Light blue
      } else if (colorScheme === 'brown') {
        frameColor = 0x8B4513; // Brown
        mattressColor = 0xD2691E; // Chocolate
      } else if (colorScheme === 'green') {
        frameColor = 0x27AE60; // Green
        mattressColor = 0x52BE80; // Light green
      }
      
      // Bed frame
      const frameGeometry = new THREE.BoxGeometry(2, 0.2, 3);
      const frameMaterial = new THREE.MeshLambertMaterial({ color: frameColor });
      const frame = new THREE.Mesh(frameGeometry, frameMaterial);
      frame.position.y = 0.5;
      frame.castShadow = true;
      frame.receiveShadow = true;
      group.add(frame);
      
      // Mattress
      const mattressGeometry = new THREE.BoxGeometry(1.8, 0.3, 2.8);
      const mattressMaterial = new THREE.MeshLambertMaterial({ color: mattressColor });
      const mattress = new THREE.Mesh(mattressGeometry, mattressMaterial);
      mattress.position.y = 0.75;
      mattress.castShadow = true;
      mattress.receiveShadow = true;
      group.add(mattress);
      
      // Pillow
      const pillowGeometry = new THREE.BoxGeometry(0.8, 0.2, 0.6);
      const pillowMaterial = new THREE.MeshLambertMaterial({ color: 0xECF0F1 }); // White
      const pillow = new THREE.Mesh(pillowGeometry, pillowMaterial);
      pillow.position.set(0, 1.0, -1.0);
      pillow.castShadow = true;
      group.add(pillow);
      
      // Legs (4)
      const legGeometry = new THREE.BoxGeometry(0.2, 0.5, 0.2);
      const legMaterial = new THREE.MeshLambertMaterial({ color: 0x34495E });
      const legPositions = [
        [0.9, 0.25, 1.4],
        [0.9, 0.25, -1.4],
        [-0.9, 0.25, 1.4],
        [-0.9, 0.25, -1.4]
      ];
      
      legPositions.forEach(pos => {
        const leg = new THREE.Mesh(legGeometry, legMaterial);
        leg.position.set(pos[0], pos[1], pos[2]);
        leg.castShadow = true;
        group.add(leg);
      });
      
      group.position.set(x, 0, z);
      group.userData = { type: 'bed' };
      return group;
    }
    
    function createFarmPlot(x, z) {
      const group = new THREE.Group();
      
      // Soil plot (brown/dark brown)
      const soilGeometry = new THREE.BoxGeometry(2, 0.2, 3);
      const soilMaterial = new THREE.MeshLambertMaterial({ color: 0x6B4423 }); // Dark brown soil
      const soil = new THREE.Mesh(soilGeometry, soilMaterial);
      soil.position.y = 0.1;
      soil.castShadow = true;
      soil.receiveShadow = true;
      group.add(soil);
      
      // Carrots group (separate so we can show/hide)
      const carrotsGroup = new THREE.Group();
      carrotsGroup.name = 'carrots';
      
      // Carrots (6 in 2 columns, 3 rows)
      const carrotPositions = [
        [-0.4, 0.2, -0.8],
        [0.4, 0.2, -0.8],
        [-0.4, 0.2, 0],
        [0.4, 0.2, 0],
        [-0.4, 0.2, 0.8],
        [0.4, 0.2, 0.8]
      ];
      
      carrotPositions.forEach(pos => {
        // Orange carrot body
        const carrotGeometry = new THREE.BoxGeometry(0.15, 0.3, 0.15);
        const carrotMaterial = new THREE.MeshLambertMaterial({ color: 0xFF8C00 }); // Orange
        const carrot = new THREE.Mesh(carrotGeometry, carrotMaterial);
        carrot.position.set(pos[0], pos[1], pos[2]);
        carrot.castShadow = true;
        carrotsGroup.add(carrot);
        
        // Green leafy top
        const leavesGeometry = new THREE.BoxGeometry(0.2, 0.15, 0.2);
        const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 }); // Green
        const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
        leaves.position.set(pos[0], pos[1] + 0.22, pos[2]);
        leaves.castShadow = true;
        carrotsGroup.add(leaves);
      });
      
      // Hide carrots initially (will show when ready to harvest)
      carrotsGroup.visible = false;
      group.add(carrotsGroup);
      
      group.position.set(x, 0, z);
      group.userData = { type: 'farmPlot', carrotsGroup: carrotsGroup };
      return group;
    }
    
    function createCrockPot(x, z) {
      const group = new THREE.Group();
      
      const potMaterial = new THREE.MeshLambertMaterial({ color: 0x9B8B7A }); // Warm gray-brown
      const darkPotMaterial = new THREE.MeshLambertMaterial({ color: 0x7A6B5A }); // Darker accent
      const legMaterial = new THREE.MeshLambertMaterial({ color: 0x4A4A4A }); // Dark gray metal
      
      // Tapered pot body - multiple layers getting narrower toward bottom
      const numSegments = 16;
      const layers = [
        { y: 1.6, radius: 1.0, height: 0.25 },   // Top rim
        { y: 1.35, radius: 0.95, height: 0.25 }, // Upper body
        { y: 1.1, radius: 0.85, height: 0.25 },  // Upper-mid body
        { y: 0.85, radius: 0.75, height: 0.25 }, // Mid body
        { y: 0.6, radius: 0.6, height: 0.25 },   // Lower-mid body
        { y: 0.4, radius: 0.45, height: 0.2 },   // Lower body (tapered)
      ];
      
      layers.forEach((layer, layerIndex) => {
        const material = layerIndex === 0 ? darkPotMaterial : potMaterial;
        for (let i = 0; i < numSegments; i++) {
          const angle = (i / numSegments) * Math.PI * 2;
          const segmentWidth = (layer.radius * 2 * Math.PI) / numSegments * 0.7;
          const segmentGeometry = new THREE.BoxGeometry(segmentWidth, layer.height, 0.2);
          const segment = new THREE.Mesh(segmentGeometry, material);
          segment.position.set(
            Math.cos(angle) * layer.radius,
            layer.y,
            Math.sin(angle) * layer.radius
          );
          segment.rotation.y = angle;
          segment.castShadow = true;
          segment.receiveShadow = true;
          group.add(segment);
        }
      });
      
      // Closed bottom of pot
      const bottomGeometry = new THREE.BoxGeometry(0.9, 0.15, 0.9);
      const bottom = new THREE.Mesh(bottomGeometry, potMaterial);
      bottom.position.y = 0.3;
      bottom.castShadow = true;
      bottom.receiveShadow = true;
      group.add(bottom);
      
      // Three curved legs
      const legAngles = [0, (2 * Math.PI) / 3, (4 * Math.PI) / 3];
      
      legAngles.forEach(angle => {
        // Leg - slightly curved outward
        const legGroup = new THREE.Group();
        
        // Upper leg part (angled outward)
        const upperLegGeometry = new THREE.BoxGeometry(0.12, 0.35, 0.12);
        const upperLeg = new THREE.Mesh(upperLegGeometry, legMaterial);
        upperLeg.position.set(0.08, 0.15, 0);
        upperLeg.rotation.z = -0.2;
        upperLeg.castShadow = true;
        legGroup.add(upperLeg);
        
        // Lower leg part (more vertical)
        const lowerLegGeometry = new THREE.BoxGeometry(0.1, 0.2, 0.1);
        const lowerLeg = new THREE.Mesh(lowerLegGeometry, legMaterial);
        lowerLeg.position.set(0.12, -0.05, 0);
        lowerLeg.castShadow = true;
        legGroup.add(lowerLeg);
        
        // Foot (small flat piece)
        const footGeometry = new THREE.BoxGeometry(0.15, 0.05, 0.15);
        const foot = new THREE.Mesh(footGeometry, legMaterial);
        foot.position.set(0.12, -0.15, 0);
        foot.castShadow = true;
        foot.receiveShadow = true;
        legGroup.add(foot);
        
        legGroup.position.set(
          Math.cos(angle) * 0.35,
          0.2,
          Math.sin(angle) * 0.35
        );
        legGroup.rotation.y = angle;
        group.add(legGroup);
      });
      
      // Handles (2) - loop style
      const handleMaterial = new THREE.MeshLambertMaterial({ color: 0x5A5A5A });
      
      [-1, 1].forEach(side => {
        // Handle ring
        const handleGeometry = new THREE.BoxGeometry(0.08, 0.3, 0.08);
        const handle = new THREE.Mesh(handleGeometry, handleMaterial);
        handle.position.set(side * 1.05, 1.2, 0);
        handle.castShadow = true;
        group.add(handle);
        
        // Handle attachment point
        const attachGeometry = new THREE.BoxGeometry(0.12, 0.12, 0.12);
        const attach = new THREE.Mesh(attachGeometry, darkPotMaterial);
        attach.position.set(side * 0.95, 1.2, 0);
        attach.castShadow = true;
        group.add(attach);
      });
      
      // Lid
      const lidMaterial = new THREE.MeshLambertMaterial({ color: 0x8A7A6A });
      
      // Lid base (slightly domed - multiple layers)
      for (let i = 0; i < numSegments; i++) {
        const angle = (i / numSegments) * Math.PI * 2;
        const lidGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.15);
        const lidPiece = new THREE.Mesh(lidGeometry, lidMaterial);
        lidPiece.position.set(Math.cos(angle) * 0.5, 1.75, Math.sin(angle) * 0.5);
        lidPiece.rotation.y = angle;
        lidPiece.castShadow = true;
        group.add(lidPiece);
      }
      
      // Lid center
      const lidCenterGeometry = new THREE.BoxGeometry(0.6, 0.12, 0.6);
      const lidCenter = new THREE.Mesh(lidCenterGeometry, lidMaterial);
      lidCenter.position.y = 1.78;
      lidCenter.castShadow = true;
      group.add(lidCenter);
      
      // Lid handle/knob
      const knobGeometry = new THREE.BoxGeometry(0.25, 0.15, 0.25);
      const knob = new THREE.Mesh(knobGeometry, darkPotMaterial);
      knob.position.y = 1.9;
      knob.castShadow = true;
      group.add(knob);
      
      group.position.set(x, 0, z);
      group.userData = { type: 'crockPot' };
      return group;
    }
    
    function createBiofuelProcessor(x, z) {
      const group = new THREE.Group();
      
      // Main body (green machine)
      const bodyGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.2);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x52BE80 }); // Green
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.75;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Funnel on top (input)
      const funnelGeometry = new THREE.BoxGeometry(0.8, 0.5, 0.8);
      const funnelMaterial = new THREE.MeshLambertMaterial({ color: 0x7D7D7D }); // Gray
      const funnel = new THREE.Mesh(funnelGeometry, funnelMaterial);
      funnel.position.y = 1.75;
      funnel.castShadow = true;
      group.add(funnel);
      
      // Spout (output)
      const spoutGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.6);
      const spout = new THREE.Mesh(spoutGeometry, funnelMaterial);
      spout.position.set(0.9, 0.5, 0);
      spout.castShadow = true;
      group.add(spout);
      
      // Control panel (darker green)
      const panelGeometry = new THREE.BoxGeometry(0.8, 0.6, 0.1);
      const panelMaterial = new THREE.MeshLambertMaterial({ color: 0x27AE60 }); // Darker green
      const panel = new THREE.Mesh(panelGeometry, panelMaterial);
      panel.position.set(0, 1.0, 0.65);
      panel.castShadow = true;
      group.add(panel);
      
      // Buttons on panel (red and yellow)
      const buttonGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.05);
      const redButtonMaterial = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
      const yellowButtonMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
      
      const redButton = new THREE.Mesh(buttonGeometry, redButtonMaterial);
      redButton.position.set(-0.2, 1.0, 0.71);
      group.add(redButton);
      
      const yellowButton = new THREE.Mesh(buttonGeometry, yellowButtonMaterial);
      yellowButton.position.set(0.2, 1.0, 0.71);
      group.add(yellowButton);
      
      // Base platform
      const baseGeometry = new THREE.BoxGeometry(1.8, 0.2, 1.5);
      const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x34495E });
      const base = new THREE.Mesh(baseGeometry, baseMaterial);
      base.position.y = 0.1;
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);
      
      group.position.set(x, 0, z);
      group.userData = { type: 'biofuelProcessor' };
      return group;
    }
    
    function createLogWallSegment(x, z, rotation) {
      const group = new THREE.Group();
      
      // Wall made of vertical logs (like fence posts) - much longer for octagon
      const logWidth = 0.4;
      const logHeight = 2.5;
      const logDepth = 0.4;
      const numLogs = 25; // More logs for longer wall
      const spacing = 0.5;
      const totalWidth = (numLogs - 1) * spacing;
      
      for (let i = 0; i < numLogs; i++) {
        const logGeometry = new THREE.BoxGeometry(logWidth, logHeight, logDepth);
        const logMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown wood
        const log = new THREE.Mesh(logGeometry, logMaterial);
        
        const xOffset = (i * spacing) - (totalWidth / 2);
        log.position.set(xOffset, logHeight / 2, 0);
        log.castShadow = true;
        log.receiveShadow = true;
        group.add(log);
        
        // Pointed top
        const tipGeometry = new THREE.BoxGeometry(logWidth, 0.4, logDepth);
        const tip = new THREE.Mesh(tipGeometry, logMaterial);
        tip.position.set(xOffset, logHeight + 0.2, 0);
        tip.rotation.z = Math.PI / 4;
        tip.castShadow = true;
        group.add(tip);
      }
      
      // Horizontal support beams (2)
      const beamGeometry = new THREE.BoxGeometry(totalWidth + 0.5, 0.2, 0.2);
      const beamMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 }); // Darker brown
      
      const beam1 = new THREE.Mesh(beamGeometry, beamMaterial);
      beam1.position.set(0, 0.8, 0.2);
      beam1.castShadow = true;
      group.add(beam1);
      
      const beam2 = new THREE.Mesh(beamGeometry, beamMaterial);
      beam2.position.set(0, 1.8, 0.2);
      beam2.castShadow = true;
      group.add(beam2);
      
      group.position.set(x, 0, z);
      group.rotation.y = rotation;
      group.userData = { type: 'logWall', length: totalWidth };
      return group;
    }
    
    function updateLogWallSegments() {
      logWallSegments.length = 0;
      logWallMeshes.forEach(wall => {
        const halfLength = ((wall.userData && wall.userData.length) || 12) / 2;
        const angle = wall.rotation.y;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const startX = wall.position.x - cos * halfLength;
        const startZ = wall.position.z - sin * halfLength;
        const endX = wall.position.x + cos * halfLength;
        const endZ = wall.position.z + sin * halfLength;
        logWallSegments.push({ startX, startZ, endX, endZ });
      });
    }
    
    function createBearTrap(x, z) {
      const group = new THREE.Group();
      
      // Base plate (circular-ish, made with box)
      const baseGeometry = new THREE.BoxGeometry(1.2, 0.1, 1.2);
      const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x505050 }); // Dark gray metal
      const base = new THREE.Mesh(baseGeometry, baseMaterial);
      base.position.y = 0.05;
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);
      
      // Jaw teeth (left side - 5 teeth)
      const toothGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.1);
      const toothMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 }); // Gray
      
      for (let i = 0; i < 5; i++) {
        const tooth = new THREE.Mesh(toothGeometry, toothMaterial);
        const zOffset = (i - 2) * 0.25;
        tooth.position.set(-0.4, 0.25, zOffset);
        tooth.rotation.z = -Math.PI / 6; // Angled inward
        tooth.castShadow = true;
        group.add(tooth);
      }
      
      // Jaw teeth (right side - 5 teeth)
      for (let i = 0; i < 5; i++) {
        const tooth = new THREE.Mesh(toothGeometry, toothMaterial);
        const zOffset = (i - 2) * 0.25;
        tooth.position.set(0.4, 0.25, zOffset);
        tooth.rotation.z = Math.PI / 6; // Angled inward
        tooth.castShadow = true;
        group.add(tooth);
      }
      
      // Jaw hinges
      const hingeGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
      const hingeMaterial = new THREE.MeshLambertMaterial({ color: 0x2C2C2C }); // Very dark
      
      const hinge1 = new THREE.Mesh(hingeGeometry, hingeMaterial);
      hinge1.position.set(-0.5, 0.1, 0.5);
      hinge1.castShadow = true;
      group.add(hinge1);
      
      const hinge2 = new THREE.Mesh(hingeGeometry, hingeMaterial);
      hinge2.position.set(0.5, 0.1, 0.5);
      hinge2.castShadow = true;
      group.add(hinge2);
      
      // Chain link
      const chainGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.1);
      const chain = new THREE.Mesh(chainGeometry, baseMaterial);
      chain.position.set(0, 0.2, -0.5);
      chain.castShadow = true;
      group.add(chain);
      
      group.position.set(x, 0, z);
      group.userData = { type: 'bearTrap' };
      return group;
    }
    
    function createSapling(x, z) {
      const group = new THREE.Group();
      
      // Small trunk
      const trunkGeometry = new THREE.BoxGeometry(0.3, 0.8, 0.3);
      const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.y = 0.4;
      trunk.castShadow = true;
      trunk.receiveShadow = true;
      group.add(trunk);
      
      // Small leaves (just a few blocks)
      const leavesGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
      const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      
      const leaves1 = new THREE.Mesh(leavesGeometry, leavesMaterial);
      leaves1.position.y = 0.9;
      leaves1.castShadow = true;
      group.add(leaves1);
      
      const leaves2 = new THREE.Mesh(leavesGeometry, leavesMaterial);
      leaves2.position.set(0.3, 1.1, 0);
      leaves2.scale.set(0.7, 0.7, 0.7);
      leaves2.castShadow = true;
      group.add(leaves2);
      
      const leaves3 = new THREE.Mesh(leavesGeometry, leavesMaterial);
      leaves3.position.set(-0.3, 1.1, 0);
      leaves3.scale.set(0.7, 0.7, 0.7);
      leaves3.castShadow = true;
      group.add(leaves3);
      
      group.position.set(x, 0, z);
      group.userData = { type: 'sapling' };
      return group;
    }
    
    // ============================================
    // GROUND PLANE
    // ============================================
    
    function createGround(radius) {
      const size = radius * 2; // Diameter
      const groundGeometry = new THREE.PlaneGeometry(size, size);
      
      // Create a simple grass texture using canvas
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      
      // Base grass color
      ctx.fillStyle = '#2d5016';
      ctx.fillRect(0, 0, 256, 256);
      
      // Add some variation
      for (let i = 0; i < 1000; i++) {
        const x = Math.random() * 256;
        const y = Math.random() * 256;
        const shade = Math.random() * 40 - 20;
        const r = Math.min(255, Math.max(0, 45 + shade));
        const g = Math.min(255, Math.max(0, 80 + shade));
        const b = Math.min(255, Math.max(0, 22 + shade));
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.fillRect(x, y, 2, 2);
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(size / 4, size / 4);
      
      const groundMaterial = new THREE.MeshLambertMaterial({ map: texture });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      ground.userData = { type: 'ground' };
      
      return ground;
    }
    
    // ============================================
    // GAME STATE
    // ============================================
    
    // UI Elements
    const mathBubble = document.getElementById('mathBubble');
    const mathBubbleLabel = document.getElementById('mathBubbleLabel');
    const mathQuestion = document.getElementById('mathQuestion');
    const mathAnswerInput = document.getElementById('mathAnswerInput');
    const mathSubmitButton = document.getElementById('mathSubmitButton');
    const mathBubbleFeedback = document.getElementById('mathBubbleFeedback');
    const mathTimerBar = document.getElementById('mathTimerBar');
    const mathTimerFill = document.getElementById('mathTimerFill');
    const mathQuestionCounter = document.getElementById('mathQuestionCounter');
    
    const woodCount = document.getElementById('woodCount');
    const meatCount = document.getElementById('meatCount');
    const coalCount = document.getElementById('coalCount');
    const scrapCount = document.getElementById('scrapCount');
    const carrotCount = document.getElementById('carrotCount');
    const stewCount = document.getElementById('stewCount');
    
    const dayCounter = document.getElementById('dayCounter');
    const rewardsDiamondCount = document.getElementById('rewardsDiamondCount');
    const cycleIcon = document.getElementById('cycleIcon');
    const cycleCountdown = document.getElementById('cycleCountdown');
    const healthBar = document.getElementById('healthBar');
    const hungerBar = document.getElementById('hungerBar');
    const hungerBarContainer = hungerBar.parentElement;
    const fireBar = document.getElementById('fireBar');
    const fireLevel = document.getElementById('fireLevel');
    
    const minimapCanvas = document.getElementById('minimapCanvas');
    const minimapCtx = minimapCanvas.getContext('2d');
    
    const woodItem = document.getElementById('woodItem');
    const meatItem = document.getElementById('meatItem');
    const fuelItem = document.getElementById('fuelItem');
    const carrotItem = document.getElementById('carrotItem');
    const stewItem = document.getElementById('stewItem');
    const axeItem = document.getElementById('axeItem');
    const spearItem = document.getElementById('spearItem');
    const metalItem = document.getElementById('metalItem');
    
    const pauseButton = document.getElementById('pauseButton');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const playButton = document.getElementById('playButton');
    const cameraToggleBtn = document.getElementById('cameraToggle');
    const fpCrosshair = document.getElementById('fpCrosshair');
    const fpHint = document.getElementById('fpHint');

    // Crafting menu elements
    const craftingMenu = document.getElementById('craftingMenu');
    const craftingItems = document.getElementById('craftingItems');
    const craftingCloseBtn = document.getElementById('craftingCloseBtn');
    const craftingWoodCount = document.getElementById('craftingWoodCount');
    const craftingMetalCount = document.getElementById('craftingMetalCount');
    const cycleSection = document.getElementById('cycleSection');
    const minimapSection = document.getElementById('minimapSection');
    
    // Game state
    let isDialogOpen = false;
    let isPaused = false;
    let currentInteractable = null;
    let currentAction = '';
    let currentQuestions = [];
    let currentQuestionIndex = 0;
    let questionsCorrectFirstTry = []; // Track which questions were answered correctly on first try
    let currentQuestionAttempts = 0; // Track attempts for current question
    let timerInterval = null;
    let timeRemaining = 0;
    let timerDuration = 7000; // Timer duration in ms (can be set from admin config)
    let currentQuestionTimedOut = false; // Track if current question timed out
    
    let playerHealth = 100;
    let playerHunger = 100;
    let fireStrength = 0;
    let currentFireLevel = 1;
    
    // New inventory items
    let carrots = 0;
    let stew = 0;
    let hasAxe = false;
    
    // Crafting state variables
    let craftingTier = 1; // 1, 2, or 3
    let hasCraftedMap = false;
    let hasCraftedSunDial = false;
    let hasCraftedCrockPot = false;
    let hasCraftedBiofuelProcessor = false;
    let bedsOwned = 0; // 0-3
    let farmPlotsOwned = 0; // 0-10
    let logWallsOwned = 0; // 0-8
    let bearTrapsOwned = 0; // 0-8
    let farmPlotDaysUntilHarvest = 2; // Countdown timer
    let isNearCraftingBench = false;
    let isCraftingMenuOpen = false;
    let pendingCraftItem = null; // Item waiting to be crafted after math problem
    let isNearCrockPot = false;
    let crockPotTooltipElement = null;
    let isNearBiofuelProcessor = false;
    let biofuelTooltipElement = null;
    
    let isStarving = false;
    let starvationTimer = null;
    let hungryWarningShown = false; // One-time "you're hungry" at 10%
    let starvingWarningShown = false; // One-time "you're starving" at 0%
    let fireWarningShown = false; // One-time "your fire is low" at 10%
    let isGameOver = false; // Track game over state
    
    let isNight = false;
    let currentDay = 1;
    let currentNight = 0; // Track which night we're on (increments when night starts)
    const DAY_DURATION = 120; // 2 minutes
    const NIGHT_DURATION = 90; // 1.5 minutes
    let cycleTimeRemaining = DAY_DURATION;
    let nightWarningShown = false;
    let cultistsSpawned = false;
    let cultists = []; // Array to track active cultists
    let cultistsDefeated = 0;
    let cultistRewardGiven = false;

    // Deer monster state
    let deerMonster = null; // The deer monster object
    let deerSpawned = false; // Has deer spawned this night?
    let lastDeerDamageTime = 0; // Prevent rapid damage
    const DEER_DAMAGE_COOLDOWN = 1000; // 1 second between damage
    
    // Wall building configuration
    // Segment positions: 0=3oclock, 1=4:30, 2=6oclock(entrance), 3=7:30, 4=9oclock, 5=10:30, 6=12oclock, 7=1:30
    // Build order: 12 o'clock first, then alternating left/right outward from there
    const wallBuildOrder = [6, 5, 7, 4, 0, 3, 1]; // Excludes entrance (segment 2)
    let wallsBuilt = 0; // How many walls are built (0-7). Starts at 0, player crafts them
    let activeWallSegments = new Set(); // Track which segment indices have walls
    
    // Diamond tracking
    let diamondsEarned = 0;
    let healthLostThisCycle = false; // Track if player lost health during current day/night cycle
    
    // ============================================
    // REWARDS SYSTEM
    // ============================================
    
    // Rewards state object
    const rewardsState = {
      // Rare items (true = found)
      rareItems: {
        lanternbark: false,
        silverWolf: false,
        whisperingFan: false,
        frostCanister: false
      },
      // Which entity is the rare one (set during generation)
      rareEntityMarkers: {
        lanternbarkTree: null,    // Will be set to an entity reference
        silverGleamWolf: null,
        whisperingFanBlade: null,
        frostLockedCanister: null
      },
      // Keys collected (count for each tier)
      keys: {
        wooden: 0,    // need 3
        golden: 0,    // need 4
        ruby: 0,      // need 5
        diamond: 0,   // need 6
        obsidian: 0   // need 7
      },
      keysRequired: {
        wooden: 3,
        golden: 4,
        ruby: 5,
        diamond: 6,
        obsidian: 7
      },
      // Chests spawned (true = spawned in world)
      chestSpawned: {
        wooden: false,
        golden: false,
        ruby: false,
        diamond: false,
        obsidian: false
      },
      // Chests opened (true = opened and reward claimed)
      chestsOpened: {
        wooden: false,
        golden: false,
        ruby: false,
        diamond: false,
        obsidian: false
      },
      // Current key tier being collected (wooden -> golden -> ruby -> diamond -> obsidian)
      currentKeyTier: null, // null until fire level 2
      // Active chest in the world (spawned after collecting all keys of a tier)
      activeChest: null,
      // Milestones reached (true = claimed)
      milestones: {
        day10: false,
        day20: false,
        day40: false,
        day60: false,
        day99: false
      },
      // Weapon upgrades
      weapons: {
        hasGoodAxe: false,
        hasSpear: false,
        hasChainsaw: false
      }
    };
    
    // Key entities in the world
    const keyEntities = [];
    const chestEntities = [];
    
    // Chest entity in the world
    let chestEntity = null;
    
    // Rare item spawn chances by fire level
    const rareSpawnChances = {
      lanternbark: [0.60, 0.90, 1.00, 1.00, 1.00],  // 60% L1, 90% L2, 100% L3+
      silverWolf:  [0.20, 0.50, 0.80, 1.00, 1.00],  // 20% L1, 50% L2, 80% L3, 100% L4+
      whisperingFan: [0.00, 0.25, 0.50, 1.00, 1.00], // 0% L1, 25% L2, 50% L3, 100% L4+
      frostCanister: [0.00, 0.25, 0.50, 1.00, 1.00]  // 0% L1, 25% L2, 50% L3, 100% L4+
    };
    
    // Check if a rare item should spawn for the current fire level
    function shouldSpawnRareItem(rareType) {
      const levelIndex = Math.min(currentFireLevel - 1, 4);
      const chance = rareSpawnChances[rareType][levelIndex];
      return Math.random() < chance;
    }
    
    // Mark rare entities among existing entities of a type
    function markRareEntities() {
      // Only mark if not already found AND not already marked
      if (!rewardsState.rareItems.lanternbark && !rewardsState.rareEntityMarkers.lanternbarkTree) {
        const trees = entities.filter(e => e.type === 'tree' && !e.isRare);
        if (trees.length > 0 && shouldSpawnRareItem('lanternbark')) {
          const randomTree = trees[Math.floor(Math.random() * trees.length)];
          randomTree.isRare = true;
          randomTree.rareType = 'lanternbark';
          rewardsState.rareEntityMarkers.lanternbarkTree = randomTree;
        }
      }
      
      if (!rewardsState.rareItems.silverWolf && !rewardsState.rareEntityMarkers.silverGleamWolf) {
        const wolves = entities.filter(e => e.type === 'wolf' && !e.isRare);
        if (wolves.length > 0 && shouldSpawnRareItem('silverWolf')) {
          const randomWolf = wolves[Math.floor(Math.random() * wolves.length)];
          randomWolf.isRare = true;
          randomWolf.rareType = 'silverWolf';
          rewardsState.rareEntityMarkers.silverGleamWolf = randomWolf;
        }
      }
      
      if (!rewardsState.rareItems.whisperingFan && !rewardsState.rareEntityMarkers.whisperingFanBlade) {
        const fans = entities.filter(e => e.type === 'fan' && !e.isRare);
        if (fans.length > 0 && shouldSpawnRareItem('whisperingFan')) {
          const randomFan = fans[Math.floor(Math.random() * fans.length)];
          randomFan.isRare = true;
          randomFan.rareType = 'whisperingFan';
          rewardsState.rareEntityMarkers.whisperingFanBlade = randomFan;
        }
      }
      
      if (!rewardsState.rareItems.frostCanister && !rewardsState.rareEntityMarkers.frostLockedCanister) {
        const canisters = entities.filter(e => e.type === 'fuel' && !e.isRare);
        if (canisters.length > 0 && shouldSpawnRareItem('frostCanister')) {
          const randomCanister = canisters[Math.floor(Math.random() * canisters.length)];
          randomCanister.isRare = true;
          randomCanister.rareType = 'frostCanister';
          rewardsState.rareEntityMarkers.frostLockedCanister = randomCanister;
        }
      }
    }
    
    // ============================================
    // PERSISTENCE LAYER
    // ============================================
    
    const SAVE_KEY = '99nights_save_v1';
    
    // Default save structure
    function createDefaultSave() {
      return {
        version: 1,
        
        // Player progression
        totalDiamondsEarned: 0,
        diamondsSpent: 0,
        playerLevel: 1,
        playerXP: 0,
        
        // Mastery tracking (per problem type ID)
        // e.g., "add_level1": { totalAttempts: 50, totalCorrect: 45, last10: [1,1,1,0,1,1,1,1,1,1], masteryAchieved: false }
        mastery: {},
        
        // Purchased classes/upgrades
        // e.g., "thick_skin": { purchased: true, purchaseDate: "2024-01-15" }
        classes: {},
        
        // Pet data
        pet: null, // or { type: 'cat', name: 'Whiskers', level: 1, happiness: 100 }
        
        // Admin configuration for math mappings
        adminConfig: {
          mathMappings: {
            fightWolf: { problemType: 'subtract_level1', questionCount: 3, timerSeconds: 7 },
            fightCultist: { problemType: 'subtract_level2', questionCount: 3, timerSeconds: 7 },
            chop: { problemType: 'add_level3', questionCount: 2, timerSeconds: 0 },
            collectFuel: { problemType: 'add_level1', questionCount: 1, timerSeconds: 0 },
            salvageFan: { problemType: 'add_level2', questionCount: 1, timerSeconds: 0 },
            salvageBolt: { problemType: 'add_level2', questionCount: 1, timerSeconds: 0 },
            salvageRadio: { problemType: 'add_level2', questionCount: 1, timerSeconds: 0 },
            collectKey: { problemType: 'add_level5', questionCount: 3, timerSeconds: 0 },
            crafting: { problemType: 'subtract_level1', questionCount: 1, timerSeconds: 0 },
            harvestFarm: { problemType: 'add_level6', questionCount: 1, timerSeconds: 0 },
            makeStew: { problemType: 'subtract_level3', questionCount: 1, timerSeconds: 0 },
          }
        },
        
        // Daily quests
        dailyQuests: [],
        lastQuestRefresh: null,
        
        // Achievements
        achievements: [],
        
        // Lifetime stats
        stats: {
          totalNightsSurvived: 0,
          totalWolvesDefeated: 0,
          totalTreesChopped: 0,
          totalCultistsDefeated: 0,
          bestNightReached: 0,
          totalQuestionsAnswered: 0,
          totalQuestionsCorrect: 0,
          currentStreak: 0,
          bestStreak: 0,
          totalPlayTime: 0,
          gamesPlayed: 0,
        },
        
        // Daily login tracking
        lastLoginDate: null,
        consecutiveLoginDays: 0,
        
        // Last session state
        lastGameMode: 'addition',
        
        // Timestamp for save
        lastSaveTime: null
      };
    }
    
    // Current game save (loaded on init)
    let gameSave = createDefaultSave();
    
    // Save game to localStorage
    function saveGame() {
      try {
        // Update save with current game state
        gameSave.totalDiamondsEarned = calculateTotalDiamonds();
        gameSave.lastGameMode = gameMode;
        gameSave.lastSaveTime = new Date().toISOString();
        
        // Update lifetime stats from current session
        gameSave.stats.bestNightReached = Math.max(gameSave.stats.bestNightReached, currentNight);
        
        // Serialize and save
        const saveData = JSON.stringify(gameSave);
        localStorage.setItem(SAVE_KEY, saveData);
        
        console.log('Game saved successfully:', gameSave);
        return true;
      } catch (error) {
        console.error('Failed to save game:', error);
        return false;
      }
    }
    
    // Load game from localStorage
    function loadGame() {
      try {
        const saveData = localStorage.getItem(SAVE_KEY);
        
        if (saveData) {
          const loaded = JSON.parse(saveData);
          
          // Merge with defaults to handle new fields in updates
          gameSave = { ...createDefaultSave(), ...loaded };
          
          // Deep merge nested objects
          gameSave.stats = { ...createDefaultSave().stats, ...(loaded.stats || {}) };
          gameSave.adminConfig = { 
            ...createDefaultSave().adminConfig, 
            ...(loaded.adminConfig || {}),
            mathMappings: {
              ...createDefaultSave().adminConfig.mathMappings,
              ...(loaded.adminConfig?.mathMappings || {})
            }
          };
          
          console.log('Game loaded successfully:', gameSave);
          return gameSave;
        } else {
          console.log('No save found, using defaults');
          gameSave = createDefaultSave();
          return gameSave;
        }
      } catch (error) {
        console.error('Failed to load game:', error);
        gameSave = createDefaultSave();
        return gameSave;
      }
    }
    
    // Reset game progress (with confirmation)
    function resetGame(skipConfirm = false) {
      if (!skipConfirm && !confirm('Are you sure you want to reset ALL progress? This cannot be undone!')) {
        return false;
      }
      
      try {
        localStorage.removeItem(SAVE_KEY);
        gameSave = createDefaultSave();
        console.log('Game reset successfully');
        return true;
      } catch (error) {
        console.error('Failed to reset game:', error);
        return false;
      }
    }
    
    // Export save as JSON file download
    function exportSave() {
      try {
        // Make sure save is current
        saveGame();
        
        const saveData = JSON.stringify(gameSave, null, 2);
        const blob = new Blob([saveData], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `99nights_save_${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        console.log('Save exported successfully');
        return true;
      } catch (error) {
        console.error('Failed to export save:', error);
        return false;
      }
    }
    
    // Import save from JSON file
    function importSave(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = (e) => {
          try {
            const imported = JSON.parse(e.target.result);
            
            // Validate it looks like a valid save
            if (typeof imported.version !== 'number') {
              throw new Error('Invalid save file format');
            }
            
            // Merge with defaults
            gameSave = { ...createDefaultSave(), ...imported };
            gameSave.stats = { ...createDefaultSave().stats, ...(imported.stats || {}) };
            gameSave.adminConfig = { 
              ...createDefaultSave().adminConfig, 
              ...(imported.adminConfig || {}),
              mathMappings: {
                ...createDefaultSave().adminConfig.mathMappings,
                ...(imported.adminConfig?.mathMappings || {})
              }
            };
            
            // Save to localStorage
            saveGame();
            
            console.log('Save imported successfully:', gameSave);
            resolve(gameSave);
          } catch (error) {
            console.error('Failed to import save:', error);
            reject(error);
          }
        };
        
        reader.onerror = () => {
          reject(new Error('Failed to read file'));
        };
        
        reader.readAsText(file);
      });
    }
    
    // Update mastery tracking after answering a question
    function updateMastery(problemTypeId, wasCorrect) {
      if (!gameSave.mastery[problemTypeId]) {
        gameSave.mastery[problemTypeId] = {
          totalAttempts: 0,
          totalCorrect: 0,
          last10: [],
          masteryAchieved: false
        };
      }
      
      const mastery = gameSave.mastery[problemTypeId];
      mastery.totalAttempts++;
      if (wasCorrect) {
        mastery.totalCorrect++;
      }
      
      // Track last 10 attempts (1 = correct, 0 = wrong)
      mastery.last10.push(wasCorrect ? 1 : 0);
      if (mastery.last10.length > 10) {
        mastery.last10.shift();
      }
      
      // Check mastery criteria:
      // - Minimum 20 attempts
      // - 80%+ overall accuracy
      // - 90%+ accuracy on last 10 attempts (should improve over time)
      if (mastery.totalAttempts >= 20) {
        const overallAccuracy = mastery.totalCorrect / mastery.totalAttempts;
        const last10Correct = mastery.last10.reduce((sum, v) => sum + v, 0);
        const last10Accuracy = mastery.last10.length >= 10 ? last10Correct / 10 : 0;
        
        if (overallAccuracy >= 0.8 && last10Accuracy >= 0.9) {
          if (!mastery.masteryAchieved) {
            mastery.masteryAchieved = true;
            console.log(`Mastery achieved for ${problemTypeId}!`);
            // Could show celebration here in the future
          }
        }
      }
      
      // Update stats
      gameSave.stats.totalQuestionsAnswered++;
      if (wasCorrect) {
        gameSave.stats.totalQuestionsCorrect++;
        gameSave.stats.currentStreak++;
        gameSave.stats.bestStreak = Math.max(gameSave.stats.bestStreak, gameSave.stats.currentStreak);
        
        // Update session stats for quests
        updateSessionStat('questionsCorrect', (gameSave.sessionStats?.questionsCorrect || 0) + 1);
        updateSessionStat('bestStreak', Math.max(gameSave.sessionStats?.bestStreak || 0, gameSave.stats.currentStreak));
      } else {
        gameSave.stats.currentStreak = 0;
      }
      
      // Auto-save after mastery update
      saveGame();
    }
    
    // Update lifetime stats (call these when relevant events happen)
    function recordNightSurvived() {
      gameSave.stats.totalNightsSurvived++;
      gameSave.stats.bestNightReached = Math.max(gameSave.stats.bestNightReached, currentNight);
      
      // Update session stats for quests
      updateSessionStat('nightsSurvived', (gameSave.sessionStats?.nightsSurvived || 0) + 1);
      
      // Check for perfect night (no damage taken)
      if (!sessionDamageTaken) {
        updateSessionStat('perfectNights', (gameSave.sessionStats?.perfectNights || 0) + 1);
      }
      // Reset damage tracking for next night
      sessionDamageTaken = false;
      
      // Award XP for surviving the night
      awardXP(XP_REWARDS.surviveNight, 'Night survived!');
      
      saveGame();
    }
    
    function recordWolfDefeated() {
      gameSave.stats.totalWolvesDefeated++;
      // Update session stats for quests
      updateSessionStat('wolvesDefeated', (gameSave.sessionStats?.wolvesDefeated || 0) + 1);
      saveGame();
    }
    
    function recordTreeChopped() {
      gameSave.stats.totalTreesChopped++;
      // Update session stats for quests
      updateSessionStat('treesChopped', (gameSave.sessionStats?.treesChopped || 0) + 1);
      saveGame();
    }
    
    function recordCultistDefeated() {
      gameSave.stats.totalCultistsDefeated++;
      // Update session stats for quests
      updateSessionStat('cultistsDefeated', (gameSave.sessionStats?.cultistsDefeated || 0) + 1);
      saveGame();
    }
    
    function recordGameStart() {
      gameSave.stats.gamesPlayed++;
      
      // Initialize session stats if needed
      if (!gameSave.sessionStats) {
        gameSave.sessionStats = {
          treesChopped: 0,
          wolvesDefeated: 0,
          questionsCorrect: 0,
          bestStreak: 0,
          nightsSurvived: 0,
          cultistsDefeated: 0,
          rareItemsFound: 0,
          perfectNights: 0
        };
      }
      
      // Reset damage tracking for "perfect night" quest
      sessionDamageTaken = false;
      
      // Check daily login
      const today = new Date().toISOString().split('T')[0];
      if (gameSave.lastLoginDate !== today) {
        const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0];
        if (gameSave.lastLoginDate === yesterday) {
          gameSave.consecutiveLoginDays++;
        } else {
          gameSave.consecutiveLoginDays = 1;
        }
        gameSave.lastLoginDate = today;
      }
      
      saveGame();
    }
    
    // Track if damage was taken this night (for perfect night quest)
    let sessionDamageTaken = false;
    
    // Update session stat for quest tracking
    function updateSessionStat(stat, value) {
      if (!gameSave.sessionStats) {
        gameSave.sessionStats = {};
      }
      gameSave.sessionStats[stat] = value;
      
      // Check if any quests are completed
      checkQuestCompletion();
    }
    
    // Check and mark completed quests
    function checkQuestCompletion() {
      if (!gameSave.dailyQuests) return;
      
      gameSave.dailyQuests.forEach(quest => {
        if (!quest.completed) {
          const progress = gameSave.sessionStats[quest.stat] || 0;
          quest.progress = Math.min(progress, quest.target);
          if (quest.progress >= quest.target) {
            quest.completed = true;
            showQuestComplete(quest);
          }
        }
      });
      
      saveGame();
    }
    
    // Show quest completion notification
    function showQuestComplete(quest) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20%;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
        color: white;
        padding: 20px 40px;
        border-radius: 16px;
        font-size: 24px;
        font-weight: 700;
        font-family: "Kalam", cursive;
        z-index: 10000;
        text-align: center;
        animation: questPop 0.5s ease-out;
        box-shadow: 0 8px 32px rgba(34, 197, 94, 0.4);
      `;
      notification.innerHTML = `
        <div style="font-size: 40px; margin-bottom: 10px;">${quest.icon}</div>
        <div>Quest Complete!</div>
        <div style="font-size: 18px; opacity: 0.9;">${quest.name}</div>
        <div style="font-size: 16px; margin-top: 10px;">+${quest.reward} üíé (Claim in lobby)</div>
      `;
      
      // Add animation
      if (!document.getElementById('quest-complete-style')) {
        const style = document.createElement('style');
        style.id = 'quest-complete-style';
        style.textContent = `
          @keyframes questPop {
            0% { transform: translateX(-50%) scale(0.5); opacity: 0; }
            50% { transform: translateX(-50%) scale(1.1); }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
          }
        `;
        document.head.appendChild(style);
      }
      
      document.body.appendChild(notification);
      setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transition = 'opacity 0.5s';
        setTimeout(() => notification.remove(), 500);
      }, 3000);
    }
    
    // Get problem type ID from current game mode and level
    function getProblemTypeId(level) {
      const prefix = gameMode === 'subtraction' ? 'subtract' : 'add';
      return `${prefix}_level${level}`;
    }
    
    // ============================================
    // XP & LEVELING SYSTEM
    // ============================================
    
    // Level thresholds - XP required to reach each level
    const LEVEL_THRESHOLDS = [
      0,      // Level 1
      100,    // Level 2
      250,    // Level 3
      500,    // Level 4
      1000,   // Level 5
      2000,   // Level 6
      4000,   // Level 7
      8000,   // Level 8
      16000,  // Level 9
      32000   // Level 10
    ];
    
    // XP rewards for various actions
    const XP_REWARDS = {
      correctAnswer: 10,
      correctFirstTry: 5,    // Bonus on top of correctAnswer
      speedBonus3sec: 5,     // Answer in < 3 seconds
      speedBonus2sec: 10,    // Answer in < 2 seconds (replaces 3sec bonus)
      surviveNight: 50,
      defeatAllCultists: 25,
      streakBonus: 2         // Per streak level
    };
    
    // Track answer timing for speed bonuses
    let questionStartTime = 0;
    
    // Calculate level from XP
    function getLevelFromXP(xp) {
      for (let i = LEVEL_THRESHOLDS.length - 1; i >= 0; i--) {
        if (xp >= LEVEL_THRESHOLDS[i]) {
          return i + 1;
        }
      }
      return 1;
    }
    
    // Get XP needed for next level
    function getXPForNextLevel(currentXP) {
      const currentLevel = getLevelFromXP(currentXP);
      if (currentLevel >= LEVEL_THRESHOLDS.length) {
        return null; // Max level reached
      }
      return LEVEL_THRESHOLDS[currentLevel];
    }
    
    // Get progress percentage to next level
    function getLevelProgress(currentXP) {
      const currentLevel = getLevelFromXP(currentXP);
      if (currentLevel >= LEVEL_THRESHOLDS.length) {
        return 100; // Max level
      }
      const currentLevelXP = LEVEL_THRESHOLDS[currentLevel - 1];
      const nextLevelXP = LEVEL_THRESHOLDS[currentLevel];
      const progress = (currentXP - currentLevelXP) / (nextLevelXP - currentLevelXP);
      return Math.min(100, Math.max(0, progress * 100));
    }
    
    // Award XP and check for level up
    function awardXP(amount, reason = '') {
      const oldLevel = getLevelFromXP(gameSave.playerXP);
      gameSave.playerXP += amount;
      const newLevel = getLevelFromXP(gameSave.playerXP);
      
      // Update UI
      updateXPDisplay();
      
      // Show floating XP indicator
      showFloatingXP(amount, reason);
      
      // Check for level up
      if (newLevel > oldLevel) {
        gameSave.playerLevel = newLevel;
        showLevelUpCelebration(newLevel);
      }
      
      saveGame();
      return { xpEarned: amount, leveledUp: newLevel > oldLevel, newLevel };
    }
    
    // Award XP for correct answer with bonuses
    function awardAnswerXP(wasFirstTry, answerTimeMs) {
      let totalXP = XP_REWARDS.correctAnswer;
      let reasons = ['+10 correct'];
      
      // First try bonus
      if (wasFirstTry) {
        totalXP += XP_REWARDS.correctFirstTry;
        reasons.push('+5 first try');
      }
      
      // Speed bonuses (only if first try)
      if (wasFirstTry && answerTimeMs > 0) {
        if (answerTimeMs < 2000) {
          totalXP += XP_REWARDS.speedBonus2sec;
          reasons.push('+10 FAST!');
        } else if (answerTimeMs < 3000) {
          totalXP += XP_REWARDS.speedBonus3sec;
          reasons.push('+5 quick');
        }
      }
      
      // Streak bonus
      const streak = gameSave.stats.currentStreak;
      if (streak > 1) {
        const streakXP = Math.min(streak, 10) * XP_REWARDS.streakBonus; // Cap at 10 streak levels
        totalXP += streakXP;
        reasons.push(`+${streakXP} streak`);
      }
      
      // Math Prodigy class bonus (+50% XP)
      const multiplier = getXPMultiplier();
      if (multiplier > 1) {
        totalXP = Math.floor(totalXP * multiplier);
        reasons.push('üéì Prodigy!');
      }
      
      return awardXP(totalXP, reasons.join(' '));
    }
    
    // Show floating XP indicator
    function showFloatingXP(amount, reason) {
      const gameContainer = document.querySelector('.game-container');
      if (!gameContainer) return;
      
      const floater = document.createElement('div');
      floater.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #ffdd00;
        font-size: 24px;
        font-weight: 700;
        font-family: "Kalam", cursive;
        text-shadow: 0 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(255,221,0,0.5);
        pointer-events: none;
        z-index: 500;
        animation: floatUp 1.5s ease-out forwards;
      `;
      floater.textContent = `+${amount} XP`;
      
      // Add animation keyframes if not already added
      if (!document.getElementById('xp-float-style')) {
        const style = document.createElement('style');
        style.id = 'xp-float-style';
        style.textContent = `
          @keyframes floatUp {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -100%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -150%) scale(0.8); }
          }
        `;
        document.head.appendChild(style);
      }
      
      gameContainer.appendChild(floater);
      setTimeout(() => floater.remove(), 1500);
    }
    
    // Show level up celebration
    function showLevelUpCelebration(newLevel) {
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: radial-gradient(circle, rgba(255,200,0,0.3) 0%, rgba(0,0,0,0.8) 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        animation: levelUpFade 3s ease-out forwards;
      `;
      
      overlay.innerHTML = `
        <div style="font-size: 32px; color: #ffd700; margin-bottom: 20px; animation: levelUpPulse 0.5s ease-in-out infinite alternate;">
          ‚≠ê LEVEL UP! ‚≠ê
        </div>
        <div style="font-size: 72px; font-weight: bold; color: white; text-shadow: 0 0 30px #ffd700, 0 4px 8px rgba(0,0,0,0.5); font-family: 'Kalam', cursive;">
          Level ${newLevel}
        </div>
        <div style="font-size: 18px; color: #ccc; margin-top: 20px;">
          ${getLevelRewardText(newLevel)}
        </div>
      `;
      
      // Add animation styles
      if (!document.getElementById('level-up-style')) {
        const style = document.createElement('style');
        style.id = 'level-up-style';
        style.textContent = `
          @keyframes levelUpFade {
            0% { opacity: 0; }
            10% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
          }
          @keyframes levelUpPulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.1); }
          }
        `;
        document.head.appendChild(style);
      }
      
      document.body.appendChild(overlay);
      setTimeout(() => overlay.remove(), 3000);
    }
    
    // Get reward text for a level
    function getLevelRewardText(level) {
      const rewards = {
        2: 'üê± Pet taming unlocked!',
        3: 'üéñÔ∏è +1 Class slot!',
        5: 'üìã Daily quests unlocked!',
        7: 'üéñÔ∏è +1 Class slot!',
        10: 'üëë Master rank achieved!'
      };
      return rewards[level] || 'Keep going!';
    }
    
    // Update XP display in UI
    function updateXPDisplay() {
      const xpBar = document.getElementById('xpBar');
      const xpText = document.getElementById('xpText');
      const levelText = document.getElementById('levelText');
      
      if (!xpBar || !xpText || !levelText) return;
      
      const currentXP = gameSave.playerXP;
      const currentLevel = getLevelFromXP(currentXP);
      const progress = getLevelProgress(currentXP);
      const nextLevelXP = getXPForNextLevel(currentXP);
      
      xpBar.style.width = `${progress}%`;
      levelText.textContent = `Lvl ${currentLevel}`;
      
      if (nextLevelXP !== null) {
        xpText.textContent = `${currentXP} / ${nextLevelXP} XP`;
      } else {
        xpText.textContent = `${currentXP} XP (MAX)`;
      }
    }
    
    // Update streak display in UI
    function updateStreakDisplay() {
      const streakBadge = document.getElementById('streakBadge');
      const streakCount = document.getElementById('streakCount');
      
      if (!streakBadge || !streakCount) return;
      
      const streak = gameSave.stats.currentStreak;
      
      if (streak >= 3) {
        streakBadge.style.display = 'flex';
        streakCount.textContent = streak;
      } else {
        streakBadge.style.display = 'none';
      }
    }
    
    // ============================================
    // CLASS EFFECTS
    // ============================================
    
    // Check if player owns a specific class
    function hasClass(classId) {
      return gameSave.classes?.[classId]?.purchased === true;
    }
    
    // Get wolf damage (reduced by Thick Skin)
    function getWolfDamage(baseDamage) {
      if (hasClass('thick_skin')) {
        return Math.floor(baseDamage * 0.9); // -10% damage
      }
      return baseDamage;
    }
    
    // Check for Lucky Axe bonus wood
    function getLuckyAxeBonus() {
      if (hasClass('lucky_axe') && Math.random() < 0.2) {
        return 1; // 20% chance for +1 bonus wood
      }
      return 0;
    }
    
    // Get timer bonus from Quick Thinker
    function getTimerBonus() {
      if (hasClass('quick_thinker')) {
        return 2000; // +2 seconds in ms
      }
      return 0;
    }
    
    // Get food healing bonus from Iron Stomach
    function getFoodHealingMultiplier() {
      if (hasClass('iron_stomach')) {
        return 1.25; // +25% healing
      }
      return 1;
    }
    
    // Get fire drain multiplier from Fire Master
    function getFireDrainMultiplier() {
      if (hasClass('fire_master')) {
        return 0.8; // Burns 20% slower (80% drain rate)
      }
      return 1;
    }
    
    // Get XP multiplier from Math Prodigy
    function getXPMultiplier() {
      if (hasClass('math_prodigy')) {
        return 1.5; // +50% XP
      }
      return 1;
    }
    
    // Get movement speed multiplier for Night Walker
    function getNightMovementMultiplier() {
      if (isNight && hasClass('night_walker')) {
        return 1.1; // +10% speed at night
      }
      return 1;
    }
    
    // Calculate total diamonds from all sources
    function calculateTotalDiamonds() {
      let total = 0;
      
      // Rare items (1 diamond each)
      if (rewardsState.rareItems.lanternbark) total += 1;
      if (rewardsState.rareItems.silverWolf) total += 1;
      if (rewardsState.rareItems.whisperingFan) total += 1;
      if (rewardsState.rareItems.frostCanister) total += 1;
      
      // Diamond chest gives 3 diamonds
      if (rewardsState.chestsOpened.diamond) total += 3;
      
      // Milestones
      if (rewardsState.milestones.day10) total += 1;
      if (rewardsState.milestones.day20) total += 2;
      if (rewardsState.milestones.day40) total += 3;
      if (rewardsState.milestones.day60) total += 4;
      if (rewardsState.milestones.day99) total += 5;
      
      // Plus the night-survival diamonds (old system)
      total += diamondsEarned;
      
      return total;
    }
    
    // Update the rewards dropdown display
    function updateRewardsDisplay() {
      const totalDiamonds = calculateTotalDiamonds();
      rewardsDiamondCount.textContent = totalDiamonds;
      
      // Update rare items
      document.getElementById('lanternbarkReward').classList.toggle('earned', rewardsState.rareItems.lanternbark);
      document.getElementById('lanternbarkReward').classList.toggle('unearned', !rewardsState.rareItems.lanternbark);
      
      document.getElementById('silverWolfReward').classList.toggle('earned', rewardsState.rareItems.silverWolf);
      document.getElementById('silverWolfReward').classList.toggle('unearned', !rewardsState.rareItems.silverWolf);
      
      document.getElementById('whisperingFanReward').classList.toggle('earned', rewardsState.rareItems.whisperingFan);
      document.getElementById('whisperingFanReward').classList.toggle('unearned', !rewardsState.rareItems.whisperingFan);
      
      document.getElementById('frostCanisterReward').classList.toggle('earned', rewardsState.rareItems.frostCanister);
      document.getElementById('frostCanisterReward').classList.toggle('unearned', !rewardsState.rareItems.frostCanister);
      
      // Update chests (show key progress)
      const chestTiers = ['wooden', 'golden', 'ruby', 'diamond', 'obsidian'];
      chestTiers.forEach(tier => {
        const chestEl = document.getElementById(`${tier}ChestReward`);
        const keysEl = document.getElementById(`${tier}ChestKeys`);
        const collected = rewardsState.keys[tier];
        const required = rewardsState.keysRequired[tier];
        
        if (rewardsState.chestsOpened[tier]) {
          chestEl.classList.add('earned');
          chestEl.classList.remove('unearned');
          keysEl.textContent = '‚úì Opened';
        } else {
          chestEl.classList.remove('earned');
          chestEl.classList.toggle('unearned', collected === 0 && rewardsState.currentKeyTier !== tier);
          keysEl.textContent = `üîë√ó${collected}/${required}`;
        }
      });
      
      // Update milestones
      document.getElementById('day10Reward').classList.toggle('earned', rewardsState.milestones.day10);
      document.getElementById('day10Reward').classList.toggle('unearned', !rewardsState.milestones.day10);
      
      document.getElementById('day20Reward').classList.toggle('earned', rewardsState.milestones.day20);
      document.getElementById('day20Reward').classList.toggle('unearned', !rewardsState.milestones.day20);
      
      document.getElementById('day40Reward').classList.toggle('earned', rewardsState.milestones.day40);
      document.getElementById('day40Reward').classList.toggle('unearned', !rewardsState.milestones.day40);
      
      document.getElementById('day60Reward').classList.toggle('earned', rewardsState.milestones.day60);
      document.getElementById('day60Reward').classList.toggle('unearned', !rewardsState.milestones.day60);
      
      document.getElementById('day99Reward').classList.toggle('earned', rewardsState.milestones.day99);
      document.getElementById('day99Reward').classList.toggle('unearned', !rewardsState.milestones.day99);
    }
    
    // Animate a diamond flying to the rewards section
    function animateFlyingDiamond(onComplete, message) {
      // Get the rewards category button position
      const rewardsBtn = document.getElementById('rewardsCategory');
      const rewardsRect = rewardsBtn.getBoundingClientRect();
      const targetX = rewardsRect.left + rewardsRect.width / 2;
      const targetY = rewardsRect.top + rewardsRect.height / 2;
      
      // Start position (center of screen)
      const startX = window.innerWidth / 2;
      const startY = window.innerHeight / 2;
      
      // Create a flash overlay
      const flashOverlay = document.createElement('div');
      flashOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: radial-gradient(circle, rgba(100, 200, 255, 0.5) 0%, rgba(100, 200, 255, 0) 70%);
        z-index: 9999;
        pointer-events: none;
        animation: flashFade 2s ease-out forwards;
      `;
      document.body.appendChild(flashOverlay);
      
      // Show message if provided
      let messageEl = null;
      if (message) {
        messageEl = document.createElement('div');
        messageEl.textContent = message;
        messageEl.style.cssText = `
          position: fixed;
          top: 35%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 42px;
          font-weight: 700;
          font-family: "Kalam", "Comic Sans MS", cursive;
          color: white;
          text-shadow: 0 0 20px rgba(100, 200, 255, 0.8), 0 0 40px rgba(100, 200, 255, 0.5);
          z-index: 10002;
          pointer-events: none;
          text-align: center;
          animation: messagePopIn 2s ease-out forwards;
        `;
        document.body.appendChild(messageEl);
        
        // Add message animation style if not exists
        if (!document.getElementById('messagePopInStyle')) {
          const style = document.createElement('style');
          style.id = 'messagePopInStyle';
          style.textContent = `
            @keyframes messagePopIn {
              0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
              20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
              40% { transform: translate(-50%, -50%) scale(1); }
              80% { opacity: 1; }
              100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
            }
          `;
          document.head.appendChild(style);
        }
      }
      
      // Create explosion of diamonds all over the screen
      const diamondCount = 30;
      const explosionDiamonds = [];
      
      for (let i = 0; i < diamondCount; i++) {
        const diamond = document.createElement('div');
        diamond.textContent = 'üíé';
        diamond.style.cssText = `
          position: fixed;
          font-size: ${20 + Math.random() * 40}px;
          z-index: 10001;
          pointer-events: none;
          left: ${Math.random() * window.innerWidth}px;
          top: ${Math.random() * window.innerHeight}px;
          opacity: 1;
          filter: drop-shadow(0 0 10px rgba(100, 200, 255, 0.8));
          animation: diamondExplosion 2s ease-out forwards;
          animation-delay: ${Math.random() * 0.3}s;
        `;
        document.body.appendChild(diamond);
        explosionDiamonds.push(diamond);
      }
      
      // Add the explosion animation style if not exists
      if (!document.getElementById('diamondExplosionStyle')) {
        const style = document.createElement('style');
        style.id = 'diamondExplosionStyle';
        style.textContent = `
          @keyframes diamondExplosion {
            0% { opacity: 1; transform: scale(1) rotate(0deg); }
            50% { opacity: 1; transform: scale(1.3) rotate(180deg); }
            100% { opacity: 0; transform: scale(0.3) rotate(360deg); }
          }
          @keyframes flashFade {
            0% { opacity: 1; }
            100% { opacity: 0; }
          }
        `;
        document.head.appendChild(style);
      }
      
      // After explosion (1 second), clean up and create the flying diamond
      setTimeout(() => {
        flashOverlay.remove();
        explosionDiamonds.forEach(d => d.remove());
        if (messageEl) messageEl.remove();
        
        // Create the main flying diamond
        const diamond = document.createElement('div');
        diamond.className = 'flying-diamond';
        diamond.textContent = 'üíé';
        diamond.style.left = `${startX - 24}px`;
        diamond.style.top = `${startY - 24}px`;
        document.body.appendChild(diamond);
        
        // Animate to target
        const duration = 800;
        const startTime = performance.now();
        
        function animate(currentTime) {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          // Easing function (ease-out cubic)
          const eased = 1 - Math.pow(1 - progress, 3);
          
          const currentX = startX + (targetX - startX) * eased;
          const currentY = startY + (targetY - startY) * eased;
          
          // Add a slight arc
          const arc = Math.sin(progress * Math.PI) * -50;
          
          diamond.style.left = `${currentX - 24}px`;
          diamond.style.top = `${currentY - 24 + arc}px`;
          diamond.style.transform = `scale(${1 - progress * 0.5})`;
          
          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            diamond.remove();
            // Flash the rewards button
            rewardsBtn.style.transition = 'transform 0.1s, box-shadow 0.1s';
            rewardsBtn.style.transform = 'scale(1.1)';
            rewardsBtn.style.boxShadow = '0 0 20px rgba(100, 200, 255, 0.8)';
            setTimeout(() => {
              rewardsBtn.style.transform = '';
              rewardsBtn.style.boxShadow = '';
              if (onComplete) onComplete();
            }, 200);
          }
        }
        
        requestAnimationFrame(animate);
      }, 2000);
    }
    
    // Award a diamond and show notification with animation
    function awardRareItemDiamond(itemName) {
      // Track rare item for quests
      updateSessionStat('rareItemsFound', (gameSave.sessionStats?.rareItemsFound || 0) + 1);
      
      // First show the diamond animation
      animateFlyingDiamond(() => {
        // Then show the notification and update display
        showCraftNotification(`üéâ You found the ${itemName}! +1üíé`);
        updateRewardsDisplay();
      });
    }
    
    // Award a diamond for surviving the night
    function awardNightSurvivalDiamond() {
      diamondsEarned++;
      
      // First show the diamond animation with "You survived another night!" message
      animateFlyingDiamond(() => {
        showCraftNotification(`üåÖ You survived another night! +1üíé`);
        updateRewardsDisplay();
      }, 'You survived another night!');
    }
    
    // Check and award milestones at the start of a new day
    function checkMilestones(day) {
      if (day >= 10 && !rewardsState.milestones.day10) {
        rewardsState.milestones.day10 = true;
        showCraftNotification('üèÅ Day 10 reached! +1üíé');
        updateRewardsDisplay();
      }
      if (day >= 20 && !rewardsState.milestones.day20) {
        rewardsState.milestones.day20 = true;
        showCraftNotification('üèÅ Day 20 reached! +2üíé');
        updateRewardsDisplay();
      }
      if (day >= 40 && !rewardsState.milestones.day40) {
        rewardsState.milestones.day40 = true;
        showCraftNotification('üèÅ Day 40 reached! +3üíé');
        updateRewardsDisplay();
      }
      if (day >= 60 && !rewardsState.milestones.day60) {
        rewardsState.milestones.day60 = true;
        showCraftNotification('üèÅ Day 60 reached! +4üíé');
        updateRewardsDisplay();
      }
      if (day >= 99 && !rewardsState.milestones.day99) {
        rewardsState.milestones.day99 = true;
        showCraftNotification('üèÜ Day 99 reached! +5üíé');
        updateRewardsDisplay();
      }
    }
    
    const FIRE_DECAY_RATES = {
      1: 100 / 600,  // 10 minutes (50% slower)
      2: 100 / 960,  // 16 minutes (50% slower)
      3: 100 / 1440, // 24 minutes (50% slower)
      4: 100 / 1800, // 30 minutes (50% slower)
      5: 100 / 2400  // 40 minutes (50% slower)
    };
    
    // Player state
    let playerX = 0; // World coordinates
    let playerZ = 0;
    const basePlayerSpeed = 0.15;
    // Get effective player speed (Night Walker bonus at night)
    function getPlayerSpeed() {
      return basePlayerSpeed * getNightMovementMultiplier();
    }
    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, a: false, s: false, d: false, e: false, E: false };
    const interactionDistance = 1.5;
    
    // Camera state
    let cameraMode = 'third-person'; // 'third-person' or 'first-person'
    let playerFacingAngle = 0; // Angle in radians, 0 = looking toward negative Z (up on screen)
    let fpYaw = 0; // First-person horizontal rotation (yaw)
    let fpPitch = 0; // First-person vertical rotation (pitch)
    let isPointerLocked = false;
    const FP_FOV = 75; // First-person field of view (wider)
    const TP_FOV = 50; // Third-person field of view (original)
    
    const BASE_CAMPFIRE_CIRCLE_RADIUS = 7.5; // Base dotted circle radius around campfire
    // Safe zone radius grows with fire level: L1=7.5, L2=10, L3=13 (includes farm plot), L4=16
    const SAFE_ZONE_RADII = [7.5, 10, 13, 16];
    let safeZoneRadius = SAFE_ZONE_RADII[0]; // Current safe zone radius (grows with fire level)
    let worldRadius = BASE_CAMPFIRE_CIRCLE_RADIUS * 3; // Start at 3R = 22.5
    let worldSize = worldRadius * 2; // Diameter of the world
    let playerMesh = null;
    let campfireMesh = null;
    let groundMesh = null;
    let safeZoneDots = []; // Store references to the dotted circle meshes
    
    // Camp structures
    let craftingBenchMesh = null;
    const bedMeshes = [];
    const farmPlotMeshes = [];
    let crockPotMesh = null;
    let biofuelProcessorMesh = null;
    const logWallMeshes = [];
    const logWallSegments = [];
    const bearTrapMeshes = [];
    const saplingMeshes = [];
    
    // Entity storage
    const entities = [];
    
    // Minimap - store explored areas by world coordinates, not grid
    const exploredMap = new Set();
    const VISIBILITY_RADIUS = 5; // World units of visibility
    
    let isNearCampfire = false;
    
    // ============================================
    // GAME MODE DETECTION & CONFIGURATION
    // ============================================
    
    // Get game mode from URL parameter (default to addition)
    const urlParams = new URLSearchParams(window.location.search);
    const gameMode = urlParams.get('mode') || 'addition';
    
    // Game mode configurations
    const GAME_MODES = {
      addition: {
        name: 'Addition Mode',
        icon: '‚ûï',
        description: 'Practice addition problems'
      },
      subtraction: {
        name: 'Subtraction Mode',
        icon: '‚ûñ',
        description: 'Practice subtraction problems'
      },
      advanced_add_sub: {
        name: 'Advanced Add & Subtract',
        icon: '‚ûï‚ûñ',
        description: 'Challenging addition and subtraction'
      },
      multiplication: {
        name: 'Multiplication Mode',
        icon: '‚úñÔ∏è',
        description: 'Practice multiplication'
      },
      division: {
        name: 'Division Mode',
        icon: '‚ûó',
        description: 'Practice division'
      },
      advanced_mul_div: {
        name: 'Advanced Multiply & Divide',
        icon: '‚úñÔ∏è‚ûó',
        description: 'Challenging multiplication and division'
      }
    };
    
    // Update UI with current game mode
    const currentModeConfig = GAME_MODES[gameMode] || GAME_MODES.addition;
    document.getElementById('gameModeIcon').textContent = currentModeConfig.icon;
    document.getElementById('gameModeTitle').textContent = currentModeConfig.name;
    
    // Lobby button handler
    document.getElementById('lobbyButton').addEventListener('click', () => {
      if (confirm('Return to the Portal Lobby? Your progress in this session will be lost.')) {
        window.location.href = 'index.html';
      }
    });
    
    // ============================================
    // CURRICULUM DEFINITIONS BY MODE
    // ============================================
    
    // Addition curriculum (existing - loaded from Google Sheets or fallback)
    const ADDITION_CURRICULUM = [
      { level: 1, name: 'Easy Addition', type: 'add', numbersA: '0-5', numbersB: '0-5', numbersC: '', maxSum: '', randomizeOrder: 'No', special: '', description: 'Adding numbers 0-5' },
      { level: 2, name: 'Bridging Numbers', type: 'add', numbersA: '0,1,2,3,4,5,9,10', numbersB: '0,1,2,3,4,5,9,10', numbersC: '', maxSum: '', randomizeOrder: 'No', special: '', description: 'Adding 0-5 and 9,10' },
      { level: 3, name: 'Medium Addition', type: 'add', numbersA: '4-10', numbersB: '4-10', numbersC: '', maxSum: '', randomizeOrder: 'No', special: '', description: 'Adding numbers 4-10' },
      { level: 4, name: 'Missing Addend', type: 'missing', numbersA: '0-10', numbersB: '0-10', numbersC: '', maxSum: '', randomizeOrder: 'Yes', special: '', description: '? + b = c format' },
      { level: 5, name: 'Equation Balance', type: 'balance', numbersA: '0-10', numbersB: '0-10', numbersC: '0-10', maxSum: '', randomizeOrder: 'No', special: '', description: 'a + b = c + ?' },
      { level: 6, name: 'Triple Addition', type: 'triple', numbersA: '0-9', numbersB: '0-9', numbersC: '0-9', maxSum: '20', randomizeOrder: 'No', special: '', description: 'Adding three single digits' },
      { level: 7, name: 'Triple Missing', type: 'triple_missing', numbersA: '0-9', numbersB: '0-9', numbersC: '0-9', maxSum: '20', randomizeOrder: 'No', special: '', description: 'a + b + ? = d' },
      { level: 8, name: 'Tens Plus Ones', type: 'add', numbersA: 'tens', numbersB: '0-9', numbersC: '', maxSum: '', randomizeOrder: 'Yes', special: '', description: '70 + 3 or 3 + 70' },
      { level: 9, name: 'Adding Ten', type: 'add', numbersA: '10-99', numbersB: '10', numbersC: '', maxSum: '', randomizeOrder: 'Yes', special: '', description: 'Two-digit + 10' },
      { level: 10, name: 'Make Ten Triple', type: 'triple', numbersA: '0-9', numbersB: '0-9', numbersC: '0-9', maxSum: '', randomizeOrder: 'No', special: 'make_ten_pair', description: '8 + 1 + 2' },
      { level: 11, name: 'Complement to 20', type: 'complement', numbersA: '0-20', numbersB: '', numbersC: '', maxSum: '20', randomizeOrder: 'Yes', special: '', description: 'a + ? = 20' },
      { level: 12, name: 'Two-Digit Plus One', type: 'add', numbersA: '21-99', numbersB: '0-9', numbersC: '', maxSum: '', randomizeOrder: 'No', special: '', description: '45 + 7' }
    ];
    
    // Subtraction curriculum
    // Level 1: Single digit minus single digit (9 - 3)
    // Level 2: Single digit minus ? = single digit (8 - ? = 5)
    // Level 3: Number between 10 and 20 minus single digit (13 - 4)
    // Level 4: Double digit minus 10 (46 - 10)
    // Level 5: Double digit minus single digit (63 - 4)
    const SUBTRACTION_CURRICULUM = [
      { level: 1, name: 'Basic Subtraction', type: 'subtract', numbersA: '1-10', numbersB: '0-9', numbersC: '', maxSum: '', randomizeOrder: 'No', special: 'no_negative', description: 'Numbers 1-10 minus single digit (10 - 4)' },
      { level: 2, name: 'Missing Subtrahend', type: 'subtract_missing', numbersA: '1-9', numbersB: '0-9', numbersC: '', maxSum: '', randomizeOrder: 'No', special: 'no_negative', description: 'Single digit minus ? = result (8 - ? = 5)' },
      { level: 3, name: 'Teens Minus Single', type: 'subtract', numbersA: '10-20', numbersB: '1-9', numbersC: '', maxSum: '', randomizeOrder: 'No', special: 'no_negative', description: 'Number 10-20 minus single digit (13 - 4)' },
      { level: 4, name: 'Minus Ten', type: 'subtract', numbersA: '20-99', numbersB: '10', numbersC: '', maxSum: '', randomizeOrder: 'No', special: '', description: 'Double digit minus 10 (46 - 10)' },
      { level: 5, name: 'Double Minus Single', type: 'subtract', numbersA: '10-99', numbersB: '1-9', numbersC: '', maxSum: '', randomizeOrder: 'No', special: 'no_negative', description: 'Double digit minus single digit (63 - 4)' }
    ];
    
    // Get curriculum for current mode
    function getCurriculumForMode(mode) {
      switch (mode) {
        case 'subtraction':
          return SUBTRACTION_CURRICULUM;
        case 'addition':
        default:
          return ADDITION_CURRICULUM;
      }
    }
    
    // ============================================
    // CURRICULUM & QUESTION GENERATION
    // ============================================
    
    // Curriculum loaded from Google Sheets or using mode-specific defaults
    let curriculum = [];
    let curriculumLoaded = false;
    
    // Tier to Level mapping - increments every 3 days
    // Base: Tier 1 ‚Üí Level 2, Tier 2 ‚Üí Level 3, etc.
    // Every 3 days, all tiers go up by 1 level
    function getLevelForTier(tier) {
      // For subtraction mode, always use Level 1 for now (single digit - single digit)
      // This can be changed later as the player progresses
      if (gameMode === 'subtraction') {
        return 1;
      }
      
      const baseLevel = tier + 1; // Tier 1 starts at Level 2
      const dayIncrement = Math.floor((currentDay - 1) / 3); // +1 level every 3 days
      const level = baseLevel + dayIncrement;
      
      // Cap at max available level in curriculum
      const maxLevel = curriculum.length > 0 ? Math.max(...curriculum.map(l => l.level)) : 12;
      return Math.min(level, maxLevel);
    }
    
    // Google Sheet ID from the public URL (only used for addition mode)
    const SHEET_ID = '14dM5CYAzZiXJt0o7ejzSbbkqsNwQp64KBGAOkfsph7Y';
    const SHEET_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json`;
    
    // Load curriculum based on game mode
    async function loadCurriculum() {
      // For non-addition modes, use the built-in curriculum
      if (gameMode !== 'addition') {
        curriculum = getCurriculumForMode(gameMode);
        curriculumLoaded = true;
        console.log(`Curriculum loaded for ${gameMode} mode:`, curriculum);
        return;
      }
      
      // For addition mode, try to load from Google Sheets
      try {
        const response = await fetch(SHEET_URL);
        const text = await response.text();
        // Google returns JSONP, strip the wrapper
        const json = JSON.parse(text.substring(47, text.length - 2));
        
        const rows = json.table.rows;
        curriculum = [];
        
        for (let i = 1; i < rows.length; i++) { // Skip header row
          const row = rows[i];
          if (!row.c || !row.c[0] || !row.c[0].v) continue; // Skip empty rows
          
          const level = {
            level: parseInt(row.c[0]?.v) || 0,
            name: row.c[1]?.v || '',
            type: row.c[2]?.v || 'add',
            numbersA: row.c[3]?.v || '',
            numbersB: row.c[4]?.v || '',
            numbersC: row.c[5]?.v || '',
            maxSum: row.c[6]?.v || '',
            randomizeOrder: row.c[7]?.v || '',
            special: row.c[8]?.v || '',
            description: row.c[9]?.v || ''
          };
          curriculum.push(level);
        }
        
        curriculumLoaded = true;
        console.log('Curriculum loaded from Google Sheets:', curriculum);
      } catch (error) {
        console.error('Failed to load curriculum from Google Sheets:', error);
        // Fall back to hardcoded curriculum
        loadFallbackCurriculum();
      }
    }
    
    // Fallback curriculum if Google Sheets fails
    function loadFallbackCurriculum() {
      curriculum = [
        { level: 1, name: 'Easy Addition', type: 'add', numbersA: '0-5', numbersB: '0-5', numbersC: '', maxSum: '', randomizeOrder: 'No', special: '', description: 'Adding numbers 0-5' },
        { level: 2, name: 'Bridging Numbers', type: 'add', numbersA: '0,1,2,3,4,5,9,10', numbersB: '0,1,2,3,4,5,9,10', numbersC: '', maxSum: '', randomizeOrder: 'No', special: '', description: 'Adding 0-5 and 9,10' },
        { level: 3, name: 'Medium Addition', type: 'add', numbersA: '4-10', numbersB: '4-10', numbersC: '', maxSum: '', randomizeOrder: 'No', special: '', description: 'Adding numbers 4-10' },
        { level: 4, name: 'Missing Addend', type: 'missing', numbersA: '0-10', numbersB: '0-10', numbersC: '', maxSum: '', randomizeOrder: 'Yes', special: '', description: '? + b = c format' },
        { level: 5, name: 'Equation Balance', type: 'balance', numbersA: '0-10', numbersB: '0-10', numbersC: '0-10', maxSum: '', randomizeOrder: 'No', special: '', description: 'a + b = c + ?' },
        { level: 6, name: 'Triple Addition', type: 'triple', numbersA: '0-9', numbersB: '0-9', numbersC: '0-9', maxSum: '20', randomizeOrder: 'No', special: '', description: 'Adding three single digits' },
        { level: 7, name: 'Triple Missing', type: 'triple_missing', numbersA: '0-9', numbersB: '0-9', numbersC: '0-9', maxSum: '20', randomizeOrder: 'No', special: '', description: 'a + b + ? = d' },
        { level: 8, name: 'Tens Plus Ones', type: 'add', numbersA: 'tens', numbersB: '0-9', numbersC: '', maxSum: '', randomizeOrder: 'Yes', special: '', description: '70 + 3 or 3 + 70' },
        { level: 9, name: 'Adding Ten', type: 'add', numbersA: '10-99', numbersB: '10', numbersC: '', maxSum: '', randomizeOrder: 'Yes', special: '', description: 'Two-digit + 10' },
        { level: 10, name: 'Make Ten Triple', type: 'triple', numbersA: '0-9', numbersB: '0-9', numbersC: '0-9', maxSum: '', randomizeOrder: 'No', special: 'make_ten_pair', description: '8 + 1 + 2' },
        { level: 11, name: 'Complement to 20', type: 'complement', numbersA: '0-20', numbersB: '', numbersC: '', maxSum: '20', randomizeOrder: 'Yes', special: '', description: 'a + ? = 20' },
        { level: 12, name: 'Two-Digit Plus One', type: 'add', numbersA: '21-99', numbersB: '0-9', numbersC: '', maxSum: '', randomizeOrder: 'No', special: '', description: '45 + 7' }
      ];
      curriculumLoaded = true;
      console.log('Using fallback curriculum');
    }
    
    // Parse a number spec like "0-5", "0,1,2,3,4,5,9,10", "tens", or "10"
    function parseNumberSpec(spec) {
      if (!spec || spec === '') return [0];
      spec = String(spec).trim();
      
      // Special case: "tens" means 10, 20, 30, ..., 90
      if (spec === 'tens') {
        return [10, 20, 30, 40, 50, 60, 70, 80, 90];
      }
      
      // Range: "0-5" or "4-10"
      if (spec.includes('-')) {
        const [min, max] = spec.split('-').map(n => parseInt(n.trim()));
        const nums = [];
        for (let i = min; i <= max; i++) nums.push(i);
        return nums;
      }
      
      // List: "0,1,2,3,4,5,9,10"
      if (spec.includes(',')) {
        return spec.split(',').map(n => parseInt(n.trim()));
      }
      
      // Single number
      return [parseInt(spec)];
    }
    
    // Pick a random element from an array
    function pickRandom(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }
    
    // Shuffle an array (Fisher-Yates)
    function shuffle(arr) {
      const result = [...arr];
      for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
      }
      return result;
    }
    
    // Generate a question based on curriculum level
    function generateQuestionForLevel(levelNum) {
      const levelData = curriculum.find(l => l.level === levelNum);
      if (!levelData) {
        console.warn(`Level ${levelNum} not found, falling back to level 1`);
        return generateQuestionForLevel(1);
      }
      
      const numbersA = parseNumberSpec(levelData.numbersA);
      const numbersB = parseNumberSpec(levelData.numbersB);
      const numbersC = parseNumberSpec(levelData.numbersC);
      const maxSum = levelData.maxSum ? parseInt(levelData.maxSum) : Infinity;
      const randomizeOrder = String(levelData.randomizeOrder).toLowerCase() === 'yes';
      const special = levelData.special || '';
      const type = levelData.type || 'add';
      
      let attempts = 0;
      while (attempts < 100) {
        attempts++;
        let question = null;
        
        switch (type) {
          case 'add': {
            let a = pickRandom(numbersA);
            let b = pickRandom(numbersB);
            if (a + b > maxSum) continue;
            if (randomizeOrder && Math.random() < 0.5) [a, b] = [b, a];
            question = { equation: `${a} + ${b}`, answer: a + b, level: levelNum };
            break;
          }
          
          case 'missing': {
            // ? + b = c or a + ? = c
            const a = pickRandom(numbersA);
            const b = pickRandom(numbersB);
            const c = a + b;
            if (c > maxSum) continue;
            
            if (randomizeOrder && Math.random() < 0.5) {
              question = { equation: `? + ${b} = ${c}`, answer: a, isKeyQuestion: true, level: levelNum };
            } else {
              question = { equation: `${a} + ? = ${c}`, answer: b, isKeyQuestion: true, level: levelNum };
            }
            break;
          }
          
          case 'balance': {
            // a + b = c + ? (mystery can be anywhere)
            const a = pickRandom(numbersA);
            const b = pickRandom(numbersB);
            const c = pickRandom(numbersC);
            const d = a + b - c; // What ? must equal
            if (d < 0) continue; // No negative answers
            
            // Randomly place the mystery in one of 4 positions
            const pos = Math.floor(Math.random() * 4);
            let answer;
            if (pos === 0) {
              answer = a;
              if (answer > maxSum) continue; // Respect maxSum for answer
              question = { equation: `? + ${b} = ${c} + ${d}`, answer: a, isKeyQuestion: true, level: levelNum };
            } else if (pos === 1) {
              answer = b;
              if (answer > maxSum) continue;
              question = { equation: `${a} + ? = ${c} + ${d}`, answer: b, isKeyQuestion: true, level: levelNum };
            } else if (pos === 2) {
              answer = c;
              if (answer > maxSum) continue;
              question = { equation: `${a} + ${b} = ? + ${d}`, answer: c, isKeyQuestion: true, level: levelNum };
            } else {
              answer = d;
              if (answer > maxSum) continue;
              question = { equation: `${a} + ${b} = ${c} + ?`, answer: d, isKeyQuestion: true, level: levelNum };
            }
            break;
          }
          
          case 'triple': {
            // a + b + c (three numbers)
            let a = pickRandom(numbersA);
            let b = pickRandom(numbersB);
            let c = pickRandom(numbersC);
            
            // Special case: make_ten_pair means two numbers must sum to 10
            if (special === 'make_ten_pair') {
              a = Math.floor(Math.random() * 10); // 0-9
              b = 10 - a; // Complement to 10
              c = pickRandom(numbersC);
              const nums = shuffle([a, b, c]);
              [a, b, c] = nums;
            }
            
            if (a + b + c > maxSum) continue;
            question = { equation: `${a} + ${b} + ${c}`, answer: a + b + c, level: levelNum };
            break;
          }
          
          case 'triple_missing': {
            // a + b + ? = d (mystery can be anywhere)
            let a = pickRandom(numbersA);
            let b = pickRandom(numbersB);
            let c = pickRandom(numbersC);
            const d = a + b + c;
            if (d > maxSum) continue;
            
            const pos = Math.floor(Math.random() * 3);
            if (pos === 0) {
              question = { equation: `? + ${b} + ${c} = ${d}`, answer: a, isKeyQuestion: true, level: levelNum };
            } else if (pos === 1) {
              question = { equation: `${a} + ? + ${c} = ${d}`, answer: b, isKeyQuestion: true, level: levelNum };
            } else {
              question = { equation: `${a} + ${b} + ? = ${d}`, answer: c, isKeyQuestion: true, level: levelNum };
            }
            break;
          }
          
          case 'complement': {
            // a + ? = target (where target is maxSum, typically 20)
            const target = maxSum || 20;
            const a = pickRandom(numbersA);
            if (a > target) continue;
            const answer = target - a;
            
            if (randomizeOrder && Math.random() < 0.5) {
              question = { equation: `? + ${a} = ${target}`, answer: answer, isKeyQuestion: true, level: levelNum };
            } else {
              question = { equation: `${a} + ? = ${target}`, answer: answer, isKeyQuestion: true, level: levelNum };
            }
            break;
          }
          
          case 'subtract': {
            // a - b = ? (subtraction)
            const a = pickRandom(numbersA);
            const b = pickRandom(numbersB);
            const result = a - b;
            
            // Skip if result would be negative and 'no_negative' is set
            if (special === 'no_negative' && result < 0) continue;
            
            question = { equation: `${a} ‚àí ${b}`, answer: result, level: levelNum };
            break;
          }
          
          case 'subtract_missing': {
            // a - ? = c (find the subtrahend)
            const a = pickRandom(numbersA);
            const b = pickRandom(numbersB);
            const c = a - b;
            
            // Skip if result would be negative and 'no_negative' is set
            if (special === 'no_negative' && c < 0) continue;
            
            question = { equation: `${a} ‚àí ? = ${c}`, answer: b, isKeyQuestion: true, level: levelNum };
            break;
          }
          
          default:
            // Default to simple addition (or subtraction if in subtraction mode)
            const a = pickRandom(numbersA);
            const b = pickRandom(numbersB);
            if (gameMode === 'subtraction') {
              const result = a - b;
              if (result >= 0) {
                question = { equation: `${a} ‚àí ${b}`, answer: result, level: levelNum };
              } else {
                question = { equation: `${b} ‚àí ${a}`, answer: b - a, level: levelNum };
              }
            } else {
              question = { equation: `${a} + ${b}`, answer: a + b, level: levelNum };
            }
        }
        
        if (question) return question;
      }
      
      // Fallback if we couldn't generate a valid question
      if (gameMode === 'subtraction') {
        return { equation: '5 ‚àí 2', answer: 3, level: 1 };
      }
      return { equation: '1 + 1', answer: 2, level: 1 };
    }
    
    // Generate question for a specific tier
    function generateTierQuestion(tier) {
      const level = getLevelForTier(tier);
      return generateQuestionForLevel(level);
    }
    
    // Legacy function wrappers for compatibility
    function generateWolfQuestion() {
      return generateTierQuestion(1);
    }
    
    function generateCultistQuestion() {
      return generateTierQuestion(1);
    }
    
    function generateTreeQuestion() {
      return generateTierQuestion(2);
    }
    
    function generateHarderQuestion() {
      // When player has upgraded weapons, use one tier higher
      return generateTierQuestion(3);
    }
    
    function generateChainsawQuestion() {
      return generateTierQuestion(3);
    }
    
    function generateCoalOrMetalQuestion() {
      return generateTierQuestion(3);
    }
    
    function generateKeyQuestion() {
      return generateTierQuestion(4);
    }
    
    function generateUniqueQuestions(generator, count) {
      const questions = [];
      let lastEquation = null;
      let attempts = 0;
      
      while (questions.length < count && attempts < count * 10) {
        const q = generator();
        if (q.equation !== lastEquation) {
          questions.push(q);
          lastEquation = q.equation;
        }
        attempts++;
      }
      
      return questions;
    }
    
    // Generate questions based on admin config for a given action
    function generateQuestionsFromAdminConfig(actionKey, countOverride = null) {
      const mapping = gameSave.adminConfig?.mathMappings?.[actionKey];
      if (!mapping) {
        // Fallback to tier-based generation if no config
        return generateUniqueQuestions(generateTierQuestion.bind(null, 1), 1);
      }
      
      const { problemType, questionCount } = mapping;
      const count = countOverride !== null ? countOverride : questionCount;
      
      // Parse problem type to get curriculum and level
      // Format: "add_level3" or "subtract_level1"
      const match = problemType.match(/^(add|subtract)_level(\d+)$/);
      if (!match) {
        return generateUniqueQuestions(generateTierQuestion.bind(null, 1), count);
      }
      
      const [, type, levelStr] = match;
      const level = parseInt(levelStr);
      
      // Generate questions using the specified level
      const generator = () => {
        // Temporarily switch curriculum if needed
        const targetCurriculum = type === 'subtract' ? SUBTRACTION_CURRICULUM : ADDITION_CURRICULUM;
        const originalCurriculum = curriculum;
        curriculum = targetCurriculum;
        const question = generateQuestionForLevel(level);
        curriculum = originalCurriculum;
        return question;
      };
      
      return generateUniqueQuestions(generator, count);
    }
    
    // Get timer duration from admin config
    function getTimerFromAdminConfig(actionKey) {
      const mapping = gameSave.adminConfig?.mathMappings?.[actionKey];
      return mapping?.timerSeconds || 0;
    }
    
    // Initialize curriculum on page load
    loadCurriculum();
    
    // ============================================
    // ENTITY GENERATION
    // ============================================
    
    function generateEntities() {
      const minDistance = 10; // Spacing between entities
      const minCampfireDistance = 15; // Clear area around campfire
      const fenceRadius = 14.5; // Keep entities outside the fenced area (approximate wallRadius)
      const fencePadding = 3; // Extra padding around fence
      
      function isTooClose(x, z) {
        // Check distance from campfire - entities must be outside the fenced area with padding
        const distFromCampfire = Math.sqrt(x * x + z * z);
        if (distFromCampfire < fenceRadius + fencePadding) return true; // Use fence radius + padding
        
        // Check distance from other entities
        for (const entity of entities) {
          const dx = x - entity.x;
          const dz = z - entity.z;
          const dist = Math.sqrt(dx * dx + dz * dz);
          if (dist < minDistance) return true;
        }
        
        return false;
      }
      
      function placeEntity(type, action, count) {
        let placed = 0;
        let attempts = 0;
        
        while (placed < count && attempts < count * 50) {
          const x = (Math.random() - 0.5) * worldSize * 0.9;
          const z = (Math.random() - 0.5) * worldSize * 0.9;
          
          if (!isTooClose(x, z)) {
            entities.push({ type, action, x, z });
            placed++;
          }
          attempts++;
        }
      }
      
      // Total entities for Level 1
      placeEntity('tree', 'chop', 6);
      placeEntity('wolf', 'fightWolf', 3);
      placeEntity('fuel', 'collectFuel', 1);
      // Scrap metal variety: bolt (1 metal), fan (2 metal), radio (3 metal)
      placeEntity('bolt', 'salvageBolt', 1);
      placeEntity('fan', 'salvageFan', 1);
      placeEntity('radio', 'salvageRadio', 1);
      
      // Mark 1 in 10 trees as enchanted
      const trees = entities.filter(e => e.type === 'tree');
      trees.forEach(tree => {
        tree.isEnchanted = Math.random() < 0.1; // 10% chance
      });
      
      // Create 3D meshes for each entity
      entities.forEach(entity => {
        let mesh;
        if (entity.type === 'tree') {
          mesh = createTree(entity.x, entity.z, entity.isEnchanted);
        } else if (entity.type === 'wolf') {
          mesh = createWolf(entity.x, entity.z);
        } else if (entity.type === 'fuel') {
          mesh = createFuelCanister(entity.x, entity.z);
        } else if (entity.type === 'fan') {
          mesh = createBrokenFan(entity.x, entity.z);
        } else if (entity.type === 'bolt') {
          mesh = createBolt(entity.x, entity.z);
        } else if (entity.type === 'radio') {
          mesh = createOldRadio(entity.x, entity.z);
        }
        
        if (mesh) {
          entity.mesh = mesh;
          scene.add(mesh);
        }
      });
      
      // Mark rare entities based on spawn chances (after meshes are created)
      markRareEntities();
    }
    
    // ============================================
    // MATH DIALOG
    // ============================================
    
    function showWelcomeMessage() {
      // Wait for font to load before rendering
      document.fonts.ready.then(() => {
        // Create a canvas for the text
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 2048;
        canvas.height = 512;
        
        // Draw text on canvas
        context.fillStyle = 'rgba(0, 0, 0, 0)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.font = '700 96px "Kalam", "Comic Sans MS", cursive';
        context.fillStyle = 'white';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        
        // Draw text (two lines)
        const line1 = 'SURVIVE THE NIGHTS';
        const line2 = 'EARN DIAMONDS';
        const lineHeight = 120;
        
        context.fillText(line1, canvas.width / 2, canvas.height / 2 - lineHeight / 2);
        context.fillText(line2, canvas.width / 2, canvas.height / 2 + lineHeight / 2);
        
        // Create texture from canvas
        const texture = new THREE.CanvasTexture(canvas);
        
        // Create sprite material
        const spriteMaterial = new THREE.SpriteMaterial({ 
          map: texture,
          transparent: true,
          opacity: 1
        });
        
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.position.set(0, 5, 0); // Above the campfire
        sprite.scale.set(40, 10, 1);
        scene.add(sprite);
        
        // Fade out animation after 3 seconds
        setTimeout(() => {
          let opacity = 1;
          const fadeInterval = setInterval(() => {
            opacity -= 0.02;
            if (opacity <= 0) {
              opacity = 0;
              clearInterval(fadeInterval);
              scene.remove(sprite);
              texture.dispose();
              spriteMaterial.dispose();
            }
            spriteMaterial.opacity = opacity;
          }, 50);
        }, 3000);
      });
    }
    
    function showAction(actionKey, entity) {
      currentAction = actionKey;
      currentInteractable = entity;
      isDialogOpen = true;
      currentQuestionIndex = 0;
      questionsCorrectFirstTry = []; // Reset first-try tracking
      currentQuestionAttempts = 0; // Reset attempt counter
      currentQuestionTimedOut = false;
      
      // Release pointer lock so player can type in the dialog
      if (document.pointerLockElement) {
        document.exitPointerLock();
      }
      
      // Get timer setting from admin config
      const timerSeconds = getTimerFromAdminConfig(actionKey);
      const hasTimer = timerSeconds > 0;
      
      // Action-specific labels and UI
      const actionLabels = {
        fightWolf: 'Fight Wolf!',
        fightCultist: 'Fight Cultist!',
        chop: 'Chop Tree',
        collectFuel: 'Collect Fuel',
        salvageFan: 'Salvage Fan (+2 metal)',
        salvageBolt: 'Salvage Bolt (+1 metal)',
        salvageRadio: 'Salvage Radio (+3 metal)',
        collectKey: entity?.tier ? `üîë ${entity.tier.charAt(0).toUpperCase() + entity.tier.slice(1)} Key` : 'üîë Key',
        crafting: 'Crafting',
        harvestFarm: 'Harvest Farm',
        makeStew: 'Make Stew'
      };
      
      // Handle weapon upgrades that modify question generation
      if (actionKey === 'fightWolf' || actionKey === 'fightCultist') {
        // Spear: 2 questions instead of configured amount
        if (rewardsState.weapons.hasSpear) {
          currentQuestions = generateQuestionsFromAdminConfig(actionKey, 2);
        } else {
          currentQuestions = generateQuestionsFromAdminConfig(actionKey);
        }
        mathBubbleLabel.textContent = actionLabels[actionKey];
        mathTimerBar.style.display = hasTimer ? 'block' : 'none';
        mathQuestionCounter.style.display = currentQuestions.length > 1 ? 'block' : 'none';
      } else if (actionKey === 'chop') {
        // Chainsaw: 1 question, Good Axe: 2 questions, otherwise use config
        if (rewardsState.weapons.hasChainsaw) {
          currentQuestions = generateQuestionsFromAdminConfig(actionKey, 1);
          mathBubbleLabel.textContent = "‚õìÔ∏è Chainsaw Tree";
          mathQuestionCounter.style.display = 'none';
        } else if (rewardsState.weapons.hasGoodAxe) {
          currentQuestions = generateQuestionsFromAdminConfig(actionKey, 2);
          mathBubbleLabel.textContent = "ü™ì Chop Tree";
          mathQuestionCounter.style.display = 'block';
        } else {
          currentQuestions = generateQuestionsFromAdminConfig(actionKey);
          mathBubbleLabel.textContent = actionLabels[actionKey];
          mathQuestionCounter.style.display = currentQuestions.length > 1 ? 'block' : 'none';
        }
        mathTimerBar.style.display = hasTimer ? 'block' : 'none';
      } else {
        // All other actions - use admin config directly
        currentQuestions = generateQuestionsFromAdminConfig(actionKey);
        mathBubbleLabel.textContent = actionLabels[actionKey] || actionKey;
        mathTimerBar.style.display = hasTimer ? 'block' : 'none';
        mathQuestionCounter.style.display = currentQuestions.length > 1 ? 'block' : 'none';
      }
      
      // Stop player movement
      for (let key in keys) keys[key] = false;
      
      mathBubble.classList.add('active');
      mathAnswerInput.value = '';
      mathBubbleFeedback.textContent = '';
      mathBubbleFeedback.classList.remove('good', 'bad');
      
      showCurrentQuestion();
    }
    
    function showCurrentQuestion() {
      const q = currentQuestions[currentQuestionIndex];
      // Key questions already have the full equation, others need "= ?"
      mathQuestion.textContent = q.isKeyQuestion ? q.equation : `${q.equation} = ?`;
      
      if (currentQuestions.length > 1) {
        mathQuestionCounter.textContent = `Question ${currentQuestionIndex + 1} of ${currentQuestions.length}`;
      }
      
      mathAnswerInput.focus();
      
      // Reset flags and counter for new question
      currentQuestionTimedOut = false;
      currentQuestionAttempts = 0;
      
      // Start timing for speed bonus
      questionStartTime = Date.now();
      
      // Start timer if configured for this action
      const actionTimer = getTimerFromAdminConfig(currentAction);
      if (actionTimer > 0) {
        timerDuration = actionTimer * 1000 + getTimerBonus(); // Convert to ms + Quick Thinker bonus
        startTimer();
      }
    }
    
    function startTimer(resume = false) {
      if (timerInterval) clearInterval(timerInterval);
      
      if (!resume) {
        timeRemaining = timerDuration;
        mathTimerFill.style.width = "100%";
        mathTimerFill.classList.remove("danger");
      }
      
      timerInterval = setInterval(() => {
        timeRemaining -= 100;
        const percentage = (timeRemaining / timerDuration) * 100;
        mathTimerFill.style.width = `${percentage}%`;
        
        if (percentage < 30) {
          mathTimerFill.classList.add("danger");
        }
        
        if (timeRemaining <= 0) {
          clearInterval(timerInterval);
          
          // Mark that this question timed out (counts as not first try)
          currentQuestionTimedOut = true;
          currentQuestionAttempts++; // Count timeout as an attempt
          
          // Time's up! Damage player health (reduced by Thick Skin for wolves)
          const timeoutDamage = currentAction === 'fightWolf' ? getWolfDamage(20) : 20;
          damagePlayer(timeoutDamage);
          
          // Flash red screen for timeout
          flashRedScreen();
          
          mathBubbleFeedback.textContent = `‚è± Time's up! -${timeoutDamage}% health`;
          mathBubbleFeedback.classList.add("bad");
          
          // Check if player died
          if (playerHealth <= 0) {
            hideBubble();
            showGameOver();
            return;
          }
          
          // Stop the timer - no more damage, but player needs to solve it
          setTimeout(() => {
            mathBubbleFeedback.textContent = "";
            mathAnswerInput.value = ""; // Clear the input
            mathAnswerInput.focus(); // Refocus
            // Don't restart timer - let them solve it without time pressure
          }, 1000);
        }
      }, 100);
    }
    
    function hideBubble() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      mathBubble.classList.remove('active');
      isDialogOpen = false;
      currentInteractable = null;
      currentAction = '';
      currentQuestions = [];
      currentQuestionIndex = 0;
      questionsCorrect = 0;
      
      // Re-lock pointer if in first-person mode
      if (cameraMode === 'first-person') {
        canvas.requestPointerLock();
      }
    }
    
    function flashRedScreen() {
      // Create red overlay
      const flash = document.createElement('div');
      flash.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(255, 0, 0, 0.4);
        z-index: 9999;
        pointer-events: none;
        animation: fadeOut 0.5s ease-out;
      `;
      document.body.appendChild(flash);
      
      // Remove after animation
      setTimeout(() => {
        flash.remove();
      }, 500);
    }
    
    function handleSubmit() {
      // Ignore empty submissions - don't treat as wrong
      if (mathAnswerInput.value.trim() === '') {
        return;
      }
      
      const userAnswer = parseInt(mathAnswerInput.value, 10);
      const currentQuestion = currentQuestions[currentQuestionIndex];
      const correctAnswer = currentQuestion.answer;
      
      // Stop timer immediately on any answer (correct or wrong)
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      
      // Get problem type ID for mastery tracking
      const problemTypeId = getProblemTypeId(currentQuestion.level || 1);
      
      if (userAnswer === correctAnswer) {
        // Track mastery for correct answer
        updateMastery(problemTypeId, true);
        // Check if this was first try (no previous attempts and not timed out)
        const isFirstTry = (currentQuestionAttempts === 0 && !currentQuestionTimedOut);
        
        // Record whether this question was answered correctly on first try
        questionsCorrectFirstTry[currentQuestionIndex] = isFirstTry;
        
        // Calculate answer time and award XP
        const answerTime = Date.now() - questionStartTime;
        awardAnswerXP(isFirstTry, answerTime);
        
        // Update streak display
        updateStreakDisplay();
        
        // Provide appropriate feedback
        if (isFirstTry) {
          if (currentAction === 'fightWolf') {
            mathBubbleFeedback.textContent = "‚úì Correct! +1 meat";
          } else if (currentAction === 'chop') {
            mathBubbleFeedback.textContent = "‚úì Correct! +1 wood";
          } else {
            mathBubbleFeedback.textContent = "‚úì Correct!";
          }
        } else {
          // Got it right but not on first try - no reward
          if (currentAction === 'fightWolf') {
            mathBubbleFeedback.textContent = "‚úì Correct, but too late. No meat.";
          } else if (currentAction === 'chop') {
            mathBubbleFeedback.textContent = "‚úì Correct, but too late. No wood.";
          } else if (currentAction === 'collectFuel') {
            mathBubbleFeedback.textContent = "‚úì Correct, but too late. No fuel.";
          } else if (currentAction === 'salvageFan' || currentAction === 'salvageBolt' || currentAction === 'salvageRadio') {
            mathBubbleFeedback.textContent = "‚úì Correct, but too late. No metal.";
          }
        }
        
        mathBubbleFeedback.classList.remove('bad');
        mathBubbleFeedback.classList.add('good');
      } else {
        // Wrong answer - increment attempts and let them retry
        currentQuestionAttempts++;
        
        // Track mastery for wrong answer
        updateMastery(problemTypeId, false);
        
        // Update streak display (streak is reset in updateMastery)
        updateStreakDisplay();
        
        // Damage health for wrong answers in wolf/cultist encounters
        if (currentAction === 'fightWolf' || currentAction === 'fightCultist') {
          // Thick Skin reduces wolf damage
          const wrongDamage = currentAction === 'fightWolf' ? getWolfDamage(20) : 20;
          damagePlayer(wrongDamage);
          
          mathBubbleFeedback.textContent = `‚úó Wrong! -${wrongDamage}% health. Try again.`;
          
          // Check if player died
          if (playerHealth <= 0) {
            hideBubble();
            showGameOver();
            return;
          }
        } else {
          mathBubbleFeedback.textContent = `‚úó Wrong! Try again.`;
        }
        
        // Flash red screen for wrong answer
        flashRedScreen();
        
        mathBubbleFeedback.classList.remove('good');
        mathBubbleFeedback.classList.add('bad');
        mathAnswerInput.value = "";
        mathAnswerInput.focus();
        
        // Don't advance to next question - let them retry
        return;
      }
      
      currentQuestionIndex++;
      
      if (currentQuestionIndex < currentQuestions.length) {
        // More questions to go
        setTimeout(() => {
          mathBubbleFeedback.textContent = "";
          mathAnswerInput.value = "";
          showCurrentQuestion();
        }, 800);
      } else {
        // All questions done
        setTimeout(() => {
          completeEncounter();
          hideBubble();
        }, 1000);
      }
    }
    
    function completeEncounter() {
      const actionKey = currentAction;
      
      if (actionKey === 'chop') {
        // Tree: get wood based on weapon
        let woodEarned = 0;
        let feedbackText = "";
        const isEnchanted = currentInteractable && currentInteractable.isEnchanted;
        
        if (rewardsState.weapons.hasChainsaw) {
          // Chainsaw: 1 question = 4 wood if correct on first try
          const correctFirstTry = questionsCorrectFirstTry[0] === true;
          if (correctFirstTry) {
            woodEarned = 4;
            feedbackText = `‚õìÔ∏è Chainsaw! +4 wood`;
          } else {
            feedbackText = "No wood - need to answer correctly on first try!";
          }
        } else if (rewardsState.weapons.hasGoodAxe) {
          // Good Axe: 2 questions, wood for each correct on first try
          woodEarned = questionsCorrectFirstTry.filter(x => x === true).length;
          const bothFirstTry = (questionsCorrectFirstTry.length === 2 && 
                                 questionsCorrectFirstTry.every(x => x === true));
          if (bothFirstTry) {
            woodEarned += 1; // Bonus sapling
            feedbackText = `‚úì Perfect! +${woodEarned - 1} wood +1 sapling!`;
          } else if (woodEarned > 0) {
            feedbackText = `+${woodEarned} wood`;
          } else {
            feedbackText = "No wood - need to answer correctly on first try!";
          }
        } else {
          // Normal axe: 3 questions, wood for each correct on first try
          woodEarned = questionsCorrectFirstTry.filter(x => x === true).length;
          const allThreeFirstTry = (questionsCorrectFirstTry.length === 3 && 
                                     questionsCorrectFirstTry.every(x => x === true));
          if (allThreeFirstTry) {
            woodEarned += 1; // Bonus sapling
            feedbackText = `‚úì Perfect! +${woodEarned - 1} wood +1 sapling!`;
          } else if (woodEarned > 0) {
            feedbackText = `+${woodEarned} wood`;
          } else {
            feedbackText = "No wood - need to answer correctly on first try!";
          }
        }
        
        if (woodEarned > 0) {
          // Lucky Axe bonus - 20% chance for extra wood
          const luckyBonus = getLuckyAxeBonus();
          if (luckyBonus > 0) {
            woodEarned += luckyBonus;
            feedbackText += ' üçÄ+1 Lucky!';
          }
          woodCount.textContent = parseInt(woodCount.textContent, 10) + woodEarned;
        }
        mathBubbleFeedback.textContent = feedbackText;
        
        // Enchanted trees give a surprise diamond!
        if (isEnchanted && woodEarned > 0) {
          setTimeout(() => {
            diamondsEarned++;
            animateFlyingDiamond(() => {
              showCraftNotification('‚ú® Enchanted Tree! +1üíé');
              updateRewardsDisplay();
            });
          }, 500);
        }
        
        // Legacy code path removed - handled above
        if (false) {
          mathBubbleFeedback.textContent = "No wood - you needed to answer correctly on first try!";
        }
        
        // Check for rare Enchanted Tree
        if (currentInteractable && currentInteractable.isRare && currentInteractable.rareType === 'lanternbark') {
          rewardsState.rareItems.lanternbark = true;
          rewardsState.rareEntityMarkers.lanternbarkTree = null;
          setTimeout(() => {
            awardRareItemDiamond('Enchanted Tree');
          }, 100);
        }
        
        if (currentInteractable && currentInteractable.mesh) {
          scene.remove(currentInteractable.mesh);
          const index = entities.indexOf(currentInteractable);
          if (index > -1) entities.splice(index, 1);
        }
        
        // Record tree chopped for persistence
        recordTreeChopped();
        
        // Check if we need to respawn trees
        checkTreeCount();
      } else if (actionKey === 'fightCultist') {
        // Cultist defeated - remove from scene
        if (currentInteractable && currentInteractable.mesh) {
          scene.remove(currentInteractable.mesh);
          const index = cultists.indexOf(currentInteractable);
          if (index > -1) cultists.splice(index, 1);
        }
        
        cultistsDefeated++;
        mathBubbleFeedback.textContent = `‚úì Cultist defeated! (${cultistsDefeated}/3)`;
        
        // Record cultist defeated for persistence
        recordCultistDefeated();

        // Check if all 3 cultists defeated (and reward not yet given)
        if (cultistsDefeated === 3 && !cultistRewardGiven) {
          cultistRewardGiven = true;
          
          // Award XP for defeating all cultists
          awardXP(XP_REWARDS.defeatAllCultists, 'All cultists defeated!');
          
          setTimeout(() => {
            scrapCount.textContent = parseInt(scrapCount.textContent, 10) + 3;
            showCultistVictoryNotification();
            // End the night early when all cultists are defeated
            setTimeout(() => {
              endNightEarly();
            }, 2000);
          }, 1000);
        }
      } else if (actionKey === 'fightWolf') {
        // Wolf: get meat ONLY for questions answered correctly on first try AND on time
        const meat = questionsCorrectFirstTry.filter(x => x === true).length;
        const maxQuestions = rewardsState.weapons.hasSpear ? 2 : 3;
        const isPerfect = meat === maxQuestions;
        
        if (meat > 0) {
          meatCount.textContent = parseInt(meatCount.textContent, 10) + meat;
        }
        
        if (isPerfect) {
          const spearPrefix = rewardsState.weapons.hasSpear ? "üî± " : "";
          mathBubbleFeedback.textContent = `${spearPrefix}‚úì Wolf defeated! +${meat} meat`;
        } else if (meat > 0) {
          mathBubbleFeedback.textContent = `+${meat} meat`;
        } else {
          mathBubbleFeedback.textContent = "No meat - too slow or wrong answers!";
        }
        
        // Check for rare Enchanted Wolf
        if (currentInteractable && currentInteractable.isRare && currentInteractable.rareType === 'silverWolf') {
          rewardsState.rareItems.silverWolf = true;
          rewardsState.rareEntityMarkers.silverGleamWolf = null;
          setTimeout(() => {
            awardRareItemDiamond('Enchanted Wolf');
          }, 100);
        }
        
        if (currentInteractable && currentInteractable.mesh) {
          scene.remove(currentInteractable.mesh);
          const index = entities.indexOf(currentInteractable);
          if (index > -1) entities.splice(index, 1);
        }
        
        // Record wolf defeated for persistence
        recordWolfDefeated();
      } else if (actionKey === 'collectFuel') {
        // Fuel: only get reward if correct on first try
        const gotReward = questionsCorrectFirstTry[0] === true;
        
        if (gotReward) {
          coalCount.textContent = parseInt(coalCount.textContent, 10) + 1;
          mathBubbleFeedback.textContent = "‚úì Collected! +1 fuel";
        } else {
          mathBubbleFeedback.textContent = "No fuel - you needed to answer correctly on first try!";
        }
        
        // Check for rare Enchanted Fuel
        if (currentInteractable && currentInteractable.isRare && currentInteractable.rareType === 'frostCanister') {
          rewardsState.rareItems.frostCanister = true;
          rewardsState.rareEntityMarkers.frostLockedCanister = null;
          setTimeout(() => {
            awardRareItemDiamond('Enchanted Fuel');
          }, 100);
        }
        
        if (currentInteractable && currentInteractable.mesh) {
          scene.remove(currentInteractable.mesh);
          const index = entities.indexOf(currentInteractable);
          if (index > -1) entities.splice(index, 1);
        }
      } else if (actionKey === 'salvageFan') {
        // Fan: only get reward if correct on first try - worth 2 metal
        const gotReward = questionsCorrectFirstTry[0] === true;
        
        if (gotReward) {
          scrapCount.textContent = parseInt(scrapCount.textContent, 10) + 2;
          mathBubbleFeedback.textContent = "‚úì Salvaged! +2 metal";
        } else {
          mathBubbleFeedback.textContent = "No metal - you needed to answer correctly on first try!";
        }
        
        // Check for rare Enchanted Scrap
        if (currentInteractable && currentInteractable.isRare && currentInteractable.rareType === 'whisperingFan') {
          rewardsState.rareItems.whisperingFan = true;
          rewardsState.rareEntityMarkers.whisperingFanBlade = null;
          setTimeout(() => {
            awardRareItemDiamond('Enchanted Scrap');
          }, 100);
        }
        
        if (currentInteractable && currentInteractable.mesh) {
          scene.remove(currentInteractable.mesh);
          const index = entities.indexOf(currentInteractable);
          if (index > -1) entities.splice(index, 1);
        }
      } else if (actionKey === 'salvageBolt') {
        // Bolt: only get reward if correct on first try - worth 1 metal
        const gotReward = questionsCorrectFirstTry[0] === true;
        
        if (gotReward) {
          scrapCount.textContent = parseInt(scrapCount.textContent, 10) + 1;
          mathBubbleFeedback.textContent = "‚úì Salvaged! +1 metal";
        } else {
          mathBubbleFeedback.textContent = "No metal - you needed to answer correctly on first try!";
        }
        
        if (currentInteractable && currentInteractable.mesh) {
          scene.remove(currentInteractable.mesh);
          const index = entities.indexOf(currentInteractable);
          if (index > -1) entities.splice(index, 1);
        }
      } else if (actionKey === 'salvageRadio') {
        // Radio: only get reward if correct on first try - worth 3 metal
        const gotReward = questionsCorrectFirstTry[0] === true;
        
        if (gotReward) {
          scrapCount.textContent = parseInt(scrapCount.textContent, 10) + 3;
          mathBubbleFeedback.textContent = "‚úì Salvaged! +3 metal";
        } else {
          mathBubbleFeedback.textContent = "No metal - you needed to answer correctly on first try!";
        }
        
        if (currentInteractable && currentInteractable.mesh) {
          scene.remove(currentInteractable.mesh);
          const index = entities.indexOf(currentInteractable);
          if (index > -1) entities.splice(index, 1);
        }
      } else if (actionKey === 'collectKey') {
        // Key collection - always succeeds (even if wrong first try, they still get the key)
        const tier = currentInteractable.tier;
        rewardsState.keys[tier]++;
        
        const tierName = tier.charAt(0).toUpperCase() + tier.slice(1);
        const collected = rewardsState.keys[tier];
        const required = rewardsState.keysRequired[tier];
        
        mathBubbleFeedback.textContent = `‚úì Got ${tierName} Key! (${collected}/${required})`;
        
        // Remove the key from the world
        if (currentInteractable && currentInteractable.mesh) {
          scene.remove(currentInteractable.mesh);
          const index = keyEntities.indexOf(currentInteractable);
          if (index > -1) keyEntities.splice(index, 1);
        }
        
        updateRewardsDisplay();
        
        // Check if we have all keys for this tier
        if (collected >= required) {
          setTimeout(() => {
            onAllKeysCollected(tier);
          }, 1000);
        } else {
          // Schedule next key spawn after delay
          scheduleNextKeySpawn();
        }
      } else if (actionKey === 'harvestFarm') {
        // Farm harvest: add carrots based on farm plots owned
        const totalCarrots = farmPlotsOwned * 6;
        carrots += totalCarrots;
        carrotCount.textContent = carrots;
        farmPlotDaysUntilHarvest = 2; // Reset timer
        mathBubbleFeedback.textContent = `‚úì Harvested! +${totalCarrots} carrots`;
        updateInventoryDisplay();
        updateFarmPlotVisuals(); // Hide carrots after harvest
      } else if (actionKey === 'cookStew') {
        // Crock pot: deduct 3 food, add 1 stew
        let foodToRemove = 3;
        const currentMeat = parseInt(meatCount.textContent, 10);
        
        // First use carrots, then meat
        if (carrots >= foodToRemove) {
          carrots -= foodToRemove;
          carrotCount.textContent = carrots;
        } else {
          const carrotsUsed = carrots;
          carrots = 0;
          carrotCount.textContent = 0;
          foodToRemove -= carrotsUsed;
          meatCount.textContent = currentMeat - foodToRemove;
        }
        
        stew++;
        stewCount.textContent = stew;
        mathBubbleFeedback.textContent = "‚úì Cooked! +1 stew";
        updateInventoryDisplay();
      } else if (actionKey === 'makeBiofuel') {
        // Biofuel processor: 1 meat + 1 wood = biofuel added directly to fire
        const currentMeat = parseInt(meatCount.textContent, 10);
        const currentWood = parseInt(woodCount.textContent, 10);
        meatCount.textContent = currentMeat - 1;
        woodCount.textContent = currentWood - 1;
        
        // Add biofuel directly to fire (17% at L1, 6% at L2+)
        const biofuelValue = currentFireLevel === 1 ? 17 : 6;
        fireStrength = Math.min(100, fireStrength + biofuelValue);
        fireBar.style.width = `${fireStrength}%`;
        checkFireLevelUp();
        
        mathBubbleFeedback.textContent = `‚úì Processed! +${biofuelValue}% fire`;
        updateInventoryDisplay();
      } else if (actionKey === 'craftingMath') {
        // Crafting math problem completed - now craft the item
        if (pendingCraftItem) {
          mathBubbleFeedback.textContent = "‚úì Correct!";
          setTimeout(() => {
            craftItem(pendingCraftItem);
            pendingCraftItem = null;
          }, 500);
        }
      }
    }
    
    // ============================================
    // PROXIMITY DETECTION
    // ============================================
    
    function checkProximity() {
      if (isDialogOpen) return;
      
      // Check regular entities
      for (const entity of entities) {
        const dx = playerX - entity.x;
        const dz = playerZ - entity.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < interactionDistance) {
          showAction(entity.action, entity);
          return;
        }
      }
      
      // Check cultists
      for (const cultist of cultists) {
        const dx = playerX - cultist.x;
        const dz = playerZ - cultist.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < interactionDistance) {
          showAction(cultist.action, cultist);
          return;
        }
      }
      
      // Check keys
      for (const key of keyEntities) {
        const dx = playerX - key.x;
        const dz = playerZ - key.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < interactionDistance) {
          showAction('collectKey', key);
          return;
        }
      }
      
      // Check proximity to chests - auto-open when close
      for (const chest of chestEntities) {
        const dx = playerX - chest.x;
        const dz = playerZ - chest.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < interactionDistance + 1) { // Slightly larger range for chests
          openChest(chest);
          return;
        }
      }
    }
    
    // Open a chest and award the reward
    function openChest(chest) {
      const tier = chest.tier;
      const tierName = tier.charAt(0).toUpperCase() + tier.slice(1);
      
      // Remove chest from world
      if (chest.mesh) {
        scene.remove(chest.mesh);
        const index = chestEntities.indexOf(chest);
        if (index > -1) chestEntities.splice(index, 1);
      }
      
      // Mark as opened
      rewardsState.chestsOpened[tier] = true;
      rewardsState.activeChest = null;
      
      // Determine and give the reward
      const reward = determineChestReward(tier);
      giveChestReward(reward);
      
      // Show reward popup
      showChestRewardPopup(tierName, reward);
      
      // Start spawning next tier of keys after chest is opened
      const tierOrder = ['wooden', 'golden', 'ruby', 'diamond', 'obsidian'];
      const currentIndex = tierOrder.indexOf(tier);
      
      if (currentIndex < tierOrder.length - 1) {
        const nextTier = tierOrder[currentIndex + 1];
        rewardsState.currentKeyTier = nextTier;
        keysSpawnedThisTier = 0;
        
        // Spawn first key of next tier after a short delay
        setTimeout(() => {
          spawnSingleKey(nextTier);
        }, 3000);
      }
      
      updateRewardsDisplay();
    }
    
    // Determine what reward comes from a chest
    function determineChestReward(tier) {
      const roll = Math.random();
      
      switch (tier) {
        case 'wooden':
          // Always Good Axe
            return { type: 'goodAxe', name: 'Good Axe', description: 'Trees now take 2 harder problems to chop!' };
          
        case 'golden':
          // Always 1 diamond + 2 fuel canisters
          return { type: 'diamondAndFuel', amount: 1, fuelAmount: 2, name: '1 Diamond + 2 Fuel', description: 'A shiny diamond and fuel for your fire!' };
          
        case 'ruby':
          return { type: 'spear', name: 'Spear', description: 'Wolves and cultists now take 2 harder problems to defeat!' };
          
        case 'diamond':
          return { type: 'diamonds', amount: 3, name: '3 Diamonds', description: 'Shiny!' };
          
        case 'obsidian':
          return { type: 'chainsaw', name: 'Chainsaw', description: 'Trees now take just 1 problem for 4 wood!' };
          
        default:
          return { type: 'fuel', amount: 1, name: '1 Fuel Canister', description: 'Added to your inventory!' };
      }
    }
    
    // Give the chest reward to the player
    function giveChestReward(reward) {
      switch (reward.type) {
        case 'goodAxe':
          rewardsState.weapons.hasGoodAxe = true;
          updateWeaponsDisplay();
          break;
        case 'spear':
          rewardsState.weapons.hasSpear = true;
          updateWeaponsDisplay();
          break;
        case 'chainsaw':
          rewardsState.weapons.hasChainsaw = true;
          // Chainsaw replaces good axe
          rewardsState.weapons.hasGoodAxe = false;
          updateWeaponsDisplay();
          break;
        case 'scraps':
          const currentScraps = parseInt(scrapCount.textContent) || 0;
          scrapCount.textContent = currentScraps + reward.amount;
          break;
        case 'fuel':
          const currentFuel = parseInt(coalCount.textContent) || 0;
          coalCount.textContent = currentFuel + reward.amount;
          break;
        case 'diamondAndFuel':
          // Award diamond(s) and fuel canisters
          diamondsEarned += reward.amount;
          const currentFuelDF = parseInt(coalCount.textContent) || 0;
          coalCount.textContent = currentFuelDF + reward.fuelAmount;
          break;
        case 'diamonds':
          // Award diamonds
          for (let i = 0; i < reward.amount; i++) {
            diamondsEarned++;
          }
          break;
      }
    }
    
    // Show a popup for the chest reward
    function showChestRewardPopup(chestName, reward) {
      // Create popup overlay
      const popup = document.createElement('div');
      popup.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        animation: fadeIn 0.3s ease;
      `;
      
      // Emoji for reward type
      const rewardEmoji = {
        goodAxe: 'ü™ì',
        spear: 'üî±',
        chainsaw: '‚õìÔ∏è',
        scraps: '‚öôÔ∏è',
        fuel: '‚õΩ',
        diamonds: 'üíé',
        diamondAndFuel: 'üíé‚õΩ'
      };
      
      const emoji = rewardEmoji[reward.type] || 'üéÅ';
      
      popup.innerHTML = `
        <div style="
          background: linear-gradient(135deg, #2a1a0a 0%, #4a2a1a 100%);
          border: 4px solid #FFD700;
          border-radius: 20px;
          padding: 40px 60px;
          text-align: center;
          box-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
          animation: popIn 0.4s ease;
        ">
          <div style="font-size: 48px; margin-bottom: 10px;">üéâ</div>
          <div style="font-size: 24px; color: #FFD700; margin-bottom: 20px; font-family: 'Cinzel', serif;">
            ${chestName} Chest Opened!
          </div>
          <div style="font-size: 64px; margin: 20px 0;">${emoji}</div>
          <div style="font-size: 28px; color: #fff; margin-bottom: 10px; font-family: 'Cinzel', serif;">
            ${reward.name}
          </div>
          <div style="font-size: 18px; color: #ccc; margin-bottom: 30px;">
            ${reward.description}
          </div>
          <button id="closeChestPopup" style="
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            font-family: 'Cinzel', serif;
            color: #2a1a0a;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
          ">Continue</button>
        </div>
      `;
      
      document.body.appendChild(popup);
      
      // Add close handler
      document.getElementById('closeChestPopup').addEventListener('click', () => {
        popup.remove();
      });
      
      // Also close on any key press
      const closeOnKey = (e) => {
        popup.remove();
        document.removeEventListener('keydown', closeOnKey);
      };
      setTimeout(() => {
        document.addEventListener('keydown', closeOnKey);
      }, 500);
    }
    
    // ============================================
    // CAMPFIRE HEALING
    // ============================================
    
    function updateHealthBar() {
      healthBar.style.width = `${playerHealth}%`;
      
      // Update health bar color based on percentage
      healthBar.classList.remove('medium', 'low', 'critical');
      if (playerHealth <= 25) {
        healthBar.classList.add('critical');
      } else if (playerHealth <= 50) {
        healthBar.classList.add('low');
      } else if (playerHealth <= 75) {
        healthBar.classList.add('medium');
      }
    }
    
    function damagePlayer(amount) {
      playerHealth = Math.max(0, Math.floor(playerHealth - amount));
      updateHealthBar();
      
      // Track damage for perfect night quest
      if (isNight) {
        sessionDamageTaken = true;
      }
      
      // Immediate death check after any damage
      if (playerHealth <= 0 && !isGameOver) {
        showGameOver();
      }
    }
    
    function checkCampfireHealing() {
      if (isPaused) return; // Don't heal when paused
      if (isDialogOpen) return; // Don't heal during encounters/dialogs
      
      const dx = playerX - 0;
      const dz = playerZ - 0;
      const distance = Math.sqrt(dx * dx + dz * dz);
      
      if (distance < 3) {
        isNearCampfire = true;
        // Don't heal during cultist encounters or when fire is out
        if (cultists.length === 0 && fireStrength > 0) {
          playerHealth = Math.min(100, playerHealth + 0.25); // 50% slower (was 0.5)
          updateHealthBar();
        }
      } else {
        isNearCampfire = false;
      }
    }
    
    // ============================================
    // FIRE SYSTEM
    // ============================================
    
    function updateFire() {
      const baseDecayRate = FIRE_DECAY_RATES[currentFireLevel] || FIRE_DECAY_RATES[1];
      // Fire Master reduces fire drain by 20%
      const decayRate = baseDecayRate * getFireDrainMultiplier();
      fireStrength = Math.max(0, fireStrength - decayRate);
      fireBar.style.width = `${fireStrength}%`;
      
      // Show one-time "your fire is low" warning at 10%
      if (fireStrength <= 10 && fireStrength > 0 && !fireWarningShown) {
        fireWarningShown = true;
        showWarningMessage("Your fire is low!", 'fire-warning');
      }
      
      // Reset warning when fire goes back above 10%
      if (fireStrength > 10) {
        fireWarningShown = false;
      }
      
      // Show/hide flames based on fire strength
      updateFlamesVisibility();
    }
    
    function updateFlamesVisibility() {
      if (campfireMesh && campfireMesh.userData.flamesGroup) {
        campfireMesh.userData.flamesGroup.visible = fireStrength > 0;
      }
    }
    
    function checkFireLevelUp() {
      if (fireStrength >= 100 && currentFireLevel < 4) {
        levelUpFire();
      }
    }
    
    function levelUpFire() {
      currentFireLevel++;
      fireLevel.textContent = currentFireLevel;
      // Level 1‚Üí2 starts at 50%, subsequent levels start at 25%
      fireStrength = currentFireLevel === 2 ? 50 : 25;
      fireBar.style.width = `${fireStrength}%`;
      
      // Expand the world size based on campfire circle radius (R = 7.5)
      // Level 1: 3R = 22.5, Level 2: 6R = 45, Level 3: 8R = 60, Level 4: 10R = 75
      const radiusMultipliers = [3, 6, 8, 10]; // For levels 1-4
      const multiplier = radiusMultipliers[currentFireLevel - 1] || 10; // Default to 10R for level 5+
      worldRadius = BASE_CAMPFIRE_CIRCLE_RADIUS * multiplier;
      worldSize = worldRadius * 2;
      
      // Expand the safe zone (dotted circle) - L1=7.5, L2=10, L3=13, L4=16
      updateSafeZoneRadius();
      
      // Remove old ground
      if (groundMesh) {
        scene.remove(groundMesh);
      }
      
      // Create new larger ground
      groundMesh = createGround(worldRadius);
      scene.add(groundMesh);
      
      // Expand the map with new entities
      expandMap();
      
      // Start key spawning at Fire Level 2
      if (currentFireLevel === 2 && rewardsState.currentKeyTier === null) {
        rewardsState.currentKeyTier = 'wooden';
        keysSpawnedThisTier = 0;
        spawnSingleKey('wooden');
      }
      
      // Show notification
      showMapExpansionNotification();
    }
    
    // Update the safe zone radius and reposition the dotted circle
    function updateSafeZoneRadius() {
      const levelIndex = Math.min(currentFireLevel - 1, SAFE_ZONE_RADII.length - 1);
      safeZoneRadius = SAFE_ZONE_RADII[levelIndex];
      
      // Reposition all the dots to the new radius
      safeZoneDots.forEach(dot => {
        const angle = (dot.userData.dotIndex / dot.userData.numDots) * Math.PI * 2;
        dot.position.x = Math.cos(angle) * safeZoneRadius;
        dot.position.z = Math.sin(angle) * safeZoneRadius;
      });
    }
    
    // Track how many keys have been spawned for current tier
    let keysSpawnedThisTier = 0;
    let keySpawnTimeout = null;
    const KEY_SPAWN_DELAY = 60000; // 60 seconds between keys
    
    // Called when all keys of a tier are collected
    function onAllKeysCollected(tier) {
      const tierName = tier.charAt(0).toUpperCase() + tier.slice(1);
      showCraftNotification(`üéâ All ${tierName} Keys collected! A chest has appeared - find it!`);
      
      // Clear any pending key spawn
      if (keySpawnTimeout) {
        clearTimeout(keySpawnTimeout);
        keySpawnTimeout = null;
      }
      
      // Spawn the chest - next tier keys will spawn when chest is OPENED
      spawnChest(tier);
      
      // Clear current key tier until chest is opened
      rewardsState.currentKeyTier = null;
    }
    
    // Schedule the next key spawn after a delay
    function scheduleNextKeySpawn() {
      const tier = rewardsState.currentKeyTier;
      if (!tier) return;
      
      const required = rewardsState.keysRequired[tier];
      const collected = rewardsState.keys[tier];
      
      // Only spawn more if we haven't spawned all required yet
      // and there are no keys currently in the world waiting to be collected
      if (keysSpawnedThisTier < required && keyEntities.length === 0) {
        keySpawnTimeout = setTimeout(() => {
          if (rewardsState.currentKeyTier === tier) { // Make sure tier hasn't changed
            const tierName = tier.charAt(0).toUpperCase() + tier.slice(1);
            spawnSingleKey(tier);
          }
        }, KEY_SPAWN_DELAY);
      }
    }
    
    // Spawn a chest of a specific tier
    function spawnChest(tier) {
      const minDistance = 10;
      const minPlayerDistance = 15; // Chest must spawn at least this far from player
      const fenceRadius = 14.5;
      const fencePadding = 3;
      
      function isTooClose(x, z) {
        const distFromCampfire = Math.sqrt(x * x + z * z);
        if (distFromCampfire < fenceRadius + fencePadding) return true;
        
        // Check distance from player - chest shouldn't spawn right on top of them!
        const dxPlayer = x - playerX;
        const dzPlayer = z - playerZ;
        const distFromPlayer = Math.sqrt(dxPlayer * dxPlayer + dzPlayer * dzPlayer);
        if (distFromPlayer < minPlayerDistance) return true;
        
        // Check distance from other entities, keys, and chests
        for (const entity of [...entities, ...keyEntities, ...chestEntities]) {
          const dx = x - entity.x;
          const dz = z - entity.z;
          const dist = Math.sqrt(dx * dx + dz * dz);
          if (dist < minDistance) return true;
        }
        return false;
      }
      
      let spawned = false;
      let attempts = 0;
      let chestX, chestZ;
      
      while (!spawned && attempts < 100) {
        const angle = Math.random() * Math.PI * 2;
        const radius = fenceRadius + fencePadding + 8 + Math.random() * (worldRadius - fenceRadius - fencePadding - 15);
        chestX = Math.cos(angle) * radius;
        chestZ = Math.sin(angle) * radius;
        
        const maxCoord = worldSize / 2 - 3;
        if (Math.abs(chestX) < maxCoord && Math.abs(chestZ) < maxCoord && !isTooClose(chestX, chestZ)) {
          spawned = true;
        }
        attempts++;
      }
      
      if (spawned) {
        const chestEntity = { type: 'chest', action: 'openChest', tier: tier, x: chestX, z: chestZ };
        const mesh = createChest(chestX, chestZ, tier);
        chestEntity.mesh = mesh;
        chestEntities.push(chestEntity);
        scene.add(mesh);
        
        // Mark the chest as spawned in rewards state
        rewardsState.chestSpawned[tier] = true;
        
        console.log(`Spawned ${tier} chest at (${chestX.toFixed(1)}, ${chestZ.toFixed(1)})`);
      } else {
        console.warn(`Failed to spawn ${tier} chest after ${attempts} attempts`);
      }
    }
    
    // Spawn a single key
    function spawnSingleKey(tier) {
      const minDistance = 8;
      const fenceRadius = 14.5;
      const fencePadding = 3;
      
      function isTooClose(x, z) {
        const distFromCampfire = Math.sqrt(x * x + z * z);
        if (distFromCampfire < fenceRadius + fencePadding) return true;
        
        // Check distance from other entities and keys
        for (const entity of [...entities, ...keyEntities]) {
          const dx = x - entity.x;
          const dz = z - entity.z;
          const dist = Math.sqrt(dx * dx + dz * dz);
          if (dist < minDistance) return true;
        }
        return false;
      }
      
      let spawned = false;
      let attempts = 0;
      
      while (!spawned && attempts < 50) {
        const angle = Math.random() * Math.PI * 2;
        const radius = fenceRadius + fencePadding + 5 + Math.random() * (worldRadius - fenceRadius - fencePadding - 10);
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        
        const maxCoord = worldSize / 2 - 2;
        if (Math.abs(x) < maxCoord && Math.abs(z) < maxCoord && !isTooClose(x, z)) {
          const keyEntity = { type: 'key', action: 'collectKey', tier: tier, x, z };
          const mesh = createKey(x, z, tier);
          keyEntity.mesh = mesh;
          keyEntities.push(keyEntity);
          scene.add(mesh);
          keysSpawnedThisTier++;
          spawned = true;
        }
        attempts++;
      }
      
      console.log(`Spawned ${tier} key (${keysSpawnedThisTier}/${rewardsState.keysRequired[tier]})`);
      updateRewardsDisplay();
    }
    
    // Check and respawn trees if count drops below minimum
    function checkTreeCount() {
      const treeCount = entities.filter(e => e.type === 'tree').length;
      const minTrees = 4;
      
      if (treeCount < minTrees) {
        const treesToSpawn = minTrees - treeCount;
        spawnTreesOffScreen(treesToSpawn);
      }
    }
    
    function spawnTreesOffScreen(count) {
      const minDistance = 8;
      const fenceRadius = 14.5;
      const fencePadding = 3;
      
      // Calculate which direction is "behind" the camera (off-screen)
      // Camera looks from playerZ + 30 toward player, so spawn trees at low Z values (top of screen)
      // or at edges far from player
      
      function isTooClose(x, z) {
        // Check distance from campfire
        const distFromCampfire = Math.sqrt(x * x + z * z);
        if (distFromCampfire < fenceRadius + fencePadding) return true;
        
        // Check distance from player (want to spawn away from player)
        const distFromPlayer = Math.sqrt((x - playerX) ** 2 + (z - playerZ) ** 2);
        if (distFromPlayer < 15) return true; // At least 15 units from player (off-screen)
        
        // Check distance from other entities
        for (const entity of entities) {
          const dx = x - entity.x;
          const dz = z - entity.z;
          const dist = Math.sqrt(dx * dx + dz * dz);
          if (dist < minDistance) return true;
        }
        
        return false;
      }
      
      let spawned = 0;
      let attempts = 0;
      
      while (spawned < count && attempts < count * 50) {
        // Try to spawn in the current world bounds, preferring areas away from player
        const angle = Math.random() * Math.PI * 2;
        const radius = fenceRadius + fencePadding + 5 + Math.random() * (worldRadius - fenceRadius - fencePadding - 10);
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        
        // Make sure it's within world bounds
        const maxCoord = worldSize / 2 - 2;
        if (Math.abs(x) < maxCoord && Math.abs(z) < maxCoord && !isTooClose(x, z)) {
          const isEnchanted = Math.random() < 0.1; // 10% chance to be enchanted
          const entity = { type: 'tree', action: 'chop', x, z, isEnchanted };
          const mesh = createTree(x, z, isEnchanted);
          entity.mesh = mesh;
          entities.push(entity);
          scene.add(mesh);
          spawned++;
        }
        attempts++;
      }
      
      if (spawned > 0) {
        console.log(`Respawned ${spawned} trees to maintain minimum count`);
      }
    }
    
    function expandMap() {
      // Generate more entities with better spacing
      const minDistance = 10; // Same spacing as initial generation
      const fenceRadius = 14.5; // Keep entities outside the fenced area
      const fencePadding = 3; // Extra padding around fence
      
      function isTooClose(x, z) {
        const campfireX = 0;
        const campfireZ = 0;
        
        // Check distance from campfire - entities must be outside the fenced area with padding
        const distFromCampfire = Math.sqrt(x * x + z * z);
        if (distFromCampfire < fenceRadius + fencePadding) return true; // Use fence radius + padding
        
        // Check distance from other entities
        for (const entity of entities) {
          const dx = x - entity.x;
          const dz = z - entity.z;
          const dist = Math.sqrt(dx * dx + dz * dz);
          if (dist < minDistance) return true;
        }
        
        return false;
      }
      
      function placeNewEntities(type, action, count) {
        let placed = 0;
        let attempts = 0;
        
        while (placed < count && attempts < count * 30) {
          // Place entities anywhere in the expanded world (5-95%)
          const x = (Math.random() - 0.5) * worldSize * 0.9;
          const z = (Math.random() - 0.5) * worldSize * 0.9;
          if (!isTooClose(x, z)) {
            const entity = { type, action, x, z };
            
            // 10% of trees are enchanted
            if (type === 'tree') {
              entity.isEnchanted = Math.random() < 0.1;
            }
            
            entities.push(entity);
            
            let mesh;
            if (type === 'tree') {
              mesh = createTree(x, z, entity.isEnchanted);
            } else if (type === 'wolf') {
              mesh = createWolf(x, z);
            } else if (type === 'fuel') {
              mesh = createFuelCanister(x, z);
            } else if (type === 'fan') {
              mesh = createBrokenFan(x, z);
            } else if (type === 'bolt') {
              mesh = createBolt(x, z);
            } else if (type === 'radio') {
              mesh = createOldRadio(x, z);
            }
            
            if (mesh) {
              entity.mesh = mesh;
              scene.add(mesh);
            }
            
            placed++;
          }
          attempts++;
        }
      }
      
      // Add entities to maintain density
      // Base counts per expansion (matching Level 1 ratios)
      const baseTreeCount = 6;
      const baseWolfCount = 3;
      const baseFuelCount = 1;
      // Scrap metal variety: bolt (1 metal), fan (2 metal), radio (3 metal)
      const baseBoltCount = 1;
      const baseFanCount = 1;
      const baseRadioCount = 1;
      
      // Scale based on current fire level
      const scaleFactor = currentFireLevel;
      
      placeNewEntities('tree', 'chop', baseTreeCount * scaleFactor);
      placeNewEntities('wolf', 'fightWolf', baseWolfCount * scaleFactor);
      placeNewEntities('fuel', 'collectFuel', baseFuelCount * scaleFactor);
      placeNewEntities('bolt', 'salvageBolt', baseBoltCount * scaleFactor);
      placeNewEntities('fan', 'salvageFan', baseFanCount * scaleFactor);
      placeNewEntities('radio', 'salvageRadio', baseRadioCount * scaleFactor);
      
      // Check for rare items in newly spawned entities
      markRareEntities();
    }
    
    function showMapExpansionNotification() {
      // Create notification element
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #ff7b00 0%, #ff5e00 100%);
        color: white;
        padding: 30px 50px;
        border-radius: 16px;
        font-size: 24px;
        font-weight: bold;
        z-index: 1000;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        border: 3px solid #fff;
        text-align: center;
      `;
      notification.textContent = `üó∫Ô∏è Map expanded to Fire Level ${currentFireLevel}! üî•`;
      document.body.appendChild(notification);
      
      // Remove after 3 seconds
      setTimeout(() => {
        notification.remove();
      }, 3000);
    }
    
    // ============================================
    // DAY/NIGHT CYCLE
    // ============================================
    
    function setNightMode(night) {
      isNight = night;
      if (night) {
        cycleIcon.textContent = "üåô";
        scene.background = new THREE.Color(0x0a0a2e);
        ambientLight.intensity = 0.2;
        directionalLight.intensity = 0.3;
      } else {
        cycleIcon.textContent = "‚òÄÔ∏è";
        scene.background = new THREE.Color(0x87ceeb);
        ambientLight.intensity = 0.6;
        directionalLight.intensity = 0.8;
      }
    }
    
    function updateDayNightCycle() {
      cycleTimeRemaining--;
      
      const minutes = Math.floor(cycleTimeRemaining / 60);
      const seconds = cycleTimeRemaining % 60;
      cycleCountdown.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      
      // Show warning 20 seconds before night
      if (!isNight && cycleTimeRemaining === 20 && !nightWarningShown) {
        nightWarningShown = true;
        showNightWarning();
      }
      
      // Spawn cultists 10 seconds after night begins
      if (isNight && cycleTimeRemaining === NIGHT_DURATION - 10 && !cultistsSpawned) {
        cultistsSpawned = true;
        spawnCultists();
      }
      
      // Spawn deer monster 5 seconds after night begins (only every 3rd night)
      if (isNight && cycleTimeRemaining === NIGHT_DURATION - 5 && !deerSpawned && currentNight % 3 === 0) {
        deerSpawned = true;
        spawnDeerMonster();
      }
      
      if (cycleTimeRemaining <= 0) {
        if (isNight) {
          // Night ended, new day
          
          // Record night survived for persistence
          recordNightSurvived();
          
          // Award diamond for surviving the night with flashy animation
          awardNightSurvivalDiamond();
          
          // Day advances by 1 + number of beds owned
          const daysToAdd = 1 + bedsOwned;
          currentDay += daysToAdd;
          dayCounter.textContent = currentDay;
          
          // Check for milestone rewards at the start of the new day
          checkMilestones(currentDay);
          updateRewardsDisplay();
          
          cycleTimeRemaining = DAY_DURATION;
          setNightMode(false);
          nightWarningShown = false;
          cultistsSpawned = false;
          cultistsDefeated = 0;
          cultistRewardGiven = false;
          
          // Remove deer monster at dawn
          removeDeerMonster();
          deerSpawned = false;
          
          // Decrement farm plot harvest timer
          if (farmPlotsOwned > 0) {
            farmPlotDaysUntilHarvest -= daysToAdd;
            updateFarmPlotVisuals(); // Show carrots if ready
          }
        } else {
          // Day ended, night begins
          currentNight++; // Track which night this is
          cycleTimeRemaining = NIGHT_DURATION;
          setNightMode(true);
        }
      }
    }
    
    function showNightWarning() {
      // Create overlay div (same style as welcome message)
      const warning = document.createElement('div');
      // Get the game container position to center the warning on the canvas
      const gameContainer = document.querySelector('.game-container');
      const rect = gameContainer.getBoundingClientRect();
      
      warning.style.cssText = `
        position: fixed;
        top: ${rect.top + rect.height / 2}px;
        left: ${rect.left}px;
        width: ${rect.width}px;
        transform: translateY(-50%);
        color: white;
        font-size: 48px;
        font-weight: 700;
        font-family: "Kalam", "Comic Sans MS", cursive;
        z-index: 1000;
        text-align: center;
        pointer-events: none;
        opacity: 1;
        line-height: 1.4;
      `;
      warning.innerHTML = 'YOU WILL BE<br>ATTACKED TONIGHT';
      document.body.appendChild(warning);
      
      // Fade out after 2 seconds
      setTimeout(() => {
        let opacity = 1;
        const fadeInterval = setInterval(() => {
          opacity -= 0.02;
          if (opacity <= 0) {
            opacity = 0;
            clearInterval(fadeInterval);
            warning.remove();
          }
          warning.style.opacity = opacity;
        }, 50);
      }, 2000);
    }
    
    function spawnCultists() {
      // Spawn 3 cultists around the campfire at different positions
      const spawnRadius = 20; // Spawn them at a distance from campfire
      const angles = [0, (2 * Math.PI) / 3, (4 * Math.PI) / 3]; // Evenly spaced
      
      angles.forEach(angle => {
        const x = Math.cos(angle) * spawnRadius;
        const z = Math.sin(angle) * spawnRadius;
        
        const cultist = {
          type: 'cultist',
          action: 'fightCultist',
          x: x,
          z: z,
          targetX: x,
          targetZ: z,
          mesh: createCultist(x, z),
          seekingEntrance: false
        };
        
        cultists.push(cultist);
        scene.add(cultist.mesh);
      });
    }
    
    function showCultistVictoryNotification() {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #7cd992 0%, #5fb377 100%);
        color: white;
        padding: 30px 50px;
        border-radius: 16px;
        font-size: 24px;
        font-weight: bold;
        z-index: 1000;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        border: 3px solid #fff;
        text-align: center;
      `;
      notification.textContent = 'üéâ All cultists defeated! +3 metal üéâ';
      document.body.appendChild(notification);

      // Remove after 3 seconds
      setTimeout(() => {
        notification.remove();
      }, 3000);
    }
    
    function endNightEarly() {
      if (!isNight) return; // Only end if it's actually night
      
      // Record night survived for persistence
      recordNightSurvived();
      
      // Award diamond for surviving the night with flashy animation
      awardNightSurvivalDiamond();
      
      // Day advances by 1 + number of beds owned
      const daysToAdd = 1 + bedsOwned;
      currentDay += daysToAdd;
      dayCounter.textContent = currentDay;
      
      // Check for milestone rewards at the start of the new day
      checkMilestones(currentDay);
      updateRewardsDisplay();
      
      cycleTimeRemaining = DAY_DURATION;
      setNightMode(false);
      nightWarningShown = false;
      cultistsSpawned = false;
      cultistsDefeated = 0;
      cultistRewardGiven = false;
      
      // Remove deer monster at dawn
      removeDeerMonster();
      deerSpawned = false;
      
      // Decrement farm plot harvest timer
      if (farmPlotsOwned > 0) {
        farmPlotDaysUntilHarvest -= daysToAdd;
        updateFarmPlotVisuals(); // Show carrots if ready
      }
      
      // Show notification that night ended early
      showCraftNotification('‚òÄÔ∏è Dawn breaks early! The cultists have been vanquished!');
    }

    // ============================================
    // DEER MONSTER
    // ============================================
    
    function spawnDeerMonster() {
      // Spawn deer at edge of world, opposite to player
      const angle = Math.atan2(playerZ, playerX) + Math.PI; // Opposite direction from player
      const spawnRadius = worldRadius - 5;
      const x = Math.cos(angle) * spawnRadius;
      const z = Math.sin(angle) * spawnRadius;
      
      deerMonster = {
        x: x,
        z: z,
        mesh: createDeerMonster(x, z)
      };
      
      scene.add(deerMonster.mesh);
    }
    
    function removeDeerMonster() {
      if (deerMonster) {
        scene.remove(deerMonster.mesh);
        deerMonster = null;
      }
    }
    
    function updateDeerMonster() {
      if (!deerMonster || isPaused || isDialogOpen || isGameOver) return;
      
      const deerSpeed = 0.12; // Slightly slower than player (0.15) so they can outrun
      const deerFleeSpeed = 0.18; // Faster when fleeing from fire
      // safeZoneRadius is a global variable that grows with fire level
      const damageDistance = 1.5; // How close deer needs to be to damage player
      const waitDistance = safeZoneRadius + 2; // Where deer waits when fire is lit
      
      // Check if fire is burning
      const fireIsBurning = fireStrength > 0;
      
      // Calculate deer's distance from campfire center
      const deerDistFromCenter = Math.sqrt(deerMonster.x * deerMonster.x + deerMonster.z * deerMonster.z);
      const deerIsInsideCircle = deerDistFromCenter < safeZoneRadius;
      
      if (fireIsBurning && deerIsInsideCircle) {
        // Fire is lit and deer is inside - RUN AWAY!
        // Move directly away from center (outward)
        const dirX = deerMonster.x / deerDistFromCenter;
        const dirZ = deerMonster.z / deerDistFromCenter;
        deerMonster.x += dirX * deerFleeSpeed;
        deerMonster.z += dirZ * deerFleeSpeed;
        
      } else if (fireIsBurning) {
        // Fire is lit, deer is outside the safe zone
        const dx = playerX - deerMonster.x;
        const dz = playerZ - deerMonster.z;
        const distToPlayer = Math.sqrt(dx * dx + dz * dz);
        
        // Check if player is inside or outside the safe zone
        const playerDistFromCenter = Math.sqrt(playerX * playerX + playerZ * playerZ);
        const playerIsInsideSafeZone = playerDistFromCenter < safeZoneRadius;
        
        if (playerIsInsideSafeZone) {
          // Player is inside safe zone - deer waits at the edge closest to player
          const angleToPlayer = Math.atan2(playerZ, playerX);
          const targetX = Math.cos(angleToPlayer) * waitDistance;
          const targetZ = Math.sin(angleToPlayer) * waitDistance;
          
          const dxTarget = targetX - deerMonster.x;
          const dzTarget = targetZ - deerMonster.z;
          const distToTarget = Math.sqrt(dxTarget * dxTarget + dzTarget * dzTarget);
          
          if (distToTarget > 0.5) {
            const dirX = dxTarget / distToTarget;
            const dirZ = dzTarget / distToTarget;
            deerMonster.x += dirX * deerSpeed;
            deerMonster.z += dirZ * deerSpeed;
          }
        } else {
          // Player is OUTSIDE safe zone - deer chases player directly
          if (distToPlayer > damageDistance) {
            // Calculate direction toward player
            const dirX = dx / distToPlayer;
            const dirZ = dz / distToPlayer;
            
            // Move toward player
            let nextX = deerMonster.x + dirX * deerSpeed;
            let nextZ = deerMonster.z + dirZ * deerSpeed;
            
            // After moving, check if we ended up inside the safe zone and push out if so
            const nextDistFromCenter = Math.sqrt(nextX * nextX + nextZ * nextZ);
            if (nextDistFromCenter < safeZoneRadius) {
              // Push deer back out to the edge of the safe zone
              const pushAngle = Math.atan2(nextZ, nextX);
              nextX = Math.cos(pushAngle) * (safeZoneRadius + 0.1);
              nextZ = Math.sin(pushAngle) * (safeZoneRadius + 0.1);
            }
            
            deerMonster.x = nextX;
            deerMonster.z = nextZ;
          }
          
          // Check for collision with player (outside safe zone)
          if (distToPlayer < damageDistance) {
            const now = Date.now();
            if (now - lastDeerDamageTime >= DEER_DAMAGE_COOLDOWN) {
              lastDeerDamageTime = now;
              damagePlayer(20);
              flashRedScreen();
            }
          }
        }
        
      } else {
        // Fire is out - deer chases player freely!
        const dx = playerX - deerMonster.x;
        const dz = playerZ - deerMonster.z;
        const distToPlayer = Math.sqrt(dx * dx + dz * dz);
        
        if (distToPlayer > damageDistance) {
          // Chase player
          const dirX = dx / distToPlayer;
          const dirZ = dz / distToPlayer;
          deerMonster.x += dirX * deerSpeed;
          deerMonster.z += dirZ * deerSpeed;
        }
        
        // Check for collision with player
        if (distToPlayer < damageDistance) {
          const now = Date.now();
          if (now - lastDeerDamageTime >= DEER_DAMAGE_COOLDOWN) {
            lastDeerDamageTime = now;
            // Damage player
            damagePlayer(20);
            flashRedScreen();
          }
        }
      }
      
      // Update mesh position
      deerMonster.mesh.position.set(deerMonster.x, 0, deerMonster.z);
      
      // Make deer face toward player
      const angleToPlayer = Math.atan2(playerX - deerMonster.x, playerZ - deerMonster.z);
      deerMonster.mesh.rotation.y = angleToPlayer;
    }
    
    function updateCultists() {
      if (isPaused || isDialogOpen) return;
      
      const cultistSpeed = 0.06; // Movement speed
      const fenceRadius = 14.5; // Fence wall radius
      const fenceThickness = 2.5; // How thick the fence barrier is (to catch corner gaps)
      // Entrance is at angle œÄ/2 (positive Z direction, toward camera at bottom of screen)
      const entranceX = 0;
      const entranceZ = fenceRadius + 1; // Target point at the entrance
      const entranceAngle = Math.PI / 2;
      const entranceHalfWidth = Math.PI / 7; // Angular half-width of entrance (~25 degrees each side)
      
      function normalizeAngle(angle) {
        while (angle > Math.PI) angle -= Math.PI * 2;
        while (angle < -Math.PI) angle += Math.PI * 2;
        return angle;
      }
      
      function getRadius(x, z) {
        return Math.sqrt(x * x + z * z);
      }
      
      // Get which segment (0-7) a position falls into
      function getSegmentIndex(x, z) {
        let angle = Math.atan2(z, x);
        if (angle < 0) angle += Math.PI * 2;
        const segmentAngle = Math.PI / 4; // Each segment spans 45 degrees
        return Math.floor((angle + segmentAngle / 2) / segmentAngle) % 8;
      }
      
      // Check if position is in an open segment (entrance or unbuilt wall)
      function isInOpenSegment(x, z) {
        const segment = getSegmentIndex(x, z);
        // Segment 2 is always open (entrance)
        if (segment === 2) return true;
        // Other segments are open if no wall is built there
        return !activeWallSegments.has(segment);
      }
      
      function isInsideFence(x, z) {
        return getRadius(x, z) < fenceRadius - fenceThickness;
      }
      
      function isOutsideFence(x, z) {
        return getRadius(x, z) > fenceRadius + fenceThickness;
      }
      
      function isInFenceZone(x, z) {
        const r = getRadius(x, z);
        return r >= fenceRadius - fenceThickness && r <= fenceRadius + fenceThickness;
      }
      
      // Check if a position is blocked by the fence
      function isBlockedByFence(x, z) {
        if (!isInFenceZone(x, z)) return false;
        // Blocked only if this segment has a wall
        return !isInOpenSegment(x, z);
      }
      
      // Check if movement would be blocked
      function isMovementBlocked(fromX, fromZ, toX, toZ) {
        // Check if destination is blocked
        if (isBlockedByFence(toX, toZ)) {
          return true;
        }
        
        // Check if crossing the fence perimeter (not through an open segment)
        const fromR = getRadius(fromX, fromZ);
        const toR = getRadius(toX, toZ);
        const crossingIn = fromR > fenceRadius && toR < fenceRadius;
        const crossingOut = fromR < fenceRadius && toR > fenceRadius;
        
        if (crossingIn || crossingOut) {
          const midX = (fromX + toX) / 2;
          const midZ = (fromZ + toZ) / 2;
          // Only allow crossing through open segments
          if (!isInOpenSegment(midX, midZ)) {
            return true;
          }
        }
        
        return false;
      }
      
      // Try to move cultist, returns true if moved
      function tryMove(cultist, moveX, moveZ) {
        const newX = cultist.x + moveX;
        const newZ = cultist.z + moveZ;
        
        if (!isMovementBlocked(cultist.x, cultist.z, newX, newZ)) {
          cultist.x = newX;
          cultist.z = newZ;
          return true;
        }
        
        // Try sliding - X only
        if (Math.abs(moveX) > 0.001) {
          const slideX = cultist.x + moveX;
          if (!isMovementBlocked(cultist.x, cultist.z, slideX, cultist.z)) {
            cultist.x = slideX;
            return true;
          }
        }
        
        // Try sliding - Z only
        if (Math.abs(moveZ) > 0.001) {
          const slideZ = cultist.z + moveZ;
          if (!isMovementBlocked(cultist.x, cultist.z, cultist.x, slideZ)) {
            cultist.z = slideZ;
            return true;
          }
        }
        
        return false;
      }
      
      // Push cultist out of fence zone if stuck
      function pushOutOfFence(cultist) {
        if (isBlockedByFence(cultist.x, cultist.z)) {
          const r = getRadius(cultist.x, cultist.z);
          const angle = Math.atan2(cultist.z, cultist.x);
          // Push outward
          const newR = fenceRadius + fenceThickness + 0.5;
          cultist.x = Math.cos(angle) * newR;
          cultist.z = Math.sin(angle) * newR;
          return true;
        }
        return false;
      }
      
      // Find the nearest open segment to a position
      function findNearestOpenSegment(x, z) {
        let angle = Math.atan2(z, x);
        if (angle < 0) angle += Math.PI * 2;
        
        // Check segments in order of angular distance
        const currentSegment = Math.floor((angle + Math.PI / 8) / (Math.PI / 4)) % 8;
        
        // Check current segment and spiral outward
        for (let offset = 0; offset < 8; offset++) {
          // Check both directions
          const seg1 = (currentSegment + offset) % 8;
          const seg2 = (currentSegment - offset + 8) % 8;
          
          if (seg1 === 2 || !activeWallSegments.has(seg1)) {
            return seg1;
          }
          if (offset > 0 && (seg2 === 2 || !activeWallSegments.has(seg2))) {
            return seg2;
          }
        }
        return 2; // Default to entrance
      }
      
      // Get position of an open segment entry point
      function getSegmentEntryPoint(segmentIndex) {
        const segmentAngle = (segmentIndex / 8) * Math.PI * 2;
        return {
          x: Math.cos(segmentAngle) * (fenceRadius + 1),
          z: Math.sin(segmentAngle) * (fenceRadius + 1)
        };
      }
      
      cultists.forEach(cultist => {
        // First, check if stuck in fence and push out
        pushOutOfFence(cultist);
        
        const inside = isInsideFence(cultist.x, cultist.z);
        const cultistAngle = Math.atan2(cultist.z, cultist.x);
        
        let moved = false;
        let targetX = playerX;
        let targetZ = playerZ;
        
        // Calculate direction to player
        const dxToPlayer = playerX - cultist.x;
        const dzToPlayer = playerZ - cultist.z;
        const distToPlayer = Math.sqrt(dxToPlayer * dxToPlayer + dzToPlayer * dzToPlayer);
        
        if (distToPlayer > 0.5) {
          // First, always try to move directly toward the player
          const moveX = (dxToPlayer / distToPlayer) * cultistSpeed;
          const moveZ = (dzToPlayer / distToPlayer) * cultistSpeed;
          moved = tryMove(cultist, moveX, moveZ);
          
          // If blocked and there are walls, find an open segment to go through
          if (!moved && activeWallSegments.size > 0 && !inside) {
            const nearestOpen = findNearestOpenSegment(cultist.x, cultist.z);
            const entryPoint = getSegmentEntryPoint(nearestOpen);
            targetX = entryPoint.x;
            targetZ = entryPoint.z;
            
            const dxToOpen = targetX - cultist.x;
            const dzToOpen = targetZ - cultist.z;
            const distToOpen = Math.sqrt(dxToOpen * dxToOpen + dzToOpen * dzToOpen);
            
            if (distToOpen > 0.5) {
              // Try moving toward the open segment
              const moveToOpenX = (dxToOpen / distToOpen) * cultistSpeed;
              const moveToOpenZ = (dzToOpen / distToOpen) * cultistSpeed;
              moved = tryMove(cultist, moveToOpenX, moveToOpenZ);
              
              // If still blocked, move tangentially around the fence
              if (!moved) {
                const openAngle = (nearestOpen / 8) * Math.PI * 2;
                let cultAngle = cultistAngle;
                if (cultAngle < 0) cultAngle += Math.PI * 2;
                
                let diff = openAngle - cultAngle;
                if (diff > Math.PI) diff -= Math.PI * 2;
                if (diff < -Math.PI) diff += Math.PI * 2;
                const direction = diff > 0 ? 1 : -1;
                
                // Move tangentially around the fence
                const tangentX = -Math.sin(cultistAngle) * direction * cultistSpeed;
                const tangentZ = Math.cos(cultistAngle) * direction * cultistSpeed;
                
                moved = tryMove(cultist, tangentX, tangentZ);
                
                // If still stuck, try moving outward + tangent
                if (!moved) {
                  const outwardX = Math.cos(cultistAngle) * cultistSpeed * 0.5;
                  const outwardZ = Math.sin(cultistAngle) * cultistSpeed * 0.5;
                  tryMove(cultist, outwardX + tangentX * 0.5, outwardZ + tangentZ * 0.5);
                }
              }
            }
          }
        }
        
        // Update mesh position
        if (cultist.mesh) {
          cultist.mesh.position.x = cultist.x;
          cultist.mesh.position.z = cultist.z;
          
          // Face toward target
          const faceDx = targetX - cultist.x;
          const faceDz = targetZ - cultist.z;
          cultist.mesh.rotation.y = Math.atan2(faceDx, faceDz);
        }
      });
      
      // Check if any cultist is close enough to trigger combat
      checkProximity();
    }
    
    function updateHunger() {
      playerHunger = Math.max(0, playerHunger - (100 / 430)); // ~7 minutes to empty (50% slower)
      hungerBar.style.width = `${playerHunger}%`;
      
      // Update hunger bar appearance based on level
      hungerBar.classList.remove('low', 'critical');
      if (playerHunger <= 0) {
        hungerBar.classList.add('critical'); // Flashing red when starving
        hungerBarContainer.classList.add('hunger-starving'); // Add glowing border
      } else {
        hungerBarContainer.classList.remove('hunger-starving'); // Remove glowing border
        if (playerHunger <= 10) {
          hungerBar.classList.add('critical'); // Flashing red at 10% or below
        } else if (playerHunger < 25) {
          hungerBar.classList.add('low'); // Red when below 25%
        }
      }
      
      // Show one-time "you're hungry" warning at 10%
      if (playerHunger <= 10 && playerHunger > 0 && !hungryWarningShown) {
        hungryWarningShown = true;
        showWarningMessage("You're Hungry!", 'hunger-warning');
      }
      
      // Check if player is starving
      if (playerHunger <= 0 && !isStarving) {
        // Just became starving - show one-time "you're starving" message
        isStarving = true;
        if (!starvingWarningShown) {
          starvingWarningShown = true;
          showWarningMessage("You're Starving!", 'hunger-warning');
        }
        startStarvation();
      } else if (playerHunger > 0 && isStarving) {
        // No longer starving
        isStarving = false;
        hungerBarContainer.classList.remove('hunger-starving'); // Make sure border is removed
        if (starvationTimer) {
          clearInterval(starvationTimer);
          starvationTimer = null;
        }
      }
      
      // Reset warnings when hunger goes back above thresholds
      if (playerHunger > 10) {
        hungryWarningShown = false;
      }
      if (playerHunger > 0) {
        starvingWarningShown = false;
      }
    }
    
    function startStarvation() {
      // Immediate damage
      damageFromStarvation();
      
      // Continue damaging every 15 seconds
      starvationTimer = setInterval(() => {
        damageFromStarvation();
      }, 15000); // 15 seconds
    }
    
    function damageFromStarvation() {
      // Flash red
      flashRedScreen();
      
      // Show "You're Hungry!" message
      showHungerWarning();
      
      // Damage health
      damagePlayer(20);
      
      // Check if player died
      if (playerHealth <= 0) {
        showGameOver();
      }
    }
    
    function showHungerWarning() {
      // Legacy function - kept for compatibility
      showWarningMessage("You're Hungry!", 'hunger-warning');
    }
    
    function showWarningMessage(message, className) {
      // Create warning message
      const warning = document.createElement('div');
      warning.className = className;
      warning.textContent = message;
      document.body.appendChild(warning);
      
      // Remove after animation (1 second)
      setTimeout(() => {
        warning.remove();
      }, 1000);
    }
    
    function showGameOver() {
      if (isGameOver) return; // Prevent multiple triggers
      isGameOver = true;
      
      // Stop all game loops and timers
      if (starvationTimer) {
        clearInterval(starvationTimer);
        starvationTimer = null;
      }
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      
      // Force hide math bubble
      mathBubble.classList.remove('active');
      isDialogOpen = false;
      
      // Update game over screen with diamonds earned (use total including milestones)
      const gameOverDiamonds = document.getElementById('gameOverDiamonds');
      const totalDiamonds = calculateTotalDiamonds();
      gameOverDiamonds.textContent = `You earned ${totalDiamonds} diamond${totalDiamonds !== 1 ? 's' : ''}`;
      
      // Show game over overlay
      const gameOverOverlay = document.getElementById('gameOverOverlay');
      gameOverOverlay.classList.add('active');
      
      // Stop player movement and game updates
      isPaused = true;
    }
    
    // ============================================
    // MINIMAP
    // ============================================
    
    function updateMinimap() {
      // Clear canvas
      minimapCtx.fillStyle = '#333';
      minimapCtx.fillRect(0, 0, 150, 150);
      
      // Mark explored areas based on world coordinates (in 2-unit chunks)
      const chunkSize = 2; // World units per chunk
      const chunkX = Math.floor(playerX / chunkSize);
      const chunkZ = Math.floor(playerZ / chunkSize);
      const visChunks = Math.ceil(VISIBILITY_RADIUS / chunkSize);
      
      for (let dx = -visChunks; dx <= visChunks; dx++) {
        for (let dz = -visChunks; dz <= visChunks; dz++) {
          const cx = chunkX + dx;
          const cz = chunkZ + dz;
          const key = `${cx},${cz}`;
          if (!exploredMap.has(key)) {
            exploredMap.add(key);
          }
        }
      }
      
      // Draw explored areas - scale them to current world size
      minimapCtx.fillStyle = '#2d5016';
      exploredMap.forEach(key => {
        const [cx, cz] = key.split(',').map(Number);
        // Convert chunk coordinates to world coordinates
        const worldX = cx * chunkSize;
        const worldZ = cz * chunkSize;
        
        // Convert world coordinates to minimap pixels (relative to current world size)
        const minimapX = ((worldX / worldSize) + 0.5) * 150;
        const minimapZ = ((worldZ / worldSize) + 0.5) * 150;
        const chunkPixelSize = (chunkSize / worldSize) * 150;
        
        // Only draw if within current minimap bounds
        if (minimapX >= 0 && minimapX < 150 && minimapZ >= 0 && minimapZ < 150) {
          minimapCtx.fillRect(minimapX, minimapZ, Math.max(1, chunkPixelSize), Math.max(1, chunkPixelSize));
        }
      });
      
      // Draw campfire (fixed at center)
      const campfireX = 75;
      const campfireY = 75;
      minimapCtx.fillStyle = '#ff4500';
      minimapCtx.beginPath();
      minimapCtx.arc(campfireX, campfireY, 3, 0, Math.PI * 2);
      minimapCtx.fill();
      
      // Draw chests on minimap
      for (const chest of chestEntities) {
          const chestMinimapX = ((chest.x / worldSize) + 0.5) * 150;
          const chestMinimapY = ((chest.z / worldSize) + 0.5) * 150;
          
          // Chest colors for minimap
          const chestMinimapColors = {
            wooden: '#8B4513',
            golden: '#FFD700',
            ruby: '#E0115F',
            diamond: '#00BFFF',
            obsidian: '#9400D3'
          };
          
          const chestColor = chestMinimapColors[chest.tier] || '#8B4513';
          
          // Draw pulsing chest icon
          const pulseSize = 4 + Math.sin(Date.now() / 200) * 1;
          
          // Outer glow
          minimapCtx.fillStyle = chestColor;
          minimapCtx.globalAlpha = 0.3;
          minimapCtx.beginPath();
          minimapCtx.arc(chestMinimapX, chestMinimapY, pulseSize + 3, 0, Math.PI * 2);
          minimapCtx.fill();
          
          // Inner chest
          minimapCtx.globalAlpha = 1;
          minimapCtx.fillRect(chestMinimapX - pulseSize/2, chestMinimapY - pulseSize/2, pulseSize, pulseSize);
      }
      
      // Draw player
      const playerMinimapX = ((playerX / worldSize) + 0.5) * 150;
      const playerMinimapY = ((playerZ / worldSize) + 0.5) * 150;
      
      // Yellow square face
      minimapCtx.fillStyle = '#FFD700';
      minimapCtx.fillRect(playerMinimapX - 4, playerMinimapY - 4, 8, 8);
      
      // Eyes
      minimapCtx.fillStyle = '#000';
      minimapCtx.fillRect(playerMinimapX - 2, playerMinimapY - 2, 1, 1);
      minimapCtx.fillRect(playerMinimapX + 1, playerMinimapY - 2, 1, 1);
      
      // Mouth
      minimapCtx.fillRect(playerMinimapX - 1, playerMinimapY + 1, 2, 1);
    }
    
    // ============================================
    // INVENTORY ACTIONS
    // ============================================
    
    // Helper function to update hunger bar appearance
    function updateHungerBarAppearance() {
      hungerBar.classList.remove('low', 'critical');
      hungerBarContainer.classList.remove('hunger-starving');
      if (playerHunger <= 0) {
        hungerBar.classList.add('critical');
        hungerBarContainer.classList.add('hunger-starving');
      } else if (playerHunger < 25) {
        hungerBar.classList.add('low');
      }
    }
    
    // Helper function to update inventory display counts
    function updateInventoryDisplay() {
      // Food items - always visible
      carrotCount.textContent = carrots;
      stewCount.textContent = stew;
    }
    
    // Update weapons display based on rewards state
    function updateWeaponsDisplay() {
      const axeName = document.getElementById('axeName');
      const spearItem = document.getElementById('spearItem');
      
      // Update axe display based on upgrades
      if (rewardsState.weapons.hasChainsaw) {
        axeName.textContent = "‚õìÔ∏è Chainsaw";
        axeItem.querySelector('.inv-dropdown-icon').textContent = "‚õìÔ∏è";
      } else if (rewardsState.weapons.hasGoodAxe) {
        axeName.textContent = "Good Axe";
        axeItem.querySelector('.inv-dropdown-icon').textContent = "ü™ì";
      } else {
        axeName.textContent = "Old Axe";
      }
      
      // Show/hide spear
      if (rewardsState.weapons.hasSpear) {
        spearItem.style.display = 'flex';
      } else {
        spearItem.style.display = 'none';
      }
    }
    
    // Carrots: Restore 3% hunger (Iron Stomach: +25%)
    carrotItem.addEventListener('click', (e) => {
      e.stopPropagation();
      if (carrots > 0) {
        carrots--;
        carrotCount.textContent = carrots;
        const hungerRestore = Math.floor(3 * getFoodHealingMultiplier());
        playerHunger = Math.min(100, playerHunger + hungerRestore);
        hungerBar.style.width = `${playerHunger}%`;
        updateHungerBarAppearance();
        updateInventoryDisplay();
        carrotItem.classList.add('pulse');
        setTimeout(() => carrotItem.classList.remove('pulse'), 300);
      }
    });
    
    // Meat: Restore 10% hunger (Iron Stomach: +25%)
    meatItem.addEventListener('click', (e) => {
      e.stopPropagation();
      const currentMeat = parseInt(meatCount.textContent, 10);
      if (currentMeat > 0) {
        meatCount.textContent = currentMeat - 1;
        const hungerRestore = Math.floor(10 * getFoodHealingMultiplier());
        playerHunger = Math.min(100, playerHunger + hungerRestore);
        hungerBar.style.width = `${playerHunger}%`;
        updateHungerBarAppearance();
        updateInventoryDisplay();
        meatItem.classList.add('pulse');
        setTimeout(() => meatItem.classList.remove('pulse'), 300);
      }
    });
    
    // Stew: Restore 30% hunger (Iron Stomach: +25%)
    stewItem.addEventListener('click', (e) => {
      e.stopPropagation();
      if (stew > 0) {
        stew--;
        stewCount.textContent = stew;
        const hungerRestore = Math.floor(30 * getFoodHealingMultiplier());
        playerHunger = Math.min(100, playerHunger + hungerRestore);
        hungerBar.style.width = `${playerHunger}%`;
        updateHungerBarAppearance();
        updateInventoryDisplay();
        stewItem.classList.add('pulse');
        setTimeout(() => stewItem.classList.remove('pulse'), 300);
      }
    });
    
    // Wood: Add to fire if near campfire
    woodItem.addEventListener('click', (e) => {
      e.stopPropagation();
      const currentWood = parseInt(woodCount.textContent, 10);
      if (currentWood > 0 && isNearCampfire) {
        woodCount.textContent = currentWood - 1;
        // Level 1: 8.5% per wood, Level 2+: 3% per wood (about 65% less effective)
        const woodValue = currentFireLevel === 1 ? 8.5 : 3;
        fireStrength = Math.min(100, fireStrength + woodValue);
        fireBar.style.width = `${fireStrength}%`;
        checkFireLevelUp();
        updateInventoryDisplay();
        woodItem.classList.add('pulse');
        setTimeout(() => woodItem.classList.remove('pulse'), 300);
      } else if (currentWood > 0 && !isNearCampfire) {
        alert("You must be near the campfire to add wood!");
      }
    });
    
    // Metal: No action (crafting only)
    metalItem.addEventListener('click', (e) => {
      e.stopPropagation();
      // No action - for crafting only
    });
    
    // Old Axe: No action yet
    axeItem.addEventListener('click', (e) => {
      e.stopPropagation();
      // No action - passive weapon upgrade
    });
    
    // Spear: No action (passive upgrade)
    spearItem.addEventListener('click', (e) => {
      e.stopPropagation();
      // No action - passive weapon upgrade
    });
    
    // Fuel: Add to fire if near campfire
    fuelItem.addEventListener('click', (e) => {
      e.stopPropagation();
      const currentFuel = parseInt(coalCount.textContent, 10);
      if (currentFuel > 0 && isNearCampfire) {
        coalCount.textContent = currentFuel - 1;
        // Level 1: 25.5% per fuel (3x wood), Level 2+: 9% per fuel (3x the level 2+ wood, ~65% less effective)
        const fuelValue = currentFireLevel === 1 ? 25.5 : 9;
        fireStrength = Math.min(100, fireStrength + fuelValue);
        fireBar.style.width = `${fireStrength}%`;
        checkFireLevelUp();
        updateInventoryDisplay();
        fuelItem.classList.add('pulse');
        setTimeout(() => fuelItem.classList.remove('pulse'), 300);
      } else if (currentFuel > 0 && !isNearCampfire) {
        alert("You must be near the campfire to add fuel!");
      }
    });
    

    // ============================================
    // CRAFTING SYSTEM
    // ============================================
    
    const craftingRecipes = {
      // Tier 1
      map: { tier: 1, wood: 3, metal: 0, name: 'Map', icon: 'üó∫Ô∏è', desc: 'Reveals the minimap' },
      oldBed: { tier: 1, wood: 20, metal: 0, name: 'Old Bed', icon: 'üõèÔ∏è', desc: '+1 day per night' },
      upgradeTier2: { tier: 1, wood: 5, metal: 1, name: 'Upgrade to Tier 2', icon: '‚¨ÜÔ∏è', desc: 'Unlock better recipes', isUpgrade: true },
      
      // Tier 2
      sunDial: { tier: 2, wood: 0, metal: 5, name: 'Sun Dial', icon: '‚òÄÔ∏è', desc: 'Shows day/night timer' },
      regularBed: { tier: 2, wood: 0, metal: 5, name: 'Regular Bed', icon: 'üõèÔ∏è', desc: '+1 day per night' },
      farmPlot: { tier: 2, wood: 10, metal: 0, name: 'Farm Plot', icon: 'üå±', desc: 'Grow carrots', maxOwned: 10 },
      // logWall: { tier: 2, wood: 12, metal: 0, name: 'Log Wall', icon: 'ü™µ', desc: 'Block cultists', maxOwned: 8 }, // Hidden for now
      // bearTrap: { tier: 2, wood: 0, metal: 3, name: 'Bear Trap', icon: 'ü™§', desc: 'Weaken cultists', maxOwned: 8 }, // Hidden for now
      upgradeTier3: { tier: 2, wood: 15, metal: 15, name: 'Upgrade to Tier 3', icon: '‚¨ÜÔ∏è', desc: 'Unlock final recipes', isUpgrade: true },
      
      // Tier 3
      crockPot: { tier: 3, wood: 15, metal: 10, name: 'Crock Pot', icon: 'üç≤', desc: 'Cook stew for extra hunger' },
      biofuelProcessor: { tier: 3, wood: 12, metal: 12, name: 'Biofuel Processor', icon: 'üß™', desc: 'Convert to efficient fuel' },
      goodBed: { tier: 3, wood: 10, metal: 10, name: 'Good Bed', icon: 'üõèÔ∏è', desc: '+1 day per night' }
    };
    
    function canAfford(recipe) {
      const currentWood = parseInt(woodCount.textContent, 10);
      const currentMetal = parseInt(scrapCount.textContent, 10);
      return currentWood >= recipe.wood && currentMetal >= recipe.metal;
    }
    
    let craftingTooltipElement = null;
    
    function checkCraftingBenchProximity() {
      if (!craftingBenchMesh) return false;
      const dx = playerX - craftingBenchMesh.position.x;
      const dz = playerZ - craftingBenchMesh.position.z;
      const dist = Math.sqrt(dx * dx + dz * dz);
      const isNear = dist < 3; // Interaction distance for crafting bench
      
      // Show tooltip when near (always, not just first time)
      if (isNear && !isCraftingMenuOpen && !isDialogOpen) {
        showCraftingTooltip();
      } else if (!isNear || isCraftingMenuOpen || isDialogOpen) {
        hideCraftingTooltip();
      }
      
      return isNear;
    }
    
    function showCraftingTooltip() {
      if (craftingTooltipElement) return;
      
      craftingTooltipElement = document.createElement('div');
      craftingTooltipElement.className = 'crafting-tooltip';
      craftingTooltipElement.textContent = '‚öíÔ∏è Press E to craft';
      document.body.appendChild(craftingTooltipElement);
    }
    
    function hideCraftingTooltip() {
      if (craftingTooltipElement) {
        craftingTooltipElement.remove();
        craftingTooltipElement = null;
      }
    }
    
    function updateCraftingMenu() {
      craftingItems.innerHTML = '';
      
      const currentWood = parseInt(woodCount.textContent, 10);
      const currentMetal = parseInt(scrapCount.textContent, 10);
      
      // Update inventory display at top
      craftingWoodCount.textContent = currentWood;
      craftingMetalCount.textContent = currentMetal;
      
      Object.entries(craftingRecipes).forEach(([key, recipe]) => {
        // Only show items for current tier or lower
        if (recipe.tier > craftingTier) return;
        
        // Skip upgrade if already at that tier
        if (key === 'upgradeTier2' && craftingTier >= 2) return;
        if (key === 'upgradeTier3' && craftingTier >= 3) return;
        
        // Skip if already crafted unique items
        if (key === 'map' && hasCraftedMap) return;
        if (key === 'sunDial' && hasCraftedSunDial) return;
        if (key === 'crockPot' && hasCraftedCrockPot) return;
        if (key === 'biofuelProcessor' && hasCraftedBiofuelProcessor) return;
        
        // Skip if max owned reached for stackable items
        if (key === 'farmPlot' && farmPlotsOwned >= 10) return;
        if (key === 'logWall' && logWallsOwned >= 8) return;
        if (key === 'bearTrap' && bearTrapsOwned >= 8) return;
        if ((key === 'oldBed' || key === 'regularBed' || key === 'goodBed') && bedsOwned >= 3) return;
        
        const affordable = canAfford(recipe);
        const itemDiv = document.createElement('div');
        itemDiv.className = `crafting-item${affordable ? '' : ' disabled'}${recipe.isUpgrade ? ' upgrade' : ''}`;
        itemDiv.dataset.recipe = key;
        
        // Build cost HTML
        let costHtml = '';
        if (recipe.wood > 0) {
          const woodClass = currentWood >= recipe.wood ? '' : ' insufficient';
          costHtml += `<div class="crafting-cost-item${woodClass}"><span class="crafting-cost-icon">ü™µ</span>${recipe.wood}</div>`;
        }
        if (recipe.metal > 0) {
          const metalClass = currentMetal >= recipe.metal ? '' : ' insufficient';
          costHtml += `<div class="crafting-cost-item${metalClass}"><span class="crafting-cost-icon">üîß</span>${recipe.metal}</div>`;
        }
        
        // Add owned count for stackable items
        let descText = recipe.desc;
        if (recipe.maxOwned) {
          let owned = 0;
          if (key === 'farmPlot') owned = farmPlotsOwned;
          if (key === 'logWall') owned = logWallsOwned;
          if (key === 'bearTrap') owned = bearTrapsOwned;
          descText += ` (${owned}/${recipe.maxOwned})`;
        }
        if (key === 'oldBed' || key === 'regularBed' || key === 'goodBed') {
          descText += ` (${bedsOwned}/3 beds)`;
        }
        
        itemDiv.innerHTML = `
          <div class="crafting-item-left">
            <div class="crafting-item-icon">${recipe.icon}</div>
            <div class="crafting-item-info">
              <div class="crafting-item-name">${recipe.name}</div>
              <div class="crafting-item-desc">${descText}</div>
            </div>
          </div>
          <div class="crafting-item-cost">${costHtml}</div>
        `;
        
        if (affordable) {
          itemDiv.addEventListener('click', () => startCraftingMathProblem(key));
        }
        
        craftingItems.appendChild(itemDiv);
      });
    }
    
    function showCraftingMenu() {
      if (isCraftingMenuOpen) return;
      isCraftingMenuOpen = true;
      updateCraftingMenu();
      craftingMenu.classList.add('active');
      hideCraftingTooltip();
    }
    
    function hideCraftingMenu() {
      isCraftingMenuOpen = false;
      craftingMenu.classList.remove('active');
    }
    
    function startCraftingMathProblem(itemKey) {
      const recipe = craftingRecipes[itemKey];
      if (!recipe || !canAfford(recipe)) return;
      
      pendingCraftItem = itemKey;
      hideCraftingMenu();
      
      const currentWood = parseInt(woodCount.textContent, 10);
      const currentMetal = parseInt(scrapCount.textContent, 10);
      
      // Create math question based on resource cost
      let question, answer;
      
      if (recipe.wood > 0 && recipe.metal > 0) {
        // Both resources needed - ask about wood
        question = `You have ${currentWood} wood and are about to spend ${recipe.wood}.<br><br>How much will you have left?`;
        answer = currentWood - recipe.wood;
      } else if (recipe.wood > 0) {
        // Only wood needed
        question = `You have ${currentWood} wood and are about to spend ${recipe.wood}.<br><br>How much will you have left?`;
        answer = currentWood - recipe.wood;
      } else if (recipe.metal > 0) {
        // Only metal needed
        question = `You have ${currentMetal} metal and are about to spend ${recipe.metal}.<br><br>How much will you have left?`;
        answer = currentMetal - recipe.metal;
      } else {
        // No cost (shouldn't happen, but just in case)
        craftItem(itemKey);
        return;
      }
      
      currentAction = 'craftingMath';
      isDialogOpen = true;
      currentQuestions = [{ equation: question, answer: answer }];
      currentQuestionIndex = 0;
      questionsCorrectFirstTry = [];
      currentQuestionAttempts = 0;
      
      // Release pointer lock so player can type
      if (document.pointerLockElement) {
        document.exitPointerLock();
      }
      
      mathBubbleLabel.textContent = `‚öíÔ∏è Craft ${recipe.name}`;
      mathQuestionCounter.textContent = '';
      mathTimerBar.style.display = 'none';
      mathQuestion.innerHTML = question;
      mathBubbleFeedback.textContent = '';
      mathAnswerInput.value = '';
      mathBubble.classList.add('active');
      mathAnswerInput.focus();
    }
    
    function craftItem(itemKey) {
      const recipe = craftingRecipes[itemKey];
      if (!recipe || !canAfford(recipe)) return;
      
      // Deduct resources
      const currentWood = parseInt(woodCount.textContent, 10);
      const currentMetal = parseInt(scrapCount.textContent, 10);
      woodCount.textContent = currentWood - recipe.wood;
      scrapCount.textContent = currentMetal - recipe.metal;
      
      // Handle each item type
      switch (itemKey) {
        case 'map':
          hasCraftedMap = true;
          minimapSection.style.display = 'block';
          showCraftNotification('üó∫Ô∏è Map crafted! Minimap unlocked.');
          break;
          
        case 'sunDial':
          hasCraftedSunDial = true;
          cycleSection.style.visibility = 'visible';
          showCraftNotification('‚òÄÔ∏è Sun Dial crafted! Timer unlocked.');
          break;
          
        case 'oldBed':
        case 'regularBed':
        case 'goodBed':
          if (bedsOwned < 3 && bedMeshes[bedsOwned]) {
            bedMeshes[bedsOwned].visible = true;
            bedsOwned++;
            showCraftNotification(`üõèÔ∏è Bed crafted! +${bedsOwned} days per night.`);
          }
          break;
          
        case 'farmPlot':
          if (farmPlotsOwned < 10) {
            farmPlotsOwned++;
            // Show the farm plot mesh (all farm plots share one visual)
            if (farmPlotMeshes[0]) {
              farmPlotMeshes[0].visible = true;
              // Start with no carrots visible (need to wait 2 days)
              if (farmPlotsOwned === 1) {
                farmPlotDaysUntilHarvest = 2; // Reset timer when first plot is planted
              }
              updateFarmPlotVisuals();
            }
            showCraftNotification(`üå± Farm plot planted! Harvest in ${farmPlotDaysUntilHarvest} days (${farmPlotsOwned}x multiplier)`);
          }
          break;
          
        case 'logWall':
          if (logWallsOwned < logWallMeshes.length) {
            logWallMeshes[logWallsOwned].visible = true;
            logWallsOwned++;
            // Update active wall segments for cultist pathfinding
            if (logWallsOwned <= wallBuildOrder.length) {
              activeWallSegments.add(wallBuildOrder[logWallsOwned - 1]);
            }
            updateLogWallSegments();
            showCraftNotification(`ü™µ Log wall crafted! (${logWallsOwned}/8)`);
          }
          break;
          
        case 'bearTrap':
          if (bearTrapsOwned < 8 && bearTrapMeshes[bearTrapsOwned]) {
            bearTrapMeshes[bearTrapsOwned].visible = true;
            bearTrapsOwned++;
            showCraftNotification(`ü™§ Bear trap crafted! (${bearTrapsOwned}/8)`);
          }
          break;
          
        case 'crockPot':
          hasCraftedCrockPot = true;
          if (crockPotMesh) {
            crockPotMesh.visible = true;
          }
          showCraftNotification('üç≤ Crock Pot crafted! Stand on it to cook stew.');
          break;
          
        case 'biofuelProcessor':
          hasCraftedBiofuelProcessor = true;
          if (biofuelProcessorMesh) {
            biofuelProcessorMesh.visible = true;
          }
          showCraftNotification('üß™ Biofuel Processor crafted! Stand on it to process biofuel.');
          break;
          
        case 'upgradeTier2':
          craftingTier = 2;
          showCraftNotification('‚¨ÜÔ∏è Upgraded to Tier 2! New recipes unlocked.');
          break;
          
        case 'upgradeTier3':
          craftingTier = 3;
          showCraftNotification('‚¨ÜÔ∏è Upgraded to Tier 3! Final recipes unlocked.');
          break;
      }
      
      // Update displays
      updateCraftingMenu();
      updateInventoryDisplay();
    }
    
    function showCraftNotification(message) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20%;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
        color: white;
        padding: 16px 30px;
        border-radius: 12px;
        font-size: 18px;
        font-weight: 600;
        z-index: 1000;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
        border: 2px solid #fff;
        text-align: center;
      `;
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 2500);
    }
    
    // ============================================
    // STRUCTURE INTERACTIONS
    // ============================================
    
    function checkBiofuelProcessorProximity() {
      if (!biofuelProcessorMesh || !hasCraftedBiofuelProcessor) {
        isNearBiofuelProcessor = false;
        hideBiofuelTooltip();
        return;
      }
      
      const dx = playerX - biofuelProcessorMesh.position.x;
      const dz = playerZ - biofuelProcessorMesh.position.z;
      const dist = Math.sqrt(dx * dx + dz * dz);
      
      isNearBiofuelProcessor = dist < 2.5;
      
      // Show tooltip when near
      const currentMeat = parseInt(meatCount.textContent, 10);
      const currentWood = parseInt(woodCount.textContent, 10);
      
      if (isNearBiofuelProcessor && !isDialogOpen && !isCraftingMenuOpen) {
        if (currentMeat >= 1 && currentWood >= 1) {
          showBiofuelTooltip('üß™ Press E to make biofuel');
        } else {
          showBiofuelTooltip('üß™ Need 1 meat + 1 wood');
        }
      } else {
        hideBiofuelTooltip();
      }
    }
    
    function showBiofuelTooltip(text) {
      if (biofuelTooltipElement) {
        biofuelTooltipElement.textContent = text;
        return;
      }
      
      biofuelTooltipElement = document.createElement('div');
      biofuelTooltipElement.className = 'crafting-tooltip';
      biofuelTooltipElement.textContent = text;
      document.body.appendChild(biofuelTooltipElement);
    }
    
    function hideBiofuelTooltip() {
      if (biofuelTooltipElement) {
        biofuelTooltipElement.remove();
        biofuelTooltipElement = null;
      }
    }
    
    function checkCrockPotProximity() {
      if (!crockPotMesh || !hasCraftedCrockPot) {
        isNearCrockPot = false;
        hideCrockPotTooltip();
        return;
      }
      
      const dx = playerX - crockPotMesh.position.x;
      const dz = playerZ - crockPotMesh.position.z;
      const dist = Math.sqrt(dx * dx + dz * dz);
      
      isNearCrockPot = dist < 2.5;
      
      // Show tooltip when near (and have enough food)
      const totalFood = carrots + parseInt(meatCount.textContent, 10);
      if (isNearCrockPot && !isDialogOpen && !isCraftingMenuOpen) {
        if (totalFood >= 3) {
          showCrockPotTooltip('üç≤ Press E to make stew');
        } else {
          showCrockPotTooltip('üç≤ Need 3 food to make stew');
        }
      } else {
        hideCrockPotTooltip();
      }
    }
    
    function showCrockPotTooltip(text) {
      if (crockPotTooltipElement) {
        crockPotTooltipElement.textContent = text;
        return;
      }
      
      crockPotTooltipElement = document.createElement('div');
      crockPotTooltipElement.className = 'crafting-tooltip';
      crockPotTooltipElement.textContent = text;
      document.body.appendChild(crockPotTooltipElement);
    }
    
    function hideCrockPotTooltip() {
      if (crockPotTooltipElement) {
        crockPotTooltipElement.remove();
        crockPotTooltipElement = null;
      }
    }
    
    function checkFarmPlotReady() {
      return farmPlotsOwned > 0 && farmPlotDaysUntilHarvest <= 0;
    }
    
    // Update farm plot visual - show/hide carrots based on harvest ready state
    function updateFarmPlotVisuals() {
      const farmPlot = farmPlotMeshes[0];
      if (farmPlot && farmPlot.userData.carrotsGroup) {
        farmPlot.userData.carrotsGroup.visible = checkFarmPlotReady();
      }
    }
    
    function showFarmHarvestDialog() {
      const totalCarrots = farmPlotsOwned * 6;
      currentAction = 'harvestFarm';
      isDialogOpen = true;
      currentQuestions = [{
        equation: `You have ${farmPlotsOwned} farm plots. Each grows 6 carrots. How many carrots total?`,
        answer: totalCarrots
      }];
      currentQuestionIndex = 0;
      questionsCorrectFirstTry = [];
      currentQuestionAttempts = 0;
      
      // Release pointer lock so player can type
      if (document.pointerLockElement) {
        document.exitPointerLock();
      }
      
      mathBubbleLabel.textContent = 'üå± Harvest Time!';
      mathQuestionCounter.textContent = '';
      mathTimerBar.style.display = 'none';
      mathQuestion.textContent = currentQuestions[0].equation;
      mathBubbleFeedback.textContent = '';
      mathAnswerInput.value = '';
      mathBubble.classList.add('active');
      mathAnswerInput.focus();
    }
    
    function showCrockPotDialog() {
      const currentMeat = parseInt(meatCount.textContent, 10);
      const totalFood = carrots + currentMeat;
      
      if (totalFood < 3) {
        return; // Tooltip already shows "need 3 food"
      }
      
      hideCrockPotTooltip();
      
      // Figure out what will be used (carrots first, then meat)
      let carrotsToUse = Math.min(carrots, 3);
      let meatToUse = 3 - carrotsToUse;
      
      // Create appropriate math question
      let question, answer;
      
      if (carrotsToUse > 0 && carrotsToUse <= carrots) {
        // We're using some carrots
        question = `You have ${carrots} carrots. Using ${carrotsToUse} for stew. How many carrots left?`;
        answer = carrots - carrotsToUse;
      } else {
        // Using all carrots and some meat
        question = `You have ${currentMeat} meat. Using ${meatToUse} for stew. How much meat left?`;
        answer = currentMeat - meatToUse;
      }
      
      currentAction = 'cookStew';
      isDialogOpen = true;
      currentQuestions = [{ equation: question, answer: answer }];
      currentQuestionIndex = 0;
      questionsCorrectFirstTry = [];
      currentQuestionAttempts = 0;
      
      // Release pointer lock so player can type
      if (document.pointerLockElement) {
        document.exitPointerLock();
      }
      
      mathBubbleLabel.textContent = 'üç≤ Make Stew';
      mathQuestionCounter.textContent = '';
      mathTimerBar.style.display = 'none';
      mathQuestion.textContent = question;
      mathBubbleFeedback.textContent = '';
      mathAnswerInput.value = '';
      mathBubble.classList.add('active');
      // Clear and focus with small delay to prevent 'e' key from being captured
      setTimeout(() => {
        mathAnswerInput.value = '';
        mathAnswerInput.focus();
      }, 50);
    }
    
    function processBiofuelInstant() {
      const currentMeat = parseInt(meatCount.textContent, 10);
      const currentWood = parseInt(woodCount.textContent, 10);
      
      if (currentMeat < 1 || currentWood < 1) {
        return;
      }
      
      hideBiofuelTooltip();
      
      // Deduct resources
      meatCount.textContent = currentMeat - 1;
      woodCount.textContent = currentWood - 1;
      
      // Add biofuel directly to fire
      const biofuelValue = currentFireLevel === 1 ? 17 : 6;
      fireStrength = Math.min(100, fireStrength + biofuelValue);
      fireBar.style.width = `${fireStrength}%`;
      checkFireLevelUp();
      
      // Show notification
      showCraftNotification(`üß™ Biofuel processed! +${biofuelValue}% fire`);
      
      updateInventoryDisplay();
    }

    // ============================================
    // INPUT HANDLERS
    // ============================================
    
    // Prevent swipe-to-go-back navigation (more aggressive)
    let touchStartX = 0;
    
    document.addEventListener('touchstart', (e) => {
      touchStartX = e.touches[0].clientX;
    }, { passive: true });
    
    document.addEventListener('touchmove', (e) => {
      const touchCurrentX = e.touches[0].clientX;
      const deltaX = touchCurrentX - touchStartX;
      
      // Prevent swipe from left edge (back gesture)
      if (touchStartX < 50 && deltaX > 0) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
      
      // Prevent any horizontal swipe
      if (Math.abs(deltaX) > 10) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    }, { passive: false });
    
    // Prevent touchend from triggering navigation
    document.addEventListener('touchend', (e) => {
      e.preventDefault();
    }, { passive: false });
    
    // Also prevent browser back navigation
    history.pushState(null, null, location.href);
    window.addEventListener('popstate', () => {
      history.pushState(null, null, location.href);
    });
    
    // Track last submit time to prevent rapid-fire submissions
    let lastSubmitTime = 0;
    const SUBMIT_COOLDOWN = 500; // 500ms cooldown between submissions
    
    window.addEventListener('keydown', (e) => {
      // Always allow browser refresh (Ctrl+R / Cmd+R)
      if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
        return; // Let the browser handle it
      }
      
      if (isPaused) return; // Ignore all key presses when paused
      
      if (isDialogOpen) {
        // Redirect keypresses to input if not focused
        if (document.activeElement !== mathAnswerInput) {
          if (/^[0-9]$/.test(e.key) || e.key === 'Backspace' || /^[a-zA-Z]$/.test(e.key)) {
            mathAnswerInput.focus();
          }
        }
        if (e.key === 'Enter') {
          // Debounce to prevent mashing
          const now = Date.now();
          if (now - lastSubmitTime >= SUBMIT_COOLDOWN) {
            lastSubmitTime = now;
            handleSubmit();
          }
        }
        return;
      }
      
      // Handle E key for crafting menu, crock pot, and biofuel processor
      if (e.key === 'e' || e.key === 'E') {
        if (isCraftingMenuOpen) {
          hideCraftingMenu();
          hideCraftingTooltip();
        } else if (checkCraftingBenchProximity()) {
          showCraftingMenu();
          hideCraftingTooltip();
        } else if (isNearCrockPot && hasCraftedCrockPot) {
          const totalFood = carrots + parseInt(meatCount.textContent, 10);
          if (totalFood >= 3) {
            showCrockPotDialog();
          }
        } else if (isNearBiofuelProcessor && hasCraftedBiofuelProcessor) {
          const currentMeat = parseInt(meatCount.textContent, 10);
          const currentWood = parseInt(woodCount.textContent, 10);
          if (currentMeat >= 1 && currentWood >= 1) {
            // Process biofuel instantly (no math required)
            processBiofuelInstant();
          }
        }
      }
      
      if (e.key in keys) {
        keys[e.key] = true;
      }
    });
    
    window.addEventListener('keyup', (e) => {
      if (isPaused) return; // Ignore key releases when paused
      
      if (e.key in keys) {
        keys[e.key] = false;
      }
    });
    
    mathSubmitButton.addEventListener('click', () => {
      // Debounce to prevent mashing
      const now = Date.now();
      if (now - lastSubmitTime >= SUBMIT_COOLDOWN) {
        lastSubmitTime = now;
        handleSubmit();
      }
    });
    
    mathAnswerInput.addEventListener('blur', () => {
      if (isDialogOpen && !isGameOver) {
        setTimeout(() => mathAnswerInput.focus(), 10);
      }
    });
    
    // Only allow numbers, backspace, delete, arrows, tab, and enter in math input
    mathAnswerInput.addEventListener('keydown', (e) => {
      const allowedKeys = ['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter', '-'];
      const isNumber = /^[0-9]$/.test(e.key);
      if (!isNumber && !allowedKeys.includes(e.key)) {
        e.preventDefault();
      }
    });
    
    // Crafting menu close button
    craftingCloseBtn.addEventListener('click', () => {
      hideCraftingMenu();
    });
    
    // Game canvas click handler (reserved for future interactions)
    const gameCanvas = document.getElementById('gameCanvas');
    gameCanvas.addEventListener('click', () => {
      if (isPaused || isDialogOpen) return;
      // Currently no click interactions - all structures use E key
    });
    
    // Farm plot proximity check - triggers harvest dialog automatically
    function checkFarmPlotProximity() {
      if (!checkFarmPlotReady() || isDialogOpen) return;
      
      const farmPlot = farmPlotMeshes[0];
      if (!farmPlot || !farmPlot.visible) return;
      
      const dx = playerX - farmPlot.position.x;
      const dz = playerZ - farmPlot.position.z;
      const dist = Math.sqrt(dx * dx + dz * dz);
      
      // Trigger harvest dialog when walking near ready farm plot
      if (dist < 3) {
        showFarmHarvestDialog();
      }
    }
    
    // Pause/Play functionality
    pauseButton.addEventListener('click', () => {
      isPaused = true;
      pauseOverlay.classList.add('active');

      // Pause wolf timer if active
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    });
    
    // Camera toggle button
    cameraToggleBtn.addEventListener('click', () => {
      if (cameraMode === 'third-person') {
        cameraMode = 'first-person';
        cameraToggleBtn.classList.add('first-person');
        cameraToggleBtn.innerHTML = 'üë§'; // First-person icon
        cameraToggleBtn.title = 'Switch to Third Person View';
        camera.fov = FP_FOV;
        camera.updateProjectionMatrix();
        // Reset first-person angles to face current direction
        fpYaw = playerFacingAngle;
        fpPitch = 0;
        // Show crosshair
        fpCrosshair.classList.add('visible');
        fpHint.classList.add('visible');
        // Request pointer lock for mouse look
        canvas.requestPointerLock();
      } else {
        cameraMode = 'third-person';
        cameraToggleBtn.classList.remove('first-person');
        cameraToggleBtn.innerHTML = 'üëÅÔ∏è'; // Third-person icon
        cameraToggleBtn.title = 'Switch to First Person View';
        camera.fov = TP_FOV;
        camera.updateProjectionMatrix();
        // Hide crosshair
        fpCrosshair.classList.remove('visible');
        fpHint.classList.remove('visible');
        // Exit pointer lock
        if (document.pointerLockElement) {
          document.exitPointerLock();
        }
      }
    });
    
    // Pointer lock change handler
    document.addEventListener('pointerlockchange', () => {
      isPointerLocked = document.pointerLockElement === canvas;
      // Update hint visibility based on lock state
      if (cameraMode === 'first-person') {
        fpHint.classList.toggle('visible', !isPointerLocked);
      }
    });
    
    // Mouse movement for first-person look
    document.addEventListener('mousemove', (e) => {
      if (cameraMode === 'first-person' && isPointerLocked) {
        const sensitivity = 0.002;
        fpYaw -= e.movementX * sensitivity;
        fpPitch -= e.movementY * sensitivity;
        // Clamp pitch to prevent flipping
        fpPitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, fpPitch));
      }
    });
    
    // Click canvas to re-lock pointer in first-person mode
    canvas.addEventListener('click', () => {
      if (cameraMode === 'first-person' && !isPointerLocked) {
        canvas.requestPointerLock();
      }
    });
    
    playButton.addEventListener('click', () => {
      isPaused = false;
      pauseOverlay.classList.remove('active');
      
      // Resume wolf/cultist timer if in a timed encounter and not already timed out
      if (isDialogOpen && (currentAction === 'fightWolf' || currentAction === 'fightCultist') && !currentQuestionTimedOut && timeRemaining > 0) {
        startTimer(true); // Pass true to resume with current time
      }
    });
    
    // ============================================
    // GAME LOOP
    // ============================================
    
    // Helper function to check wall collision
    function isPositionBlockedByWall(x, z) {
      const fenceRadius = 14.5;
      const fenceThickness = 2; // Thick enough to catch corner gaps
      const distFromCenter = Math.sqrt(x * x + z * z);
      
      // Check if position is in the fence zone (the thick ring around the fence)
      if (distFromCenter >= fenceRadius - fenceThickness && distFromCenter <= fenceRadius + fenceThickness) {
        // Calculate angle
        let angle = Math.atan2(z, x);
        if (angle < 0) angle += Math.PI * 2;
        
        // Check which segment this angle falls into
        const segmentAngle = Math.PI / 4; // Each segment spans œÄ/4 radians (45 degrees)
        const segmentIndex = Math.floor((angle + segmentAngle / 2) / segmentAngle) % 8;
        
        // Segment 2 is always the entrance (never blocked)
        if (segmentIndex === 2) return false;
        
        // Block only if this segment has a wall built
        if (activeWallSegments.has(segmentIndex)) {
          return true;
        }
      }
      return false;
    }
    
    function updatePlayer() {
      if (isPaused) return; // Don't update if paused
      
      // Global death check - catches any edge cases where health reaches 0
      if (playerHealth <= 0 && !isGameOver) {
        showGameOver();
        return;
      }
      
      if (!isDialogOpen) {
        let moved = false;
        const oldX = playerX;
        const oldZ = playerZ;
        let moveX = 0;
        let moveZ = 0;
        
        if (cameraMode === 'first-person') {
          // First-person: movement relative to camera direction
          const forward = keys.w || keys.ArrowUp;
          const backward = keys.s || keys.ArrowDown;
          const left = keys.a || keys.ArrowLeft;
          const right = keys.d || keys.ArrowRight;
          
          if (forward || backward || left || right) {
            moved = true;
            // Calculate movement direction based on camera yaw
            const sinYaw = Math.sin(fpYaw);
            const cosYaw = Math.cos(fpYaw);
            
            if (forward) {
              const speed = getPlayerSpeed();
              playerX -= sinYaw * speed;
              playerZ -= cosYaw * speed;
            }
            if (backward) {
              const speed = getPlayerSpeed();
              playerX += sinYaw * speed;
              playerZ += cosYaw * speed;
            }
            if (left) {
              const speed = getPlayerSpeed();
              playerX -= cosYaw * speed;
              playerZ += sinYaw * speed;
            }
            if (right) {
              const speed = getPlayerSpeed();
              playerX += cosYaw * speed;
              playerZ -= sinYaw * speed;
            }
          }
        } else {
          // Third-person: original world-relative movement
          const speed = getPlayerSpeed();
          if (keys.w || keys.ArrowUp) {
            playerZ -= speed;
            moveZ -= 1;
            moved = true;
          }
          if (keys.s || keys.ArrowDown) {
            playerZ += speed;
            moveZ += 1;
            moved = true;
          }
          if (keys.a || keys.ArrowLeft) {
            playerX -= speed;
            moveX -= 1;
            moved = true;
          }
          if (keys.d || keys.ArrowRight) {
            playerX += speed;
            moveX += 1;
            moved = true;
          }
          
          // Update player facing direction based on movement (third-person only)
          if (moved && (moveX !== 0 || moveZ !== 0)) {
            playerFacingAngle = Math.atan2(moveX, -moveZ);
          }
        }
        
        // Check wall collision - revert if blocked
        if (moved && isPositionBlockedByWall(playerX, playerZ)) {
          playerX = oldX;
          playerZ = oldZ;
        }
        
        // Clamp player to world boundaries
        const maxCoord = worldSize / 2 - 2;
        playerX = Math.max(-maxCoord, Math.min(maxCoord, playerX));
        playerZ = Math.max(-maxCoord, Math.min(maxCoord, playerZ));
        
        if (moved) {
          checkProximity();
          checkCraftingBenchProximity(); // Check for crafting tooltip
          checkFarmPlotProximity(); // Check for harvest
          checkCrockPotProximity(); // Check for crock pot tooltip
          checkBiofuelProcessorProximity(); // Check for biofuel tooltip
        }
      }

      // Update player mesh position and rotation
      if (playerMesh) {
        playerMesh.position.x = playerX;
        playerMesh.position.z = playerZ;
        // In first-person, rotate player to match camera; in third-person, face movement direction
        playerMesh.rotation.y = (cameraMode === 'first-person') ? fpYaw : playerFacingAngle;
        
        // Hide player mesh in first-person view
        playerMesh.visible = (cameraMode === 'third-person');
      }
      
      // Update camera to follow player
      if (cameraMode === 'third-person') {
        // Third person: camera above and behind player, looking down
        camera.position.x = playerX;
        camera.position.z = playerZ + 30;
        camera.position.y = 30;
        camera.lookAt(playerX, 0, playerZ);
      } else {
        // First person: camera at player eye level with mouse-look
        const eyeHeight = 1.8;
        
        camera.position.x = playerX;
        camera.position.y = eyeHeight;
        camera.position.z = playerZ;
        
        // Calculate look direction from yaw and pitch
        const lookX = playerX - Math.sin(fpYaw) * Math.cos(fpPitch);
        const lookY = eyeHeight + Math.sin(fpPitch);
        const lookZ = playerZ - Math.cos(fpYaw) * Math.cos(fpPitch);
        camera.lookAt(lookX, lookY, lookZ);
      }
      
      checkCampfireHealing();
      updateCultists(); // Update cultist AI
      updateDeerMonster(); // Update deer monster AI
      updateMinimap();
    }
    
    function animate() {
      requestAnimationFrame(animate);
      updatePlayer();
      renderer.render(scene, camera);
    }
    
    // ============================================
    // CAMP STRUCTURES SETUP
    // ============================================
    
    function createCampStructures() {
      // Position #1: Crafting Bench (12 o'clock, inside circle) - ALWAYS VISIBLE
      craftingBenchMesh = createCraftingBench(0, -6);
      scene.add(craftingBenchMesh);
      
      // Position #2: Saplings (top, just outside circle) - 3 trees (hidden for now)
      saplingMeshes.push(createSapling(-2, -9));
      saplingMeshes.push(createSapling(0, -9.5));
      saplingMeshes.push(createSapling(2, -9));
      saplingMeshes.forEach(sapling => {
        scene.add(sapling);
        sapling.visible = false; // Hidden for now
      });
      
      // Position #3: Beds (west side, outside circle) - 3 beds with different colors
      // Rotated 90 degrees counter-clockwise, feet facing the fire, with gaps between
      const bed1 = createBed(-10, -3, 'cyan');
      bed1.rotation.y = Math.PI / 2; // 90 degrees counter-clockwise
      bedMeshes.push(bed1);
      
      const bed2 = createBed(-10, 0, 'brown');
      bed2.rotation.y = Math.PI / 2;
      bedMeshes.push(bed2);
      
      const bed3 = createBed(-10, 3, 'green');
      bed3.rotation.y = Math.PI / 2;
      bedMeshes.push(bed3);
      
      bedMeshes.forEach(bed => scene.add(bed));
      
      // Position #4: Farm Plots (east side, outside circle) - 10 plots stacked in one location
      // Just one visual plot that represents all stacked plots
      // Farm plot at 3 o'clock position, below the midpoint
      const farmPlot = createFarmPlot(10, 3);
      farmPlot.scale.set(1, 1, 1.5); // Make it 3x as long
      farmPlotMeshes.push(farmPlot);
      farmPlotMeshes.forEach(plot => scene.add(plot));
      
      // Position #5: Crock Pot (above farm plot with a small gap)
      // Positioned closer to farm plot
      crockPotMesh = createCrockPot(10, -1);
      scene.add(crockPotMesh);
      
      // Position #6: Biofuel Processor (between 4-5 o'clock, a bit further from fire)
      // 4:30 position: angle = 135 degrees (3œÄ/4 radians)
      const biofuelAngle = (4.5 / 12) * Math.PI * 2 - Math.PI / 2; // Convert clock to radians
      const biofuelRadius = 4;
      biofuelProcessorMesh = createBiofuelProcessor(
        Math.cos(biofuelAngle) * biofuelRadius,
        Math.sin(biofuelAngle) * biofuelRadius
      );
      scene.add(biofuelProcessorMesh);
      
      // Position #7: Log Walls (outer perimeter) - 8 segments forming octagon
      // Create octagon around the camp (large enough to surround everything including trees)
      const wallSegments = 8; // Octagon has 8 sides
      const wallWidth = 12; // Total width of each wall segment (25 logs * 0.5 spacing = 12 units)
      // For octagon: radius = sideLength / (2 * tan(œÄ/8))
      const wallRadius = wallWidth / (2 * Math.tan(Math.PI / 8));
      
      // Create all 7 wall segments (8th is always entrance) but hide them initially
      activeWallSegments.clear();
      for (let buildIndex = 0; buildIndex < wallBuildOrder.length; buildIndex++) {
        const i = wallBuildOrder[buildIndex];
        
        const angle = (i / wallSegments) * Math.PI * 2;
        const x = Math.cos(angle) * wallRadius;
        const z = Math.sin(angle) * wallRadius;
        
        // Rotate wall so each segment is tangent to the circle (forms octagon)
        const rotation = -(angle + Math.PI / 2);
        
        const wall = createLogWallSegment(x, z, rotation);
        logWallMeshes.push(wall);
        scene.add(wall);
      }
      updateLogWallSegments();
      
      // Position #8: Bear Traps - 8 traps in 2 rows of 4 in the fence opening
      // Place them at the fence opening (bottom, around wallRadius)
      const trapStartZ = wallRadius - 1; // Just inside the fence opening
      const trapSpacing = 3; // Wider spacing to fill the opening
      
      // First row of 4 traps
      for (let i = 0; i < 4; i++) {
        const x = -4.5 + (i * trapSpacing);
        bearTrapMeshes.push(createBearTrap(x, trapStartZ));
      }
      
      // Second row of 4 traps (slightly further out)
      for (let i = 0; i < 4; i++) {
        const x = -4.5 + (i * trapSpacing);
        bearTrapMeshes.push(createBearTrap(x, trapStartZ + 2));
      }
      
      bearTrapMeshes.forEach(trap => scene.add(trap));
      
      // Hide all structures except crafting bench initially
      bedMeshes.forEach(bed => bed.visible = false);
      farmPlotMeshes.forEach(plot => plot.visible = false);
      crockPotMesh.visible = false;
      biofuelProcessorMesh.visible = false;
      logWallMeshes.forEach(wall => wall.visible = false);
      bearTrapMeshes.forEach(trap => trap.visible = false);
    }
    
    // ============================================
    // INITIALIZATION
    // ============================================
    
    function init() {
      // Load saved game data
      loadGame();
      recordGameStart();
      console.log('Game initialized with save:', gameSave);
      
      // Initialize XP and streak display
      updateXPDisplay();
      updateStreakDisplay();
      
      // Create ground
      groundMesh = createGround(worldRadius);
      scene.add(groundMesh);
      
      // Create campfire at origin
      campfireMesh = createCampfire(0, 0);
      scene.add(campfireMesh);
      
      // Hide flames initially since fire starts at 0
      updateFlamesVisibility();
      
      // Create all camp structures
      createCampStructures();
      
      // Create player
      playerMesh = createPlayer(playerX, playerZ);
      scene.add(playerMesh);
      
      // Generate entities
      generateEntities();
      
      // Show welcome message
      showWelcomeMessage();
      
      // Start day/night cycle
      setNightMode(false);
      setInterval(() => {
        if (!isPaused) { // Only update timers if not paused
          updateDayNightCycle();
          updateHunger();
          updateFire();
        }
      }, 1000);
      
      // Initial minimap
      updateMinimap();
      
      // Initialize rewards display (all items start as unearned)
      updateRewardsDisplay();
      
      // Start animation loop
      animate();
    }
    
    init();
  </script>

</body>
</html>
