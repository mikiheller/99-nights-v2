<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>99 Nights Math Forest ‚Äì Portal Lobby</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Kalam:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-deep: #02040a;
      --bg-panel: #0c1420;
      --accent-fire: #ff7b00;
      --accent-fire-soft: #ffb347;
      --accent-ok: #7cd992;
      --text-main: #f6f3ea;
      --text-muted: #c4c4c4;
      --border-soft: rgba(255, 255, 255, 0.06);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #101529 0%, #02040a 60%);
      font-family: 'Kalam', cursive;
      color: var(--text-main);
      overflow: hidden;
    }

    .lobby-container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }

    #lobbyCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .lobby-title {
      position: absolute;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 42px;
      font-weight: 700;
      color: var(--accent-fire);
      text-shadow: 0 0 20px rgba(255, 123, 0, 0.5), 0 4px 8px rgba(0,0,0,0.5);
      z-index: 10;
      pointer-events: none;
      text-align: center;
    }

    .lobby-subtitle {
      font-size: 18px;
      color: var(--text-muted);
      margin-top: 8px;
    }

    .portal-tooltip {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(12, 20, 32, 0.95);
      border: 2px solid var(--accent-fire);
      border-radius: 12px;
      padding: 16px 24px;
      z-index: 20;
      text-align: center;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .portal-tooltip.visible {
      opacity: 1;
    }

    .portal-tooltip-name {
      font-size: 24px;
      font-weight: 700;
      color: var(--accent-fire);
      margin-bottom: 8px;
    }

    .portal-tooltip-desc {
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 12px;
    }

    .portal-tooltip-action {
      font-size: 16px;
      color: var(--accent-ok);
    }

    .portal-tooltip.locked .portal-tooltip-name {
      color: #666;
    }

    .portal-tooltip.locked .portal-tooltip-action {
      color: #888;
    }

    .controls-hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      color: var(--text-muted);
      z-index: 10;
      pointer-events: none;
    }

    .controls-hint kbd {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      padding: 2px 8px;
      margin: 0 2px;
    }

    /* Crosshair for first-person view */
    .crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 10;
    }

    .crosshair::before,
    .crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255, 255, 255, 0.7);
      box-shadow: 0 0 3px rgba(0,0,0,0.5);
    }

    .crosshair::before {
      width: 20px;
      height: 2px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .crosshair::after {
      width: 2px;
      height: 20px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
  </style>
</head>
<body>
  <div class="lobby-container">
    <canvas id="lobbyCanvas"></canvas>
    
    <div class="lobby-title">
      üî• 99 Nights üî•
      <div class="lobby-subtitle">Choose Your Challenge</div>
    </div>
    
    <div class="crosshair"></div>
    
    <div id="portalTooltip" class="portal-tooltip">
      <div class="portal-tooltip-name" id="tooltipName">Adding</div>
      <div class="portal-tooltip-desc" id="tooltipDesc">Practice addition problems</div>
      <div class="portal-tooltip-action" id="tooltipAction">Press ENTER or CLICK to enter</div>
    </div>
    
    <div class="controls-hint">
      <kbd>‚Üë</kbd><kbd>‚Üì</kbd><kbd>‚Üê</kbd><kbd>‚Üí</kbd> or <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> to move ‚Ä¢ Mouse to look ‚Ä¢ Walk through a portal to enter!
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ============================================
    // PORTAL CONFIGURATION
    // ============================================
    
    // All portals in a single line so you can see more are coming!
    const PORTALS = [
      { 
        id: 'addition', 
        name: '‚ûï Adding', 
        description: 'Addition problems from easy to challenging',
        locked: false,
        position: { x: -50, z: -20 }
      },
      { 
        id: 'subtraction', 
        name: '‚ûñ Subtracting', 
        description: 'Subtraction problems to sharpen your skills',
        locked: false,
        position: { x: -30, z: -20 }
      },
      { 
        id: 'advanced_add_sub', 
        name: '‚ûï‚ûñ Advanced +‚àí', 
        description: 'Challenging addition and subtraction',
        locked: true,
        position: { x: -10, z: -20 }
      },
      { 
        id: 'multiplication', 
        name: '‚úñÔ∏è Multiplying', 
        description: 'Multiplication tables and beyond',
        locked: true,
        position: { x: 10, z: -20 }
      },
      { 
        id: 'division', 
        name: '‚ûó Dividing', 
        description: 'Division problems and remainders',
        locked: true,
        position: { x: 30, z: -20 }
      },
      { 
        id: 'advanced_mul_div', 
        name: '‚úñÔ∏è‚ûó Advanced √ó√∑', 
        description: 'Master-level multiplication and division',
        locked: true,
        position: { x: 50, z: -20 }
      }
    ];

    // ============================================
    // THREE.JS SETUP
    // ============================================
    
    const canvas = document.getElementById('lobbyCanvas');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a1628);
    scene.fog = new THREE.Fog(0x0a1628, 30, 80);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 2, 15);
    
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x334466, 0.4);
    scene.add(ambientLight);
    
    const moonLight = new THREE.DirectionalLight(0x8899bb, 0.3);
    moonLight.position.set(10, 20, 10);
    scene.add(moonLight);

    // ============================================
    // VOXEL HELPERS (matching game style)
    // ============================================
    
    function createVoxelBox(width, height, depth, color) {
      const geometry = new THREE.BoxGeometry(width, height, depth);
      const material = new THREE.MeshLambertMaterial({ color });
      return new THREE.Mesh(geometry, material);
    }

    // ============================================
    // GROUND
    // ============================================
    
    function createGround() {
      const size = 100;
      const geometry = new THREE.PlaneGeometry(size, size);
      
      // Create grass texture like the game
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      
      ctx.fillStyle = '#1a3d1a';
      ctx.fillRect(0, 0, 64, 64);
      
      // Add grass details
      for (let i = 0; i < 100; i++) {
        const x = Math.random() * 64;
        const y = Math.random() * 64;
        ctx.fillStyle = Math.random() > 0.5 ? '#2a5a2a' : '#0f2f0f';
        ctx.fillRect(x, y, 2, 2);
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(25, 25);
      
      const material = new THREE.MeshLambertMaterial({ map: texture });
      const ground = new THREE.Mesh(geometry, material);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      
      return ground;
    }

    // ============================================
    // TREES (background decoration)
    // ============================================
    
    function createTree(x, z) {
      const group = new THREE.Group();
      
      // Trunk
      const trunk = createVoxelBox(1, 4, 1, 0x4a3728);
      trunk.position.y = 2;
      group.add(trunk);
      
      // Foliage layers
      const foliageColors = [0x2d5a2d, 0x1e4a1e, 0x3d6a3d];
      const foliageSizes = [
        { w: 5, h: 2, d: 5, y: 5 },
        { w: 4, h: 2, d: 4, y: 7 },
        { w: 2, h: 2, d: 2, y: 9 }
      ];
      
      foliageSizes.forEach((size, i) => {
        const foliage = createVoxelBox(size.w, size.h, size.d, foliageColors[i % 3]);
        foliage.position.y = size.y;
        group.add(foliage);
      });
      
      group.position.set(x, 0, z);
      return group;
    }

    // ============================================
    // PORTAL CREATION
    // ============================================
    
    function createPortal(portalData) {
      const group = new THREE.Group();
      group.userData = { portal: portalData };
      
      const isLocked = portalData.locked;
      
      // Portal frame (stone archway)
      const frameColor = isLocked ? 0x333333 : 0x5a4a3a;
      const glowColor = isLocked ? 0x222222 : 0xff7b00;
      
      // Left pillar
      const leftPillar = createVoxelBox(2, 10, 2, frameColor);
      leftPillar.position.set(-4, 5, 0);
      group.add(leftPillar);
      
      // Right pillar
      const rightPillar = createVoxelBox(2, 10, 2, frameColor);
      rightPillar.position.set(4, 5, 0);
      group.add(rightPillar);
      
      // Top arch
      const topArch = createVoxelBox(10, 2, 2, frameColor);
      topArch.position.set(0, 10, 0);
      group.add(topArch);
      
      // Portal glow surface
      const portalGeometry = new THREE.PlaneGeometry(6, 8);
      
      if (!isLocked) {
        // Glowing portal effect
        const portalMaterial = new THREE.MeshBasicMaterial({ 
          color: glowColor,
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide
        });
        const portalSurface = new THREE.Mesh(portalGeometry, portalMaterial);
        portalSurface.position.set(0, 5, 0);
        portalSurface.userData.isPortalSurface = true;
        group.add(portalSurface);
        
        // Add point light for glow
        const portalLight = new THREE.PointLight(glowColor, 1, 15);
        portalLight.position.set(0, 5, 2);
        group.add(portalLight);
      } else {
        // Locked portal - chains/bars
        const barColor = 0x444444;
        for (let i = 0; i < 4; i++) {
          const bar = createVoxelBox(0.3, 8, 0.3, barColor);
          bar.position.set(-2 + i * 1.5, 5, 0);
          group.add(bar);
        }
        
        // Lock icon (simple representation)
        const lock = createVoxelBox(2, 2, 1, 0x666666);
        lock.position.set(0, 3, 0.5);
        group.add(lock);
      }
      
      // Sign with portal name
      const signGeometry = new THREE.PlaneGeometry(8, 2);
      const signCanvas = document.createElement('canvas');
      signCanvas.width = 256;
      signCanvas.height = 64;
      const signCtx = signCanvas.getContext('2d');
      
      signCtx.fillStyle = isLocked ? '#222' : '#1a0a00';
      signCtx.fillRect(0, 0, 256, 64);
      
      signCtx.font = 'bold 28px Kalam, cursive';
      signCtx.textAlign = 'center';
      signCtx.fillStyle = isLocked ? '#666' : '#ffb347';
      signCtx.fillText(portalData.name, 128, 42);
      
      const signTexture = new THREE.CanvasTexture(signCanvas);
      const signMaterial = new THREE.MeshBasicMaterial({ map: signTexture, transparent: true });
      const sign = new THREE.Mesh(signGeometry, signMaterial);
      sign.position.set(0, 12, 0);
      group.add(sign);
      
      group.position.set(portalData.position.x, 0, portalData.position.z);
      
      return group;
    }

    // ============================================
    // SCENE SETUP
    // ============================================
    
    // Add ground
    scene.add(createGround());
    
    // Add trees for atmosphere
    const treePositions = [
      [-40, -30], [-35, -15], [-45, 5], [-38, 20],
      [40, -30], [35, -15], [45, 5], [38, 20],
      [-20, -40], [0, -45], [20, -40],
      [-25, 30], [0, 35], [25, 30]
    ];
    
    treePositions.forEach(([x, z]) => {
      scene.add(createTree(x, z));
    });
    
    // Create portals
    const portalMeshes = [];
    PORTALS.forEach(portalData => {
      const portal = createPortal(portalData);
      scene.add(portal);
      portalMeshes.push(portal);
    });
    
    // Add central campfire for ambiance
    function createCampfire() {
      const group = new THREE.Group();
      
      // Logs
      const logColor = 0x4a3728;
      for (let i = 0; i < 4; i++) {
        const log = createVoxelBox(0.4, 0.4, 2, logColor);
        log.rotation.y = (i / 4) * Math.PI;
        log.position.y = 0.2;
        group.add(log);
      }
      
      // Fire glow
      const fireLight = new THREE.PointLight(0xff6600, 2, 20);
      fireLight.position.y = 1;
      group.add(fireLight);
      
      // Simple flame shapes
      const flameColors = [0xff4400, 0xff6600, 0xffaa00];
      for (let i = 0; i < 5; i++) {
        const flame = createVoxelBox(0.3, 1 + Math.random(), 0.3, flameColors[i % 3]);
        flame.position.set((Math.random() - 0.5) * 0.8, 0.5 + Math.random() * 0.5, (Math.random() - 0.5) * 0.8);
        flame.userData.isFlame = true;
        flame.userData.baseY = flame.position.y;
        group.add(flame);
      }
      
      return group;
    }
    
    const campfire = createCampfire();
    campfire.position.set(0, 0, 5);
    scene.add(campfire);

    // ============================================
    // PLAYER CONTROLS
    // ============================================
    
    let playerX = 0;
    let playerZ = 12;
    let yaw = 0;
    let pitch = 0;
    const playerSpeed = 0.15;
    
    const keys = {};
    
    document.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
      // Also track arrow keys
      keys[e.key] = true;
    });
    
    document.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
      keys[e.key] = false;
    });
    
    // Mouse look
    let isPointerLocked = false;
    
    canvas.addEventListener('click', () => {
      if (!isPointerLocked) {
        canvas.requestPointerLock();
      }
    });
    
    document.addEventListener('pointerlockchange', () => {
      isPointerLocked = document.pointerLockElement === canvas;
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!isPointerLocked) return;
      
      const sensitivity = 0.002;
      yaw -= e.movementX * sensitivity;
      pitch -= e.movementY * sensitivity;
      pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, pitch));
    });

    // ============================================
    // PORTAL DETECTION
    // ============================================
    
    let nearbyPortal = null;
    const tooltip = document.getElementById('portalTooltip');
    const tooltipName = document.getElementById('tooltipName');
    const tooltipDesc = document.getElementById('tooltipDesc');
    const tooltipAction = document.getElementById('tooltipAction');
    
    let hasEnteredPortal = false; // Prevent double-entry
    
    function checkPortalProximity() {
      const detectionRange = 8;
      const enterRange = 3; // Auto-enter when this close
      let closest = null;
      let closestDist = Infinity;
      
      portalMeshes.forEach(portalMesh => {
        const dx = playerX - portalMesh.position.x;
        const dz = playerZ - portalMesh.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        
        if (dist < detectionRange && dist < closestDist) {
          closest = portalMesh;
          closestDist = dist;
        }
      });
      
      nearbyPortal = closest;
      
      if (nearbyPortal) {
        const portal = nearbyPortal.userData.portal;
        tooltipName.textContent = portal.name;
        tooltipDesc.textContent = portal.description;
        
        if (portal.locked) {
          tooltipAction.textContent = 'üîí Coming Soon!';
          tooltip.classList.add('locked');
        } else {
          tooltipAction.textContent = '‚ñ∂ Walk through to enter!';
          tooltip.classList.remove('locked');
          
          // Auto-enter when walking through the portal
          if (closestDist < enterRange && !hasEnteredPortal) {
            hasEnteredPortal = true;
            enterPortal(portal);
          }
        }
        
        tooltip.classList.add('visible');
      } else {
        tooltip.classList.remove('visible');
      }
    }

    // ============================================
    // ENTER PORTAL
    // ============================================
    
    function enterPortal(portal) {
      // Navigate to game with mode parameter
      window.location.href = `game.html?mode=${portal.id}`;
    }

    // ============================================
    // ANIMATION LOOP
    // ============================================
    
    function animate() {
      requestAnimationFrame(animate);
      
      // Movement (WASD and Arrow keys)
      const moveX = Math.sin(yaw);
      const moveZ = Math.cos(yaw);
      
      if (keys.w || keys.ArrowUp) {
        playerX -= moveX * playerSpeed;
        playerZ -= moveZ * playerSpeed;
      }
      if (keys.s || keys.ArrowDown) {
        playerX += moveX * playerSpeed;
        playerZ += moveZ * playerSpeed;
      }
      if (keys.a || keys.ArrowLeft) {
        playerX -= moveZ * playerSpeed;
        playerZ += moveX * playerSpeed;
      }
      if (keys.d || keys.ArrowRight) {
        playerX += moveZ * playerSpeed;
        playerZ -= moveX * playerSpeed;
      }
      
      // Clamp to world
      playerX = Math.max(-60, Math.min(60, playerX));
      playerZ = Math.max(-40, Math.min(30, playerZ));
      
      // Update camera
      camera.position.set(playerX, 2, playerZ);
      
      const lookX = playerX - Math.sin(yaw) * Math.cos(pitch);
      const lookY = 2 + Math.sin(pitch);
      const lookZ = playerZ - Math.cos(yaw) * Math.cos(pitch);
      camera.lookAt(lookX, lookY, lookZ);
      
      // Check portal proximity
      checkPortalProximity();
      
      // Animate flames
      scene.traverse(obj => {
        if (obj.userData.isFlame) {
          obj.position.y = obj.userData.baseY + Math.sin(Date.now() * 0.01 + obj.id) * 0.1;
          obj.scale.y = 0.8 + Math.sin(Date.now() * 0.015 + obj.id) * 0.3;
        }
      });
      
      // Animate portal glow
      portalMeshes.forEach(portal => {
        portal.traverse(child => {
          if (child.userData.isPortalSurface) {
            child.material.opacity = 0.4 + Math.sin(Date.now() * 0.003) * 0.2;
          }
        });
      });
      
      renderer.render(scene, camera);
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    animate();
  </script>
</body>
</html>

